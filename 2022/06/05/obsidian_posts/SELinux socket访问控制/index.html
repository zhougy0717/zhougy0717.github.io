<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhougy0717.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="内核socket架构介绍socket编程的用户态接口是：12int socketpair(int domain, int type, int protocol, int fd[2]);int socket(int domain, int type, int protocol);  domain定义在Linux内核目录include&#x2F;linux&#x2F;socket.h文件中，常用的有:![[socket">
<meta property="og:type" content="article">
<meta property="og:title" content="SELinux socket访问控制">
<meta property="og:url" content="https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Big Ben">
<meta property="og:description" content="内核socket架构介绍socket编程的用户态接口是：12int socketpair(int domain, int type, int protocol, int fd[2]);int socket(int domain, int type, int protocol);  domain定义在Linux内核目录include&#x2F;linux&#x2F;socket.h文件中，常用的有:![[socket">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-05T13:25:27.461Z">
<meta property="article:modified_time" content="2022-09-02T14:03:33.817Z">
<meta property="article:author" content="Ben Zhou">
<meta property="article:tag" content="selinux">
<meta property="article:tag" content="can">
<meta property="article:tag" content="network">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","path":"2022/06/05/obsidian_posts/SELinux socket访问控制/","title":"SELinux socket访问控制"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SELinux socket访问控制 | Big Ben</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Big Ben</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一个半吊子的编码爱好者</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8socket%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">内核socket架构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">1.0.1.</span> <span class="nav-text">标签的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">1.0.2.</span> <span class="nav-text">标签的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sockcreate"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">sockcreate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type-transition"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">type transition</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AF-UNIX%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">AF_UNIX访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8Dsocket"><span class="nav-number">1.1.1.</span> <span class="nav-text">匿名socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AF-INET%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">AF_INET访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#node"><span class="nav-number">1.2.1.</span> <span class="nav-text">node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netif"><span class="nav-number">1.2.2.</span> <span class="nav-text">netif</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BD%91%E5%8D%A1%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">如何实现单网卡的绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netifcon%E5%9C%A8%E5%93%AA%E4%BA%9Bhook%E7%82%B9%E7%94%9F%E6%95%88%EF%BC%9F"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">netifcon在哪些hook点生效？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AF-CAN%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">AF_CAN访问控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhougy0717" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhougy0717" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:benzhou.guangyu@gmail.com" title="E-Mail → mailto:benzhou.guangyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Big Ben">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SELinux socket访问控制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-05 21:25:27" itemprop="dateCreated datePublished" datetime="2022-06-05T21:25:27+08:00">2022-06-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-02 22:03:33" itemprop="dateModified" datetime="2022-09-02T22:03:33+08:00">2022-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="内核socket架构介绍"><a href="#内核socket架构介绍" class="headerlink" title="内核socket架构介绍"></a>内核socket架构介绍</h1><p>socket编程的用户态接口是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>domain</strong><br>定义在Linux内核目录include/linux/socket.h文件中，常用的有:<br>![[socket domain.png]]<br>我们通常用<code>AF_</code>(Address Family)取代<code>PF_</code>(Protocol Family)。在内核代码中也有所体现：<br>![[PF与AF的对应关系.png]]<br><strong>type</strong><br>当前定义的类型为：</p>
<ul>
<li>SOCK_STREAM</li>
<li>SOCK_DGRAM</li>
<li>SOCK_RAW</li>
</ul>
<p><strong>protocol</strong><br>决定协议的种类。例如针对AF_INET类型socket，可以有不同的网络协议，例如：SOCK_STREAM的默认协议是IPPROTO_TCP，SOCK_DGRAM的默认协议为IPPROTO_UDP。这些协议类型定义的位置，以musl为例，在include/netinet/in.h中。不过大多时候，传0就好了，例如：<code>socket(AF_INET, SOCK_STREAM, 0)</code></p>
</blockquote>
<p>socket和socketpair都会调用系统调用进入内核，对应的系统调用分别是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(socket, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol) </span><br><span class="line">SYSCALL_DEFINE4(socketpair, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol,<span class="keyword">int</span> __user *, usockvec)</span><br></pre></td></tr></table></figure><br>这两个系统调用会通过<code>sock_create</code>实例化真正的内核的socket object。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = sock_create(family, type, protocol, &amp;sock); </span><br></pre></td></tr></table></figure></p>
<p>我们从socket 的family属性可以看到，Linux希望用socket涵盖所有的通信场景。针对不同的socket使用场景，Linux内核采用了类似面向对象的实现方法。</p>
<pre class="mermaid">classDiagram
    class `struct sock_common`
    class `struct sock` {
        + void *sk_security
    }
    class `struct socket` {
        + const struct proto_ops ops
    }

    `struct sock` o-- `struct sock_common`
    `struct socket` o-- `struct sock`</pre>
`sock_create`调用`__sock_create`最终通过Address Family找到对应socket类注册的create接口，实现具体对象的构造。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure>
在对应子类的create函数中，子类根据type的不同，绑定不同的处理函数指针。以af_unix.c为例。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (sock-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> SOCK_STREAM:</span><br><span class="line">		sock-&gt;ops = &amp;unix_stream_ops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *	Believe it or not BSD has AF_UNIX, SOCK_RAW though</span></span><br><span class="line"><span class="comment">		 *	nothing uses it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	<span class="keyword">case</span> SOCK_RAW:</span><br><span class="line">		sock-&gt;type = SOCK_DGRAM;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> SOCK_DGRAM:</span><br><span class="line">		sock-&gt;ops = &amp;unix_dgram_ops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_SEQPACKET:</span><br><span class="line">		sock-&gt;ops = &amp;unix_seqpacket_ops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -ESOCKTNOSUPPORT;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
跟访问控制有关的信息都存储在struct sock的sk_security成员指针中。

# socket访问控制
SELinux实现了面向主客体的访问控制模型，即所谓的TEAC（Type Enforcement Access Control）。针对文件，SELinux通过在文件系统的扩展属性上设置标签（安全上下文），当进程（主体）访问该文件客体时，SELinux提供的`avc_has_perm`函数会通过查询内存中的policydb，以获取对应的决策结果。针对socket这一类客体，SELinux的工作原理类似，每个socket object都会被打上对应的标签，从而在系统调用的时候对其进行权限判断。

## 打标签
所有类型的socket，对socket打标签的方式都是基本一致的。下面以AF_UNIX socket为例解释Linux内核如何实现socket object打标签。

由于socket object没有文件实体，所以没法像文件一样，通过给文件设置文件系统的扩展属性来实现。socket的标签设置在socket抽象层实现，具体即net/socket.c文件，通过LSM的接口调用SELinux层的接口实现“打标签”。
<pre class="mermaid">graph TD;
    A["__sock_create"] --> B["security_socket_create"];
    B --> C["pf->create"];
    C --> D["security_socket_post_create"]</pre>

<p><code>security_socket_create</code>和<code>security_socket_post_create</code>对应的SELinux hook函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LSM_HOOK_INIT(socket_create, selinux_socket_create), </span><br><span class="line">LSM_HOOK_INIT(socket_post_create, selinux_socket_post_create)</span><br></pre></td></tr></table></figure><br><code>security_socket_create</code>通过下面的代码实现了：</p>
<ul>
<li>family到security class的转换</li>
<li>socket标签的生成<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u32 newsid;</span><br><span class="line">secclass = socket_type_to_security_class(family, type, protocol);</span><br><span class="line">rc = socket_sockcreate_sid(tsec, secclass, &amp;newsid);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里需要注意的是newsid仅仅是一个局部变量，可见该hook点，并未对socket的标签信息进行保存。那么:</p>
<ol>
<li>socket object的标签是在哪儿生成的呢？</li>
<li>socket标签的值具体是什么呢？</li>
</ol>
<h3 id="标签的生成"><a href="#标签的生成" class="headerlink" title="标签的生成"></a>标签的生成</h3><p>第一个问题的答案可以在<code>security_socket_post_create</code>函数中找到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sksec = sock-&gt;sk-&gt;sk_security;</span><br><span class="line">sksec-&gt;sclass = sclass;</span><br><span class="line">sksec-&gt;sid = sid;</span><br></pre></td></tr></table></figure><br>socket object的标签（SID）存储在struct sock结构体的sk_security的sid成员中。关于SID的内容可以参考[[详解SELinux SID]]。<br>下图显示了<code>security_socket_create</code>和<code>security_socket_post_create</code>中对socket SID的两次计算。由于未赋予正确的标签（type与user，role的组合不合法），且SELinux处于permissive模式，所以内核audit子系统报了两次告警。<br>![[对socket标签的两次计算.png]]</p>
<blockquote>
<p><strong>为什么要有两次SID计算？</strong><br>第一次是在创建socket之前，检查进程是否有权限创建该socket，此时尚不具备该socket object，所以自然无法记录。直到security_socket_post_create时，socket object已经创建完毕了，此时再计算出socket的SID，并予以记录。</p>
</blockquote>
<h3 id="标签的计算"><a href="#标签的计算" class="headerlink" title="标签的计算"></a>标签的计算</h3><p>不论是<code>security_socket_create</code>还是<code>security_socket_post_create</code>都会调用<code>socket_sockcreate_sid</code>函数来获取socket object的标签。获取的方法，分两步：</p>
<ol>
<li>如果进程设置了sockcreate属性，则使用该属性指定的标签</li>
<li>否则通过security_transition_sid执行type transition</li>
</ol>
<h4 id="sockcreate"><a href="#sockcreate" class="headerlink" title="sockcreate"></a>sockcreate</h4><p>通过改写进程的sockcreate属性，每个进程可以决定其创建的socket object的标签属性。一旦为该属性赋值，那么socket object的type_transition不再生效。</p>
<p><pre class="mermaid">graph TD;
    A["写/proc/pid/attr/sockcreate文件"] --> B["proc_pid_attr_write"];
    B --> C["security_setprocattr"];
    C --> D["__tsec->sockcreate_sid = xxx"];</pre><br>通过下面的代码，用户态设置的属性值最终被写入到current-&gt;cred-&gt;security-&gt;sockcreate_sid成员中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in security/selinux/hooks.c, selinux_setprocattr函数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;exec&quot;</span>)) &#123;</span><br><span class="line">	tsec-&gt;exec_sid = sid;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;sockcreate&quot;</span>)) &#123;</span><br><span class="line">	tsec-&gt;sockcreate_sid = sid;</span><br><span class="line">&#125; ...</span><br></pre></td></tr></table></figure></p>
<h4 id="type-transition"><a href="#type-transition" class="headerlink" title="type transition"></a>type transition</h4><p>关于type<em>transition可以参考[[28—(6 条消息) 深入理解 SELinux SEAndroid（第一部分）</em>阿拉神农的博客 - CSDN 博客_domain_auto_trans]]，也可以参考官方文档<a target="_blank" rel="noopener" href="https://selinuxproject.org/page/TypeRules">TypeRules - SELinux Wiki</a>。<br>socket的type_transition和其他类型的type_transtion没有区别。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_transition proc_t, source_t, target_t, &#123; xxx_class &#125;</span><br></pre></td></tr></table></figure><br>这条语句的意思是：</p>
<blockquote>
<p>由类型为proc_t创建的，源标签为source_t的客体，如果其类型为xxx_class，则其目标标签为target_t。</p>
</blockquote>
<p>由于socket的起始默认标签，会继承进程的主体标签，所以如果是socket，则上面这样一条语句会变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这里以SOCK_STREAM类型的AF_UNIX socket为例</span><br><span class="line">type_transition proc_t, proc_t, target_t, &#123; unix_stream_socket &#125;</span><br></pre></td></tr></table></figure><br>如果使用refpolicy提供的宏来编写，那么就会写作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetrans_pattern(proc_t, source_t, target_t, &#123; unix_stream_socket &#125;)</span><br></pre></td></tr></table></figure><br><code>filetrans_pattern</code>定义在policy/support/file_patterns.spt文件中。<br>最终socket的标签信息（SID）会被记录在struct sock的sk_security成员中。<br>一旦socket object有了标签信息，并且可以实施type_transition，那么我们就可以将某个进程创建的socket转换为任意我们想要的标签（type），并对其定义任意我们想要的allow规则。</p>
<h2 id="AF-UNIX访问控制"><a href="#AF-UNIX访问控制" class="headerlink" title="AF_UNIX访问控制"></a>AF_UNIX访问控制</h2><p>AF_UNIX socket又称为Unix Domain Socket，简称UDS，中文称为域套接字。UDS还有一些比较特殊的地方。AF_UNIX socket通常用来进行操作系统内部的进程间通信。通过设置sun_family和sun_path来为UDS设置地址。从而完成客户端与服务端的绑定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> *<span class="title">addr</span>;</span></span><br><span class="line">addr-&gt;sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strncpy</span>(addr-&gt;sun_path, path, <span class="keyword">sizeof</span>(addr-&gt;sun_path) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>服务端进程可以调用bind，listen，accept来监听客户端的请求，并用recv和send来响应。客户端进程通过send和recv类接口发送请求。<br>当服务端创建好socket之后，会在目录下生成一个socket文件。而UDS除了标准的（或者通用的）socket object的权限控制之外，还可以对socket文件进行访问控制。</p>
<p>UDS socket文件和普通文件类似，可以设置DAC权限，也可以打标签。区别是UDS socket不能在rootfs中集成，而是在运行时动态生成的。生成之后，可以通过restorecon或者chcon等SELinux工具或接口对其设置安全上下文。UDS socket文件同样可以实现type_transition。使用refpolicy的宏接口可以如下编写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetrans_pattern(proc_t, dir_t, target_t, &#123; sock_file &#125;;</span><br></pre></td></tr></table></figure><br>需要注意以下几点：</p>
<ul>
<li>UDS socket文件和普通文件一样，会默认继承其所在目录的标签，所以文件的源标签要设置成目录的标签</li>
<li>UDS socket的类型（class）是sock_file，如果设置不正确，则type_transtion不会生效。<br>配置好type_transition之后，就可以针对UDS socket文件进行访问控制了。</li>
</ul>
<h3 id="匿名socket"><a href="#匿名socket" class="headerlink" title="匿名socket"></a>匿名socket</h3><p>UDS还有一种特殊的socket，即匿名socket，英文称为abstract namespace socket。此时sun_path的首字符为’\0’。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> *<span class="title">addr</span>;</span></span><br><span class="line">addr-&gt;sun_family = AF_UNIX;</span><br><span class="line">addr-&gt;sun_path[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(&amp;addr-&gt;sun_path[<span class="number">1</span>], path, <span class="keyword">sizeof</span>(addr-&gt;sun_path) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>其实匿名socket比有名socket更简单，其丢失了socket文件的文件访问控制特性，只保留了socket object访问控制。</p>
<h2 id="AF-INET访问控制"><a href="#AF-INET访问控制" class="headerlink" title="AF_INET访问控制"></a>AF_INET访问控制</h2><p>INET型socket除了通用的socket object之外，还针对一些网络属性进行了访问控制。主要包含三种语句：</p>
<ul>
<li>nodecon</li>
<li>portcon</li>
<li>netifcon<br>可以参考官方的网页<a target="_blank" rel="noopener" href="https://selinuxproject.org/page/NetworkStatements">NetworkStatements - SELinux Wiki</a>。本节挑选node和netif相关的控制做简单介绍。</li>
</ul>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>SELinux的nodecon语句在编译时，被加载到policydb中。在security/selinux/hooks.c文件中定义的系统调用hook点的实现时，通过查询policydb，获得node的标签。其实现调用流程如下：</p>
<p><pre class="mermaid">graph TD;
    A["selinux_socket_bind"] --> B["sel_netnode_sid"];
    B --> C["sel_netnode_sid_slow"];
    C --> D["security_node_sid"]</pre><br>在<code>security_node_sid</code>中，查询policydb完成了node标签的查询。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for IPv4</span></span><br><span class="line">c = policydb-&gt;ocontexts[OCON_NODE];</span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line">	<span class="keyword">if</span> (c-&gt;u.node.addr == (addr &amp; c-&gt;u.node.mask))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	c = c-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for IPv6</span></span><br><span class="line">c = policydb-&gt;ocontexts[OCON_NODE6];</span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line">	<span class="keyword">if</span> (match_ipv6_addrmask(addrp, c-&gt;u.node6.addr,</span><br><span class="line">				c-&gt;u.node6.mask))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	c = c-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有了node的标签，SELinux就可以使用avc_has_perm了。<br>![[针对node的访问控制.png]]<br>node的标签为node_t, 其class属性跟随了socket object的class属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_security_struct</span> *<span class="title">sksec</span> =</span> sk-&gt;sk_security;</span><br><span class="line">err = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				   sksec-&gt;sid, sid,</span><br><span class="line">				   sksec-&gt;sclass, node_perm, &amp;ad);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>nodecon语句的特殊性</strong><br>![[nodecon在refpolicy中的支持情况.png]]<br>nodecon是不支持模块化策略的，也就是说在.pp文件中编写nodecon编译会报错（syntax error）。通过semanage工具可以增加nodecon标签条目，例如：semanage node -a -M 255.255.255.255 -t node_t -r s0:c20.c250 -p ipv4 127.0.0.2会生成nodecon语句nodecon ipv4 127.0.0.2 255.255.255.255 system_u:object_r:node_t:s0:c20.c250。<br>这里还需要注意的是：node的type属性不能随便赋予。否则会出现以下错误：<br>![[错误的node type.png]]</p>
</blockquote>
<h3 id="netif"><a href="#netif" class="headerlink" title="netif"></a>netif</h3><p>netif本身倒没什么特别之处，与node的控制方法类似。</p>
<p><pre class="mermaid">graph TD;
    A["selinux_inet_sys_rcv_skb"] --> B["sel_netif_sid"];
    B --> C["sel_netif_sid_slow"];
    C --> D["security_netif_sid"];</pre><br>在<code>security_netif_sid</code>中查找policydb中的netif表格。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = policydb-&gt;ocontexts[OCON_NETIF];</span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, c-&gt;u.name) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	c = c-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>netif的控制有两个比较有意思的地方，下面依次道来。</p>
<h4 id="如何实现单网卡的绑定"><a href="#如何实现单网卡的绑定" class="headerlink" title="如何实现单网卡的绑定"></a>如何实现单网卡的绑定</h4><p>网上搜索了好久，大多是实现如何从指定的网卡发送报文（所谓的绑定）。因为操作系统通常会按照连接或网络的连通性，自动选择发送数据的网卡。也有不少提及通过SO_BINDTODEVICE绑定网卡的实现。但缺乏关键代码。最终通过下面的代码实现了demostration，摘取关键代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">&quot;lo&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;lo&quot;</span>)); <span class="comment">// &quot;lo&quot;就是网卡名</span></span><br><span class="line">ioctl(server_fd, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line">setsockopt(server_fd, SOL_SOCKET, SO_BINDTODEVICE, (<span class="keyword">char</span> *)&amp;ifr, <span class="keyword">sizeof</span>(ifr));</span><br></pre></td></tr></table></figure><br>设置完socket之后，就可以像正常的socket一样访问和监听了。<br>这里要注意为socket设置的绑定地址，即<code>address.sin_addr.s_addr</code>要和SO_BINDTODEVICE指定的地址相匹配，否则会出现connection failed。例如：<code>address.sin_addr.s_addr</code>设置一个与ifreq指定的网卡IP地址不同的IP地址，则bind会返回connection failed的错误。<br>另外，SO_BINDTODEVICE实现的网卡绑定，也不适用netifcon的权限控制。</p>
<h4 id="netifcon在哪些hook点生效？"><a href="#netifcon在哪些hook点生效？" class="headerlink" title="netifcon在哪些hook点生效？"></a>netifcon在哪些hook点生效？</h4><p>netifcon的策略检查点在<code>sel_netif_sid</code>中。该函数的调用者只有以下两个函数：</p>
<ul>
<li>selinux_inet_sys_rcv_skb<ul>
<li>该函数只在fallback peer labelling生效时使用。关于fallback peer labelling，可以关注以下官方网页<a target="_blank" rel="noopener" href="https://selinuxproject.org/page/NB_Networking">NB Networking - SELinux Wiki</a>，以及一些相关的衍生阅读</li>
<li>该函数也有两个调用点，分别是：<ul>
<li>selinux_socket_sock_rcv_skb</li>
<li>selinux_ip_forward</li>
</ul>
</li>
</ul>
</li>
<li>selinux_ip_postroute<ul>
<li>该函数在NetFilter中使用，post routing是一个NetFilter的一个chain的名字。关于NetFilter以及iptables，可以参考[[iptables + SELinux控制socket packet]]。</li>
</ul>
</li>
</ul>
<h2 id="AF-CAN访问控制"><a href="#AF-CAN访问控制" class="headerlink" title="AF_CAN访问控制"></a>AF_CAN访问控制</h2><p>CAN总线是有别于网络报文的另一种总线通信方式。我是用的demo程序是<a target="_blank" rel="noopener" href="https://github.com/linux-can/can-utils">linux-can/can-utils: Linux-CAN / SocketCAN user space applications</a> 中的candump。具体可以看candump.c这个文件。对CAN socket的调用方法大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line">socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">addr.can_family = AF_CAN;</span><br><span class="line"><span class="built_in">strncpy</span>(ifr.ifr_name, can_netif_name, name_size);</span><br><span class="line">bind(sock_fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">nbytes = recvmsg(sock_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>CAN设备可以被作为一张网卡，被监听和读写。如何插入一个虚拟CAN设备，可以参考[[52—How to create a virtual CAN interface on Linux - PragmaticLinux]]。<br>CAN设备的访问控制和其他的对socket object对访问控制是一样的。也可以实现type_transition:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetrans_pattern(candump_t, candump_t, target_t, &#123; can_socket &#125;)</span><br></pre></td></tr></table></figure><br>需要注意的是，对于CAN设备，内核会根据其Address Family或Protocol Family识别其类型（class）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PF_CAN:</span><br><span class="line">	<span class="keyword">return</span> SECCLASS_CAN_SOCKET;</span><br></pre></td></tr></table></figure><br>所以在写策略时，class一定要写对，如果写成了其他的class，那么策略是无法正确生效的。<br>另外，虽然CAN设备被当成一个netif在使用，但针对netif的hook点并没有对CAN设备有针对性的部署。根据[[#netif]]中的描述，针对netif的控制只发生在和网络相关的调用路径上。所以无法针对CAN设备使用netifcon语句。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从Unix Domain Socket（UDS，域套接字，AF_UNIX或AF_LOCAL），INET socket和CAN socket的角度阐述了内核对socket的访问控制实现方式。<br>针对通用socket，内核通过将标签写入内核的socket object中，并在系统调用时，对其进行主客体匹配实现访问控制。<br>针对不同种类的socket，内核还辅以其他相关资源的控制，例如：</p>
<ul>
<li>如果是有名的域套接字还可以对socket文件进行控制，class属性为sock_file</li>
<li>如果是IP地址，还可以结合nodecon进行控制，该语句只能在monolithic策略中编写，无法在modular策略中使能</li>
<li>如果是网卡，可以结合netifcon进行控制，该语句只和网络相关的hook点相关</li>
<li>CAN socket可以使用通用socket进行访问控制，不能使用netifcon进行访问控制。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打赏代表您对我的认可，这会激励我继续向前！</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat_reward_qr.png" alt="Ben Zhou WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay_reward_qr.png" alt="Ben Zhou Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/rss.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/selinux/" rel="tag"># selinux</a>
              <a href="/tags/can/" rel="tag"># can</a>
              <a href="/tags/network/" rel="tag"># network</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/22/obsidian_posts/fPIC%20vs.%20fPIE/" rel="prev" title="fPIC vs. fPIE">
                  <i class="fa fa-chevron-left"></i> fPIC vs. fPIE
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/" rel="next" title="iptables + SELinux控制socket packet">
                  iptables + SELinux控制socket packet <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben Zhou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.12.0/dist/mermaid.min.js","integrity":"sha256-0dD7vUjUCTGJjeLnPotQQJIcSzug5fO6WDMYYyNIX4c="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"zhougy0717/zhougy0717.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
