{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben • All posts by \"network\" tag",
    "description": null,
    "home_page_url": "https://blog.zhougy.top",
    "items": [
        {
            "id": "https://blog.zhougy.top/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
            "url": "https://blog.zhougy.top/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
            "title": "SELinux socket访问控制",
            "date_published": "2022-06-05T13:25:27.461Z",
            "content_html": "<h1 id=\"内核socket架构介绍\"><a href=\"#内核socket架构介绍\" class=\"headerlink\" title=\"内核socket架构介绍\"></a>内核socket架构介绍</h1><p>socket编程的用户态接口是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>domain</strong><br>定义在Linux内核目录include/linux/socket.h文件中，常用的有:<br>![[socket domain.png]]<br>我们通常用<code>AF_</code>(Address Family)取代<code>PF_</code>(Protocol Family)。在内核代码中也有所体现：<br>![[PF与AF的对应关系.png]]<br><strong>type</strong><br>当前定义的类型为：</p>\n<ul>\n<li>SOCK_STREAM</li>\n<li>SOCK_DGRAM</li>\n<li>SOCK_RAW</li>\n</ul>\n<p><strong>protocol</strong><br>决定协议的种类。例如针对AF_INET类型socket，可以有不同的网络协议，例如：SOCK_STREAM的默认协议是IPPROTO_TCP，SOCK_DGRAM的默认协议为IPPROTO_UDP。这些协议类型定义的位置，以musl为例，在include/netinet/in.h中。不过大多时候，传0就好了，例如：<code>socket(AF_INET, SOCK_STREAM, 0)</code></p>\n</blockquote>\n<p>socket和socketpair都会调用系统调用进入内核，对应的系统调用分别是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYSCALL_DEFINE3(socket, <span class=\"keyword\">int</span>, family, <span class=\"keyword\">int</span>, type, <span class=\"keyword\">int</span>, protocol) </span><br><span class=\"line\">SYSCALL_DEFINE4(socketpair, <span class=\"keyword\">int</span>, family, <span class=\"keyword\">int</span>, type, <span class=\"keyword\">int</span>, protocol,<span class=\"keyword\">int</span> __user *, usockvec)</span><br></pre></td></tr></table></figure><br>这两个系统调用会通过<code>sock_create</code>实例化真正的内核的socket object。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retval = sock_create(family, type, protocol, &amp;sock); </span><br></pre></td></tr></table></figure></p>\n<p>我们从socket 的family属性可以看到，Linux希望用socket涵盖所有的通信场景。针对不同的socket使用场景，Linux内核采用了类似面向对象的实现方法。</p>\n<pre class=\"mermaid\">classDiagram\n    class `struct sock_common`\n    class `struct sock` {\n        + void *sk_security\n    }\n    class `struct socket` {\n        + const struct proto_ops ops\n    }\n\n    `struct sock` o-- `struct sock_common`\n    `struct socket` o-- `struct sock`</pre>\n`sock_create`调用`__sock_create`最终通过Address Family找到对应socket类注册的create接口，实现具体对象的构造。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure>\n在对应子类的create函数中，子类根据type的不同，绑定不同的处理函数指针。以af_unix.c为例。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (sock-&gt;type) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_STREAM:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_stream_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *\tBelieve it or not BSD has AF_UNIX, SOCK_RAW though</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *\tnothing uses it.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_RAW:</span><br><span class=\"line\">\t\tsock-&gt;type = SOCK_DGRAM;</span><br><span class=\"line\">\t\tfallthrough;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_DGRAM:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_dgram_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_SEQPACKET:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_seqpacket_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ESOCKTNOSUPPORT;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n跟访问控制有关的信息都存储在struct sock的sk_security成员指针中。\n\n# socket访问控制\nSELinux实现了面向主客体的访问控制模型，即所谓的TEAC（Type Enforcement Access Control）。针对文件，SELinux通过在文件系统的扩展属性上设置标签（安全上下文），当进程（主体）访问该文件客体时，SELinux提供的`avc_has_perm`函数会通过查询内存中的policydb，以获取对应的决策结果。针对socket这一类客体，SELinux的工作原理类似，每个socket object都会被打上对应的标签，从而在系统调用的时候对其进行权限判断。\n\n## 打标签\n所有类型的socket，对socket打标签的方式都是基本一致的。下面以AF_UNIX socket为例解释Linux内核如何实现socket object打标签。\n\n由于socket object没有文件实体，所以没法像文件一样，通过给文件设置文件系统的扩展属性来实现。socket的标签设置在socket抽象层实现，具体即net/socket.c文件，通过LSM的接口调用SELinux层的接口实现“打标签”。\n<pre class=\"mermaid\">graph TD;\n    A[\"__sock_create\"] --> B[\"security_socket_create\"];\n    B --> C[\"pf->create\"];\n    C --> D[\"security_socket_post_create\"]</pre>\n\n<p><code>security_socket_create</code>和<code>security_socket_post_create</code>对应的SELinux hook函数如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSM_HOOK_INIT(socket_create, selinux_socket_create), </span><br><span class=\"line\">LSM_HOOK_INIT(socket_post_create, selinux_socket_post_create)</span><br></pre></td></tr></table></figure><br><code>security_socket_create</code>通过下面的代码实现了：</p>\n<ul>\n<li>family到security class的转换</li>\n<li>socket标签的生成<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u32 newsid;</span><br><span class=\"line\">secclass = socket_type_to_security_class(family, type, protocol);</span><br><span class=\"line\">rc = socket_sockcreate_sid(tsec, secclass, &amp;newsid);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要注意的是newsid仅仅是一个局部变量，可见该hook点，并未对socket的标签信息进行保存。那么:</p>\n<ol>\n<li>socket object的标签是在哪儿生成的呢？</li>\n<li>socket标签的值具体是什么呢？</li>\n</ol>\n<h3 id=\"标签的生成\"><a href=\"#标签的生成\" class=\"headerlink\" title=\"标签的生成\"></a>标签的生成</h3><p>第一个问题的答案可以在<code>security_socket_post_create</code>函数中找到。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sksec = sock-&gt;sk-&gt;sk_security;</span><br><span class=\"line\">sksec-&gt;sclass = sclass;</span><br><span class=\"line\">sksec-&gt;sid = sid;</span><br></pre></td></tr></table></figure><br>socket object的标签（SID）存储在struct sock结构体的sk_security的sid成员中。关于SID的内容可以参考[[详解SELinux SID]]。<br>下图显示了<code>security_socket_create</code>和<code>security_socket_post_create</code>中对socket SID的两次计算。由于未赋予正确的标签（type与user，role的组合不合法），且SELinux处于permissive模式，所以内核audit子系统报了两次告警。<br>![[对socket标签的两次计算.png]]</p>\n<blockquote>\n<p><strong>为什么要有两次SID计算？</strong><br>第一次是在创建socket之前，检查进程是否有权限创建该socket，此时尚不具备该socket object，所以自然无法记录。直到security_socket_post_create时，socket object已经创建完毕了，此时再计算出socket的SID，并予以记录。</p>\n</blockquote>\n<h3 id=\"标签的计算\"><a href=\"#标签的计算\" class=\"headerlink\" title=\"标签的计算\"></a>标签的计算</h3><p>不论是<code>security_socket_create</code>还是<code>security_socket_post_create</code>都会调用<code>socket_sockcreate_sid</code>函数来获取socket object的标签。获取的方法，分两步：</p>\n<ol>\n<li>如果进程设置了sockcreate属性，则使用该属性指定的标签</li>\n<li>否则通过security_transition_sid执行type transition</li>\n</ol>\n<h4 id=\"sockcreate\"><a href=\"#sockcreate\" class=\"headerlink\" title=\"sockcreate\"></a>sockcreate</h4><p>通过改写进程的sockcreate属性，每个进程可以决定其创建的socket object的标签属性。一旦为该属性赋值，那么socket object的type_transition不再生效。</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"写/proc/pid/attr/sockcreate文件\"] --> B[\"proc_pid_attr_write\"];\n    B --> C[\"security_setprocattr\"];\n    C --> D[\"__tsec->sockcreate_sid = xxx\"];</pre><br>通过下面的代码，用户态设置的属性值最终被写入到current-&gt;cred-&gt;security-&gt;sockcreate_sid成员中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in security/selinux/hooks.c, selinux_setprocattr函数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(name, <span class=\"string\">&quot;exec&quot;</span>)) &#123;</span><br><span class=\"line\">\ttsec-&gt;exec_sid = sid;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(name, <span class=\"string\">&quot;sockcreate&quot;</span>)) &#123;</span><br><span class=\"line\">\ttsec-&gt;sockcreate_sid = sid;</span><br><span class=\"line\">&#125; ...</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"type-transition\"><a href=\"#type-transition\" class=\"headerlink\" title=\"type transition\"></a>type transition</h4><p>关于type<em>transition可以参考[[28—(6 条消息) 深入理解 SELinux SEAndroid（第一部分）</em>阿拉神农的博客 - CSDN 博客_domain_auto_trans]]，也可以参考官方文档<a href=\"https://selinuxproject.org/page/TypeRules\">TypeRules - SELinux Wiki</a>。<br>socket的type_transition和其他类型的type_transtion没有区别。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type_transition proc_t, source_t, target_t, &#123; xxx_class &#125;</span><br></pre></td></tr></table></figure><br>这条语句的意思是：</p>\n<blockquote>\n<p>由类型为proc_t创建的，源标签为source_t的客体，如果其类型为xxx_class，则其目标标签为target_t。</p>\n</blockquote>\n<p>由于socket的起始默认标签，会继承进程的主体标签，所以如果是socket，则上面这样一条语句会变成：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这里以SOCK_STREAM类型的AF_UNIX socket为例</span><br><span class=\"line\">type_transition proc_t, proc_t, target_t, &#123; unix_stream_socket &#125;</span><br></pre></td></tr></table></figure><br>如果使用refpolicy提供的宏来编写，那么就会写作：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(proc_t, source_t, target_t, &#123; unix_stream_socket &#125;)</span><br></pre></td></tr></table></figure><br><code>filetrans_pattern</code>定义在policy/support/file_patterns.spt文件中。<br>最终socket的标签信息（SID）会被记录在struct sock的sk_security成员中。<br>一旦socket object有了标签信息，并且可以实施type_transition，那么我们就可以将某个进程创建的socket转换为任意我们想要的标签（type），并对其定义任意我们想要的allow规则。</p>\n<h2 id=\"AF-UNIX访问控制\"><a href=\"#AF-UNIX访问控制\" class=\"headerlink\" title=\"AF_UNIX访问控制\"></a>AF_UNIX访问控制</h2><p>AF_UNIX socket又称为Unix Domain Socket，简称UDS，中文称为域套接字。UDS还有一些比较特殊的地方。AF_UNIX socket通常用来进行操作系统内部的进程间通信。通过设置sun_family和sun_path来为UDS设置地址。从而完成客户端与服务端的绑定。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_un</span> *<span class=\"title\">addr</span>;</span></span><br><span class=\"line\">addr-&gt;sun_family = AF_UNIX;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(addr-&gt;sun_path, path, <span class=\"keyword\">sizeof</span>(addr-&gt;sun_path) - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>服务端进程可以调用bind，listen，accept来监听客户端的请求，并用recv和send来响应。客户端进程通过send和recv类接口发送请求。<br>当服务端创建好socket之后，会在目录下生成一个socket文件。而UDS除了标准的（或者通用的）socket object的权限控制之外，还可以对socket文件进行访问控制。</p>\n<p>UDS socket文件和普通文件类似，可以设置DAC权限，也可以打标签。区别是UDS socket不能在rootfs中集成，而是在运行时动态生成的。生成之后，可以通过restorecon或者chcon等SELinux工具或接口对其设置安全上下文。UDS socket文件同样可以实现type_transition。使用refpolicy的宏接口可以如下编写<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(proc_t, dir_t, target_t, &#123; sock_file &#125;;</span><br></pre></td></tr></table></figure><br>需要注意以下几点：</p>\n<ul>\n<li>UDS socket文件和普通文件一样，会默认继承其所在目录的标签，所以文件的源标签要设置成目录的标签</li>\n<li>UDS socket的类型（class）是sock_file，如果设置不正确，则type_transtion不会生效。<br>配置好type_transition之后，就可以针对UDS socket文件进行访问控制了。</li>\n</ul>\n<h3 id=\"匿名socket\"><a href=\"#匿名socket\" class=\"headerlink\" title=\"匿名socket\"></a>匿名socket</h3><p>UDS还有一种特殊的socket，即匿名socket，英文称为abstract namespace socket。此时sun_path的首字符为’\\0’。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_un</span> *<span class=\"title\">addr</span>;</span></span><br><span class=\"line\">addr-&gt;sun_family = AF_UNIX;</span><br><span class=\"line\">addr-&gt;sun_path[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(&amp;addr-&gt;sun_path[<span class=\"number\">1</span>], path, <span class=\"keyword\">sizeof</span>(addr-&gt;sun_path) - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>其实匿名socket比有名socket更简单，其丢失了socket文件的文件访问控制特性，只保留了socket object访问控制。</p>\n<h2 id=\"AF-INET访问控制\"><a href=\"#AF-INET访问控制\" class=\"headerlink\" title=\"AF_INET访问控制\"></a>AF_INET访问控制</h2><p>INET型socket除了通用的socket object之外，还针对一些网络属性进行了访问控制。主要包含三种语句：</p>\n<ul>\n<li>nodecon</li>\n<li>portcon</li>\n<li>netifcon<br>可以参考官方的网页<a href=\"https://selinuxproject.org/page/NetworkStatements\">NetworkStatements - SELinux Wiki</a>。本节挑选node和netif相关的控制做简单介绍。</li>\n</ul>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><p>SELinux的nodecon语句在编译时，被加载到policydb中。在security/selinux/hooks.c文件中定义的系统调用hook点的实现时，通过查询policydb，获得node的标签。其实现调用流程如下：</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"selinux_socket_bind\"] --> B[\"sel_netnode_sid\"];\n    B --> C[\"sel_netnode_sid_slow\"];\n    C --> D[\"security_node_sid\"]</pre><br>在<code>security_node_sid</code>中，查询policydb完成了node标签的查询。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for IPv4</span></span><br><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NODE];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c-&gt;u.node.addr == (addr &amp; c-&gt;u.node.mask))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for IPv6</span></span><br><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NODE6];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (match_ipv6_addrmask(addrp, c-&gt;u.node6.addr,</span><br><span class=\"line\">\t\t\t\tc-&gt;u.node6.mask))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>有了node的标签，SELinux就可以使用avc_has_perm了。<br>![[针对node的访问控制.png]]<br>node的标签为node_t, 其class属性跟随了socket object的class属性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sk_security_struct</span> *<span class=\"title\">sksec</span> =</span> sk-&gt;sk_security;</span><br><span class=\"line\">err = avc_has_perm(&amp;selinux_state,</span><br><span class=\"line\">\t\t\t\t   sksec-&gt;sid, sid,</span><br><span class=\"line\">\t\t\t\t   sksec-&gt;sclass, node_perm, &amp;ad);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>nodecon语句的特殊性</strong><br>![[nodecon在refpolicy中的支持情况.png]]<br>nodecon是不支持模块化策略的，也就是说在.pp文件中编写nodecon编译会报错（syntax error）。通过semanage工具可以增加nodecon标签条目，例如：semanage node -a -M 255.255.255.255 -t node_t -r s0:c20.c250 -p ipv4 127.0.0.2会生成nodecon语句nodecon ipv4 127.0.0.2 255.255.255.255 system_u:object_r:node_t:s0:c20.c250。<br>这里还需要注意的是：node的type属性不能随便赋予。否则会出现以下错误：<br>![[错误的node type.png]]</p>\n</blockquote>\n<h3 id=\"netif\"><a href=\"#netif\" class=\"headerlink\" title=\"netif\"></a>netif</h3><p>netif本身倒没什么特别之处，与node的控制方法类似。</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"selinux_inet_sys_rcv_skb\"] --> B[\"sel_netif_sid\"];\n    B --> C[\"sel_netif_sid_slow\"];\n    C --> D[\"security_netif_sid\"];</pre><br>在<code>security_netif_sid</code>中查找policydb中的netif表格。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NETIF];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(name, c-&gt;u.name) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>netif的控制有两个比较有意思的地方，下面依次道来。</p>\n<h4 id=\"如何实现单网卡的绑定\"><a href=\"#如何实现单网卡的绑定\" class=\"headerlink\" title=\"如何实现单网卡的绑定\"></a>如何实现单网卡的绑定</h4><p>网上搜索了好久，大多是实现如何从指定的网卡发送报文（所谓的绑定）。因为操作系统通常会按照连接或网络的连通性，自动选择发送数据的网卡。也有不少提及通过SO_BINDTODEVICE绑定网卡的实现。但缺乏关键代码。最终通过下面的代码实现了demostration，摘取关键代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address.sin_family = AF_INET;</span><br><span class=\"line\">address.sin_addr.s_addr = INADDR_ANY;</span><br><span class=\"line\">address.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;ifr, <span class=\"number\">0x00</span>, <span class=\"keyword\">sizeof</span>(ifr));</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(ifr.ifr_name, <span class=\"string\">&quot;lo&quot;</span>, <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;lo&quot;</span>)); <span class=\"comment\">// &quot;lo&quot;就是网卡名</span></span><br><span class=\"line\">ioctl(server_fd, SIOCGIFINDEX, &amp;ifr);</span><br><span class=\"line\">setsockopt(server_fd, SOL_SOCKET, SO_BINDTODEVICE, (<span class=\"keyword\">char</span> *)&amp;ifr, <span class=\"keyword\">sizeof</span>(ifr));</span><br></pre></td></tr></table></figure><br>设置完socket之后，就可以像正常的socket一样访问和监听了。<br>这里要注意为socket设置的绑定地址，即<code>address.sin_addr.s_addr</code>要和SO_BINDTODEVICE指定的地址相匹配，否则会出现connection failed。例如：<code>address.sin_addr.s_addr</code>设置一个与ifreq指定的网卡IP地址不同的IP地址，则bind会返回connection failed的错误。<br>另外，SO_BINDTODEVICE实现的网卡绑定，也不适用netifcon的权限控制。</p>\n<h4 id=\"netifcon在哪些hook点生效？\"><a href=\"#netifcon在哪些hook点生效？\" class=\"headerlink\" title=\"netifcon在哪些hook点生效？\"></a>netifcon在哪些hook点生效？</h4><p>netifcon的策略检查点在<code>sel_netif_sid</code>中。该函数的调用者只有以下两个函数：</p>\n<ul>\n<li>selinux_inet_sys_rcv_skb<ul>\n<li>该函数只在fallback peer labelling生效时使用。关于fallback peer labelling，可以关注以下官方网页<a href=\"https://selinuxproject.org/page/NB_Networking\">NB Networking - SELinux Wiki</a>，以及一些相关的衍生阅读</li>\n<li>该函数也有两个调用点，分别是：<ul>\n<li>selinux_socket_sock_rcv_skb</li>\n<li>selinux_ip_forward</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>selinux_ip_postroute<ul>\n<li>该函数在NetFilter中使用，post routing是一个NetFilter的一个chain的名字。关于NetFilter以及iptables，可以参考[[iptables + SELinux控制socket packet]]。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AF-CAN访问控制\"><a href=\"#AF-CAN访问控制\" class=\"headerlink\" title=\"AF_CAN访问控制\"></a>AF_CAN访问控制</h2><p>CAN总线是有别于网络报文的另一种总线通信方式。我是用的demo程序是<a href=\"https://github.com/linux-can/can-utils\">linux-can/can-utils: Linux-CAN / SocketCAN user space applications</a> 中的candump。具体可以看candump.c这个文件。对CAN socket的调用方法大致如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_can</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class=\"line\">addr.can_family = AF_CAN;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(ifr.ifr_name, can_netif_name, name_size);</span><br><span class=\"line\">bind(sock_fd, (struct sockaddr *)&amp;addr, <span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">nbytes = recvmsg(sock_fd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>CAN设备可以被作为一张网卡，被监听和读写。如何插入一个虚拟CAN设备，可以参考[[52—How to create a virtual CAN interface on Linux - PragmaticLinux]]。<br>CAN设备的访问控制和其他的对socket object对访问控制是一样的。也可以实现type_transition:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(candump_t, candump_t, target_t, &#123; can_socket &#125;)</span><br></pre></td></tr></table></figure><br>需要注意的是，对于CAN设备，内核会根据其Address Family或Protocol Family识别其类型（class）。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> PF_CAN:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> SECCLASS_CAN_SOCKET;</span><br></pre></td></tr></table></figure><br>所以在写策略时，class一定要写对，如果写成了其他的class，那么策略是无法正确生效的。<br>另外，虽然CAN设备被当成一个netif在使用，但针对netif的hook点并没有对CAN设备有针对性的部署。根据[[#netif]]中的描述，针对netif的控制只发生在和网络相关的调用路径上。所以无法针对CAN设备使用netifcon语句。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文从Unix Domain Socket（UDS，域套接字，AF_UNIX或AF_LOCAL），INET socket和CAN socket的角度阐述了内核对socket的访问控制实现方式。<br>针对通用socket，内核通过将标签写入内核的socket object中，并在系统调用时，对其进行主客体匹配实现访问控制。<br>针对不同种类的socket，内核还辅以其他相关资源的控制，例如：</p>\n<ul>\n<li>如果是有名的域套接字还可以对socket文件进行控制，class属性为sock_file</li>\n<li>如果是IP地址，还可以结合nodecon进行控制，该语句只能在monolithic策略中编写，无法在modular策略中使能</li>\n<li>如果是网卡，可以结合netifcon进行控制，该语句只和网络相关的hook点相关</li>\n<li>CAN socket可以使用通用socket进行访问控制，不能使用netifcon进行访问控制。</li>\n</ul>\n",
            "tags": [
                "selinux",
                "can",
                "network"
            ]
        }
    ]
}