{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben",
    "description": null,
    "home_page_url": "https://zhougy0717.github.io",
    "items": [
        {
            "id": "https://zhougy0717.github.io/2024/01/29/obsidian_posts/Pointer%20Authentication/",
            "url": "https://zhougy0717.github.io/2024/01/29/obsidian_posts/Pointer%20Authentication/",
            "title": "Pointer Authentication",
            "date_published": "2024-01-29T14:58:17.118Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Pointer Authentication是ARM v8.3特性，Qualcomm和Apple的芯片均使能了该功能。Apple在iOS12中引入该功能，并通过PAC实现了用户态以及内核态的CFI，DFI。</p>\n<p>PAC利用内存虚拟地址的高位存储内存地址的MAC值来计算和验证指针的完整性，从而保证控制流和数据流的完整性。<br><img src=\"/2024/01/29/obsidian_posts/Pointer%20Authentication/ARM使用内存地址高位保存PAC值.png\" alt><br>如Linux内核文档Documentation/arm64/pointer-authentication.rst中描述，PAC特性使用从54位开始到VA_SIZE位的空闲位存储PAC值。一般虚拟地址有效位为48位，那么用于PAC的就是7位，如果VA_SIZE是52位，那么PAC就只有4位。<br>与PAC类似的MTE特性，如Documentation/arm64/pointer-authentication.rst所述，则使用虚拟地址的59-56位。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>PAC的工作原理如下图所示：<br>![[ARM PAC工作原理.png]]<br>假设指针值为ptr，且虚拟地址有效长度为48位，则<code>PAC = ptr[54..48] = QARMA(ptr[47..0], context, key)</code>。其中QARMA为ARM为PAC设计的MAC算法，算法输入为：</p>\n<ul>\n<li>内存地址值</li>\n<li>context，或者modifier值。不同的汇编指令对应不同的context值。</li>\n<li>密钥<h2 id=\"PAC相关指令\"><a href=\"#PAC相关指令\" class=\"headerlink\" title=\"PAC相关指令\"></a>PAC相关指令</h2>ARM通过一条指令来计算PAC值，即<code>PAC*</code>。同样使用一条指令来验证指针的PAC值，即<code>AUT*</code>指令。</li>\n<li>PACIA Xd, Xn|SP： <ul>\n<li>address：Xd</li>\n<li>context：Xn或SP值</li>\n</ul>\n</li>\n<li>PACIZA Xd<ul>\n<li>address：Xd</li>\n<li>context：0</li>\n</ul>\n</li>\n<li>PACIA1716: <ul>\n<li>address：x17</li>\n<li>context：x16</li>\n</ul>\n</li>\n<li>PACIASP：<ul>\n<li>address：x30，即LR寄存器</li>\n<li>context：SP<br>以上指令都是使用IA密钥。AUT相关指令与PAC指令类似。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"密钥管理\"><a href=\"#密钥管理\" class=\"headerlink\" title=\"密钥管理\"></a>密钥管理</h2><p>PAC共使用5把密钥，每把密钥128位，分别为：</p>\n<ul>\n<li>IA，IB</li>\n<li>DA，DB</li>\n<li>GA<br>Apple使用了全部5把密钥，应用于不同的场景和数据类型。Linux仅使用了IAkey和PACIASP指令保证函数返回地址的完整性（后向CFI）。</li>\n</ul>\n<p>Linux用户态可以使用全部5把密钥<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * We give each process its own keys, which are shared by all threads. The keys</span></span><br><span class=\"line\"><span class=\"comment\"> * are inherited upon fork(), and reinitialised upon exec*().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_keys_user</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apia</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apib</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apda</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apdb</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apga</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>Linux内核态尽使用密钥IA<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_keys_kernel</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ptrauth_key</span> <span class=\"title\">apia</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>Linux内核在进程调用exec系统调用时，为其初始化了所有5把密钥。同时，Linux提供了一个PRCTL，由用户态程序发起对全部5把密钥全部初始化。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> PR_PAC_RESET_KEYS:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arg3 || arg4 || arg5)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">\terror = PAC_RESET_KEYS(me, arg2);</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure><br>PAC密钥的使用和设置，都是由内核触发，软件无法获取密钥明文。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __ptrauth_key_install_nosync(k, v)\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">do &#123;\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tstruct ptrauth_key __pki_v = (v);\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\twrite_sysreg_s(__pki_v.lo, SYS_ ## k ## KEYLO_EL1);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\twrite_sysreg_s(__pki_v.hi, SYS_ ## k ## KEYHI_EL1);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; while (0)</span></span><br></pre></td></tr></table></figure><br>其中k为APIA，APIB等代表密钥类型的字串。所以最终代表密钥的寄存器形如SYS_APIA_KEYLO_EL1，SYS_APIA_KEYHI_EL1。</p>\n<h1 id=\"Apple-PAC\"><a href=\"#Apple-PAC\" class=\"headerlink\" title=\"Apple PAC\"></a>Apple PAC</h1><p>本文对Apple PAC的学习，主要来自于《Demystifying Pointer Authentication on Apple M1 - USENIX23》和两篇BlackHat的演讲：</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=7zCBOFxATFs\">iOS Kernel PAC, One Year Later - YouTube</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=3byNNUReyvE\">Behind the scenes of iOS and Mac Security - YouTube</a><br>Apple对PAC的应用<br>![[Apple将PAC用于保护数据指针.png]]<br>![[Apple将PAC用于代码指针的保护.png]]<br>![[Apple在iOS13中的PAC应用计划.png]]<br>可见Apple将PAC广发应用于用户态和内核态的CFI和DFI中。<br>除了标准的ARM PAC之外，Apple结合其Apple silicon的设计，对PAC进行了增强。<br>![[Apple对PAC的主要增强.png]]</li>\n</ul>\n<h2 id=\"增加寄存器\"><a href=\"#增加寄存器\" class=\"headerlink\" title=\"增加寄存器\"></a>增加寄存器</h2><p>Apple silicon与PAC有关的寄存器主要有：EXTRAKEY_EL1、VMDIV_EL2和AP_CTL。</p>\n<ul>\n<li>EXTRAKEY_EL1：用于修改实际使用的PAC密钥，以区分用户态密钥和内核态密钥，减少cross EL的攻击</li>\n<li>VMDIV_EL2: 用于在key transformation process时为不同的VM和host派生不同的密钥，降低cross VM的攻击</li>\n<li>AP_CTL：作为ARM SCTLR中PAC开关的补充<ul>\n<li>bit 0: Apple PAC总开关    </li>\n<li>bit 1，bit 4：分别在用户态和内核态控制EXTRAKEY_EL1    </li>\n<li>bit 2，bit3: 分别在用户态和内核态控制Apple PAC开关</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"改进算法\"><a href=\"#改进算法\" class=\"headerlink\" title=\"改进算法\"></a>改进算法</h2><p>Apple PAC使用密钥的低64位先与context（modifier）作异或，再输入与密钥的高64位作PAC运算。<br><code>PAC = QARMA(ARMKey_HI, XOR(ARMKey_LO, context))</code></p>\n<h2 id=\"增加随机源\"><a href=\"#增加随机源\" class=\"headerlink\" title=\"增加随机源\"></a>增加随机源</h2><p>Apple PAC与ARM PAC不同的是，Apple PAC不再直接使用硬件寄存器中的密钥，转而使用key transformation process来派生密钥并使用。除了使用密钥寄存器中存储的密钥作为密钥材料之外，还引入了</p>\n<ul>\n<li>VMDIV_EL2：作为cross VM的diversifier。Apple为每个VM以及host使用不同VMDIV_EL2值，确保不同的VM，以及VM与host之间有密钥隔离</li>\n<li>EXTRAKEY_EL1：作为cross EL的diversifier。Apple XNU kernel在用户态使用EXTRAKEY_EL1与密钥进行异或后，作为密钥输入计算PAC值<br>另外，Apple PAC还引入了per-boot的diversifier，以及per-key的diversifier，即每次重启，Apple PAC均会生成per-boot的随机值，作为key transformation process的随机源。同时，Apple PAC为每把密钥也生成了相应的随机盐值，确保即便被设置成同一个值，实际使用的密钥仍然是不同的。</li>\n</ul>\n<h1 id=\"Linux-PAC\"><a href=\"#Linux-PAC\" class=\"headerlink\" title=\"Linux PAC\"></a>Linux PAC</h1><p>gcc支持编译程序时使能PAC。gcc相关参数可参考<a href=\"https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/AArch64-Options.html\">Using the GNU Compiler Collection (GCC): AArch64 Options</a><br>针对C语言代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用命令<code>gcc -mbranch-protection=pac-ret+leaf main.c -o test</code>编译可得到下面的汇编代码。其中使用IA key，对函数的返回地址进行校验，从而实现了后向CFI，可以消减ROP攻击风险。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000000714 &lt;main&gt;:</span><br><span class=\"line\"> 714:   d503233f        paciasp</span><br><span class=\"line\"> 718:   52800000        mov     w0, #0x0                        // #0</span><br><span class=\"line\"> 71c:   d50323bf        autiasp</span><br><span class=\"line\"> 720:   d65f03c0        ret</span><br></pre></td></tr></table></figure><br>当前gcc的功能只有这些，远不如Apple的功能丰富。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li>Demystifying Pointer Authentication on Apple M1 - USENIX23</li>\n<li><a href=\"https://www.youtube.com/watch?v=7zCBOFxATFs\">iOS Kernel PAC, One Year Later - YouTube</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=3byNNUReyvE\">Behind the scenes of iOS and Mac Security - YouTube</a></li>\n<li>Pointer Authentication on ARMv8.3 - Qualcomm</li>\n<li><a href=\"https://developer.arm.com/documentation/dui0801/g/A64-General-Instructions/PACIA--PACIZA--PACIA1716--PACIASP--PACIAZ\">ARM Compiler armasm User Guide Version 6.6</a></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://zhougy0717.github.io/2023/03/25/obsidian_posts/%E4%BA%BA%E7%94%9F%E5%A6%82%E6%97%85%E9%80%94/",
            "url": "https://zhougy0717.github.io/2023/03/25/obsidian_posts/%E4%BA%BA%E7%94%9F%E5%A6%82%E6%97%85%E9%80%94/",
            "title": "",
            "date_published": "2023-03-25T12:39:47.372Z",
            "content_html": "<p>人生是旅途吗？或许是一段艰苦但值得的旅途。</p>\n<p>今天是华为的月末周六，此刻我坐上去上班的班车。7:15的早班车上人不是很多，位子可以随意挑选。我向来喜欢靠窗而坐。大巴的座位很窄，膝盖顶死了前座，有时还不得不分成外八字。大巴车上的气味总是不好，忍不住让人有晕车的感觉。这大概是我下意识地选择靠窗坐的原因吧，或许窗外明亮的世界能给人一些清新的感觉。只不过今天是一个阴天。</p>\n<p>上海的春天总是冷得那么突然，让人措手不及，就像生活总时不时地给你上一课。难熬的2022年好不容易过去了。3月份又染上甲流，如今还有一些咳嗽，身体也不甚硬朗。</p>\n<p>人生转眼已到40岁，好像在外婆膝下承欢还就在昨天。郭德纲说：“四十不惑，人到四十岁就不让嚯嚯了。”想到郭德纲的相声，嘴角和心里有些许的轻松。星期六的早上，行人和车辆都很少，大巴车可以开得很快。如果这时是个明媚的春天，能透过玻璃，沐浴一段阳光，看树影婆娑，恐怕甚至会有春风得意马蹄急的感觉。可想想有啥好值得得意的呢，而且今天还是个阴天。阴天也还是要生活下去的，每天都有值得好好生活下去的理由，为家人，为父母，为孩子，为你爱的，和爱你的人，虽然辛苦，但还是有所得，这还不足够吗？</p>\n<p>车程再长，交通再拥堵，目的地也总是会到来，只不过你准备好了吗？睡醒了吗？压抑的膝盖还站得起来吗？朋友！</p>\n",
            "tags": []
        },
        {
            "id": "https://zhougy0717.github.io/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/",
            "url": "https://zhougy0717.github.io/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/",
            "title": "iptables + SELinux控制socket packet",
            "date_published": "2022-06-11T14:40:02.069Z",
            "content_html": "<p>SELinux对socket的控制包含这几个方面：</p>\n<ul>\n<li>context语法中的nodecon, portcon, netifcon：这一类控制本端系统资源，确保合法进程才能访问本端网络资源</li>\n<li>通过iptables工具的SECMARK/CONNSECMARK扩展为socket packet打上的标签：这一类控制socket包的流向，确保只有合法进程才能访问某些网络报文</li>\n<li>NetLable/Labeled IPSec：这一类还没看，留待后面继续学习<br>本文关注第二种控制方法，并结合iptables，简要阐述其工作原理和使用方法。<h1 id=\"iptables简介\"><a href=\"#iptables简介\" class=\"headerlink\" title=\"iptables简介\"></a>iptables简介</h1><blockquote>\n<p><strong>from wiki</strong><br>iptables is a user-space utility program that allows a system administrator to configure the IP packet filter rules of the Linux kernel firewall, implemented as different Netfilter modules. The filters are organized <strong>in different tables, which contain chains of rules</strong> for how to treat network traffic packets. Different kernel modules and programs are currently used for different protocols; iptables applies to IPv4, ip6tables to IPv6, arptables to ARP, and ebtables to Ethernet frames.</p>\n</blockquote>\n</li>\n</ul>\n<p>iptables其实就是Linux的防火墙，用户通过配置各种规则来实现数据包的过滤。他利用了Linux的Netfilter框架的hook点对数据包进行判断，并执行action。例如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -s 10.10.10.10 -j DROP # 来自10.10.10.10的packet全部被丢弃</span><br><span class=\"line\">iptables -A INPUT -s 10.10.10.0/24 -j DROP # 来自10.10.10.0/255.255.255.0（24表示掩码位数）的packet全部被丢弃</span><br></pre></td></tr></table></figure><br>iptables支持的规则很多，具体可以参考<a href=\"https://linux.die.net/man/8/iptables\">iptables(8) - Linux man page</a>。</p>\n<h2 id=\"table-amp-chain\"><a href=\"#table-amp-chain\" class=\"headerlink\" title=\"table &amp; chain\"></a>table &amp; chain</h2><p>如wiki page所述，iptables通过各种tables和chains来管理所有rules。其实chain就是对应了netfilter的hook点。netfilter的hook点有：</p>\n<blockquote>\n<p>The following hooks represent various well-defined points in the networking stack:</p>\n<ul>\n<li>NF_IP_PRE_ROUTING: This hook will be triggered by any incoming traffic very soon after entering the network stack. This hook is processed before any routing decisions have been made regarding where to send the packet.</li>\n<li>NF_IP_LOCAL_IN: This hook is triggered after an incoming packet has been routed if the packet is destined for the local system.</li>\n<li>NF_IP_FORWARD: This hook is triggered after an incoming packet has been routed if the packet is to be forwarded to another host.</li>\n<li>NF_IP_LOCAL_OUT: This hook is triggered by any locally created outbound traffic as soon it hits the network stack.</li>\n<li>NF_IP_POST_ROUTING: This hook is triggered by any outgoing or forwarded traffic after routing has taken place and just before being put out on the wire.</li>\n</ul>\n</blockquote>\n<p>而chain就是和这些hook点一一对应的，例如：</p>\n<blockquote>\n<ul>\n<li>PREROUTING: Triggered by the NF_IP_PRE_ROUTING hook.</li>\n<li>INPUT: Triggered by the NF_IP_LOCAL_IN hook.</li>\n<li>FORWARD: Triggered by the NF_IP_FORWARD hook.</li>\n<li>OUTPUT: Triggered by the NF_IP_LOCAL_OUT hook.</li>\n<li>POSTROUTING: Triggered by the NF_IP_POST_ROUTING hook.</li>\n</ul>\n</blockquote>\n<p>而iptables又是怎么遍历这些table和chain的呢？<br>iptable在各个NetFilter的hook点上，依次遍历各个table的各个chain。其顺序按照如下表格：</p>\n<ul>\n<li>chain从左到右</li>\n<li>table从上到下</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Tables↓/Chains→</th>\n<th>PREROUTING</th>\n<th>INPUT</th>\n<th>FORWARD</th>\n<th>OUTPUT</th>\n<th>POSTROUTING</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(routing decision)</td>\n<td></td>\n<td></td>\n<td></td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>raw</td>\n<td>✓</td>\n<td></td>\n<td></td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>(connection tracking enabled)</td>\n<td>✓</td>\n<td></td>\n<td></td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>mangle</td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>nat (DNAT)</td>\n<td>✓</td>\n<td></td>\n<td></td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>(routing decision)</td>\n<td>✓</td>\n<td></td>\n<td></td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>filter</td>\n<td></td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>security</td>\n<td></td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n<td></td>\n</tr>\n<tr>\n<td>nat (SNAT)</td>\n<td></td>\n<td>✓</td>\n<td></td>\n<td></td>\n<td>✓</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>每个chain和table在整个协议栈的位置如下图。</p>\n<p><img src=\"/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/8EE2A917-0763-4E5E-AE46-1E5F07080950.png\" alt=\"fcbd15b235c892be235e74cb0e2f537f\"></p>\n<p>用户还可以创建自己的chain，使用命令<code>iptables -N &lt;chain name&gt;</code>。然后使用<code>-j</code>参数跳转，例如：<code>iptables -A INPUT -p tcp -j tcp_packets</code></p>\n<blockquote>\n<p>When/If we reach the end of that chain, we get dropped back to the INPUT chain and the packet starts traversing from the rule one step below where it jumped to the other chain (tcp_packets in this case). If a packet is ACCEPTed within one of the sub chains, it will be ACCEPT’ed in the superset chain also and it will not traverse any of the superset chains any further. However, do note that the packet will traverse all other chains in the other tables in a normal fashion.</p>\n</blockquote>\n<p>总结一下：</p>\n<ul>\n<li>如果自定义chain遍历结束，则回到原先跳出的chain（super chain），继续遍历</li>\n<li>如果子链（sub chain）中有ACCEPT，则父链中的规则不会再被继续遍历，但仍然会继续遍历其他chain中的规则，以及其他table中的规则。</li>\n<li>如果在任意位置，packet被DROP，则后续的chain和table都不会被执行<h2 id=\"target\"><a href=\"#target\" class=\"headerlink\" title=\"target\"></a>target</h2><code>-j</code>除了指定自定义chain外，一个更重要的用途就是指定packet的目的地，也就是target。</li>\n</ul>\n<blockquote>\n<p>Targets on the other hand specify an action to take on the packet in question. We could for example, DROP or ACCEPT the packet depending on what we want to do. There are also a number of other actions we may want to take.<br>For example: ACCEPT, DROP, CONNMARK, CLASSIFY, LOG …</p>\n</blockquote>\n<ul>\n<li>Some targets will cause the packet to stop traversing that speciﬁc chain and superior chains as described above. ex. ACCEPT, DROP</li>\n<li>Other targets, may take an action on the packet, after which the packet will continue passing through the rest of the rules. ex. LOG, ULOG, TOS</li>\n<li>Some targets will accept extra options (What TOS value to use etc), while others don’t necessarily need any options.</li>\n</ul>\n<p><strong>注</strong>：以上摘自[5],时间有点久，可能有些已经不成立了（例如[5]中通篇未提到security table)，但基本思路应该是保持的。</p>\n<h1 id=\"SECMARK\"><a href=\"#SECMARK\" class=\"headerlink\" title=\"SECMARK\"></a>SECMARK</h1><p>上一章介绍了iptables的基本工作原理，和table/chain的遍历方法。而可以与SELinux联动，并提供基于socket packet的MAC机制的是iptables的security表格。从上面表格可以看到，security table只有3个chain，即：INPUT，FORWARD，OUTPUT。对应了输入，输出以及转发3种数据流。可以满足基本的packet强制访问控制需求。<br>一条SECMARK相关的iptables语句如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -t security -A INPUT -i lo -p tcp --dport 9999 -j SECMARK --selctx system_u:object_r:ext_gateway_packet_t:s0</span><br></pre></td></tr></table></figure><br>其中<code>iptables -t security -A INPUT</code>表示往security table的INPUT chain插入一条规则，match部分<code>-i lo -p tcp --dport 9999</code>表示匹配来自lo网卡，协议为tcp的报文，目标端口为9999的数据包被SECMARK目标进行处理。SECMARK目标使用—selctx参数为该类数据包打上<code>system_u:object_r:ext_gateway_packet_t:s0</code>的安全上下文。则SELinux的策略语法即可以针对该类packet进行权限判断。例如:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow ext_gateway_t ext_gateway_packet_t : packet &#123; send recv &#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"CONNSECMARK\"><a href=\"#CONNSECMARK\" class=\"headerlink\" title=\"CONNSECMARK\"></a>CONNSECMARK</h1><p>CONNSECMARK实际上是SECMARK的扩展。从名字就可以看出CONNSECMARK是针对连接（connection）进行mark动作。iptables的连接管理基于NetFilter的conntrack。conntrack是内核模块，针对不同的协议类型，具有相应的连接控制管理。这已经超出本文的范围了。但不管conntrack多么复杂，功能多么强大，对应到iptables的状态只有4个，即NEW, EATABLISHED, RELATED, INVALID。所有的socket packet都被映射到这4歌状态。具体可以参考文献[5]的Chapter 7. The state machine的User-land states。</p>\n<blockquote>\n<ul>\n<li>NEW: tells us that the packet is the ﬁrst packet that we see.</li>\n<li>ESTABLISHED: The only requirement to get into an ESTABLISHED state is that one host sends a packet, and that it later on gets a reply from the other host.</li>\n<li>RELATED: The ESTABLISHED connection will then spawn a connection outside of the main connection. The newly spawned connection will then be considered RELATED, if the conntrack module is able to understand that it is RELATED.<br>INVALID: The INVALID state means that the packet can’t be identiﬁed or that it does not have any state.</li>\n</ul>\n</blockquote>\n<p>有了这状态定义，iptables就可以使用—state maches。例如：<code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</code>定义了规则，处于ESTABLISHED, RELATED状态的packet才被ACCEPT。<br>iptables与SELinux配合完全基于对socket packet进行过滤。并没有allow规则，或SELinux object是针对网络连接的。所以，iptables可以通过配合state match以及CONNSECMARK为来自于某个连接的packet进行打标签。方法就是—save和—restore参数。</p>\n<ul>\n<li><p>—save </p>\n<ul>\n<li>Example: <code>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j CONNSECMARK --save</code></li>\n<li>Explanation: Save the security context mark from the packet to the connection if the connection is not marked since before.</li>\n</ul>\n</li>\n<li><p>—restore</p>\n<ul>\n<li>Example: <code>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j CONNSECMARK --restore</code></li>\n<li>Explanation: If the packet has no security context mark set on it, the —restore option will set the security context mark associated with the connection on the packet.</li>\n</ul>\n</li>\n</ul>\n<p>总结一下就是：</p>\n<ul>\n<li>—save将packet数据包的context赋予连接</li>\n<li>—restore将连接的context赋予packet<br>此时SELinux具备更丰富的上下文，来对socket packet进行强制访问控制。<h1 id=\"Gateway实验\"><a href=\"#Gateway实验\" class=\"headerlink\" title=\"Gateway实验\"></a>Gateway实验</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2>文献[2]的2.2章节中提供了一个很好的练习，带我们认识iptables与SELinux配合做socket packet强制访问控制的方法。该方法通过iptables和SELinux实现客户端和服务端之间的数据包过滤。整个测试框架示意图如下所示，其中client和secure_client使用同一份源码编译，只是file context有所不同，server和secure_server同理。<br><img src=\"/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/5E235FC5-38CE-4069-ABC3-C68CA07D8A70.png\" alt=\"afd271fe524baadc38c595d0b74f9fae\"></li>\n</ul>\n<p>示例代码通过定义可执行文件的安全上下文（如下所示），和type<em>transition规则，使得secure</em>*进程工作在ext_gateway_t domain，而非secure进程工作在unconfined_t domain。各可执行文件的安全上下文如下所示：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/bin/secure_client system_u:object_r:secure_services_exec_t:s0</span><br><span class=\"line\">/usr/local/bin/secure_server system_u:object_r:secure_services_exec_t:s0</span><br><span class=\"line\">/usr/local/bin/client system_u:object_r:unconfined_t:s0</span><br><span class=\"line\">/usr/local/bin/server system_u:object_r:unconfined_t:s0</span><br></pre></td></tr></table></figure><br>示例代码中的策略集（.conf)文件定义了示意图中4个方向数据流的权限，包括：</p>\n<ul>\n<li>允许访问未标记端口的数据流(default_secmark_packet_t)：<code>auditallow unconfined_t default_secmark_packet_t : packet &#123; send recv &#125;;</code></li>\n<li>允许secure_*进程访问标记了端口的数据流（ext_gateway_packet_t）：<code>allow ext_gateway_t ext_gateway_packet_t : packet &#123; send recv &#125;;</code></li>\n<li>允许secure_*进程访问无SECMARK标记的数据流（unconfined_t）：<code>allow ext_gateway_t unconfined_t : packet &#123; recv send &#125;;</code><br>iptables_secmark使用若干iptables命令，定义数据包的标签规则，例如：</li>\n<li>来自于lo网卡的，协议为tcp，目标IP为127.0.0.0，掩码为255.0.0.0输入数据包被设置成default_secmark_packet_t<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This OUTPUT rule sets all packets to default_secmark_packet_t: as it is</span></span><br><span class=\"line\">iptables -t security -A INPUT -i lo -p tcp -d 127.0.0.0/8 -j SECMARK --selctx system_u:object_r:default_secmark_packet_t:s0</span><br></pre></td></tr></table></figure></li>\n<li>来自于lo网卡的，协议为tcp，目标/源端口为9999的输入/输出数据包被设置成ext_gateway_packet_t（节选）<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> These rules will replace the above context with the internal or</span></span><br><span class=\"line\">iptables -t security -A INPUT -i lo -p tcp --dport 9999 -j SECMARK --selctx system_u:object_r:ext_gateway_packet_t:s0</span><br><span class=\"line\">iptables -t security -A OUTPUT -o lo -p tcp --sport 9999 -j SECMARK --selctx system_u:object_r:ext_gateway_packet_t:s0</span><br></pre></td></tr></table></figure>\n两类规则定义的数据包范围实际是有重叠的，根据注释可知，实际两者的关系是，general和特例的关系。即前者将所有特定目标的数据包设置为default_secmark_packet_t，而后者将来自特定端口的数据包指定为ext_gateway_packet_t。<br>经过此类策略设置，client在访问secure_server时，数据包就会被拦截。查看/var/log/audit/audit.log:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type=AVC msg=audit(1602641071.967:3475): avc:  granted  &#123; send &#125; for  pid=0 comm=&quot;swapper/0&quot; saddr=127.0.0.1 src=9999 daddr=127.0.0.1 dest=47076 netif=lo scontext=unconfined_u:message_filter_r:ext_gateway_t:s0-s0:c0.c1023 tcontext=system_u:object_r:ext_gateway_packet_t:s0 tclass=packet</span><br><span class=\"line\"></span><br><span class=\"line\">type=AVC msg=audit(1602641071.967:3476): avc:  denied  &#123; recv &#125; for  pid=10 comm=&quot;ksoftirqd/0&quot; saddr=127.0.0.1 src=9999 daddr=127.0.0.1 dest=47076 netif=lo scontext=unconfined_u:</span><br><span class=\"line\">unconfined_r:unconfined_t:s0-s0:c0.c1023 tcontext=system_u:object_r:ext_gateway_packet_t:s0 tclass=packet permissive=0</span><br></pre></td></tr></table></figure>\nclient连接secure_server监听的9999端口，数据流为：tcp，127.0.0.1:9999 =&gt; 127.0.0.1:47076。secure_server向client发送成功，但client接收失败。因为client运行于unconfined_t，没有对应ext_gateway_packet_t的recv权限。</li>\n</ul>\n<h2 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h2><p>参考文献[2]因为成书过久（写于2014年，现在2020年），且练习基于书中前导章节中的modular-test章节，所以直接运行会产生错误。错误主要包含：</p>\n<ul>\n<li>基于modular-test构建ext_gateway策略。因为可能是发行版变化（笔者用的CentOS8）或者时间过久的原因，直接用书中的基础策略会造成无法开机，所以modular-test练习中的策略不可用。解决方法是，编译ext_gateway module，并用semodule插入发行版自带的策略中。此时需要针对原生策略进行适配。例如：进程拉起时报错，需要增加相应allow规则，节选如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow ext_gateway_t null_device_t : chr_file &#123; read write open &#125;;</span><br><span class=\"line\">allow ext_gateway_t ld_so_t : file &#123; map read execute &#125;;</span><br><span class=\"line\">allow ext_gateway_t ld_so_cache_t : file &#123; open map read execute getattr &#125;;</span><br><span class=\"line\">allow ext_gateway_t lib_t : file &#123; open map read execute getattr &#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>本书给出的示例代码的安全上下文未给出mls描述，在编译时会报错。例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -t security -A INPUT -i lo -p tcp --dport 9999 -j SECMARK --selctx system_u:object_r:ext_gateway_packet_t:s0</span><br><span class=\"line\">iptables -t security -A INPUT -i lo -p tcp --sport 9999 -j SECMARK --selctx system_u:object_r:ext_gateway_packet_t:s0</span><br><span class=\"line\">/usr/local/bin/secure_client system_u:object_r:secure_services_exec_t:s0</span><br></pre></td></tr></table></figure>\n所有的context都加上了<code>:s0</code>。<br>经过适配后，书中提供的示例可以顺利跑通，如下：<br>server<br><img src=\"/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/FEBE1E4A-7068-4FF8-8B09-B0DB7E6FD327.png\" alt=\"e19e063bd6c8c6ea612eab6441924451\"><br>client端<br><img src=\"/2022/06/11/obsidian_posts/iptables%20+%20SELinux%E6%8E%A7%E5%88%B6socket%20packet/A643FA3B-02D4-41AB-827D-698C99A2505F.png\" alt=\"2cf32398daa366c050fa0a9cbebd4dae\"></li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://selinuxproject.org/page/NB_Networking\">SELinux Networking Support</a><br>[2] <a href=\"https://app.yinxiang.com/shard/s10/nl/161681/b51d0a9e-c5fc-48aa-8eb9-0b9bee14f832/\">The SELinux Notebook - Building The Sample Policy</a><br>[3] <a href=\"https://en.wikipedia.org/wiki/Iptables\">iptables wiki page</a><br>[4] <a href=\"https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture\">A Deep Dive into Iptables and Netfilter Architecture</a><br>[5] Oskar Andreasson, 2001-2006, Iptables Tutorial 1.2.2</p>\n",
            "tags": [
                "selinux",
                "iptables"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
            "url": "https://zhougy0717.github.io/2022/06/05/obsidian_posts/SELinux%20socket%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
            "title": "SELinux socket访问控制",
            "date_published": "2022-06-05T13:25:27.461Z",
            "content_html": "<h1 id=\"内核socket架构介绍\"><a href=\"#内核socket架构介绍\" class=\"headerlink\" title=\"内核socket架构介绍\"></a>内核socket架构介绍</h1><p>socket编程的用户态接口是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>domain</strong><br>定义在Linux内核目录include/linux/socket.h文件中，常用的有:<br>![[socket domain.png]]<br>我们通常用<code>AF_</code>(Address Family)取代<code>PF_</code>(Protocol Family)。在内核代码中也有所体现：<br>![[PF与AF的对应关系.png]]<br><strong>type</strong><br>当前定义的类型为：</p>\n<ul>\n<li>SOCK_STREAM</li>\n<li>SOCK_DGRAM</li>\n<li>SOCK_RAW</li>\n</ul>\n<p><strong>protocol</strong><br>决定协议的种类。例如针对AF_INET类型socket，可以有不同的网络协议，例如：SOCK_STREAM的默认协议是IPPROTO_TCP，SOCK_DGRAM的默认协议为IPPROTO_UDP。这些协议类型定义的位置，以musl为例，在include/netinet/in.h中。不过大多时候，传0就好了，例如：<code>socket(AF_INET, SOCK_STREAM, 0)</code></p>\n</blockquote>\n<p>socket和socketpair都会调用系统调用进入内核，对应的系统调用分别是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYSCALL_DEFINE3(socket, <span class=\"keyword\">int</span>, family, <span class=\"keyword\">int</span>, type, <span class=\"keyword\">int</span>, protocol) </span><br><span class=\"line\">SYSCALL_DEFINE4(socketpair, <span class=\"keyword\">int</span>, family, <span class=\"keyword\">int</span>, type, <span class=\"keyword\">int</span>, protocol,<span class=\"keyword\">int</span> __user *, usockvec)</span><br></pre></td></tr></table></figure><br>这两个系统调用会通过<code>sock_create</code>实例化真正的内核的socket object。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retval = sock_create(family, type, protocol, &amp;sock); </span><br></pre></td></tr></table></figure></p>\n<p>我们从socket 的family属性可以看到，Linux希望用socket涵盖所有的通信场景。针对不同的socket使用场景，Linux内核采用了类似面向对象的实现方法。</p>\n<pre class=\"mermaid\">classDiagram\n    class `struct sock_common`\n    class `struct sock` {\n        + void *sk_security\n    }\n    class `struct socket` {\n        + const struct proto_ops ops\n    }\n\n    `struct sock` o-- `struct sock_common`\n    `struct socket` o-- `struct sock`</pre>\n`sock_create`调用`__sock_create`最终通过Address Family找到对应socket类注册的create接口，实现具体对象的构造。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure>\n在对应子类的create函数中，子类根据type的不同，绑定不同的处理函数指针。以af_unix.c为例。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (sock-&gt;type) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_STREAM:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_stream_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *\tBelieve it or not BSD has AF_UNIX, SOCK_RAW though</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *\tnothing uses it.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_RAW:</span><br><span class=\"line\">\t\tsock-&gt;type = SOCK_DGRAM;</span><br><span class=\"line\">\t\tfallthrough;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_DGRAM:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_dgram_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> SOCK_SEQPACKET:</span><br><span class=\"line\">\t\tsock-&gt;ops = &amp;unix_seqpacket_ops;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ESOCKTNOSUPPORT;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n跟访问控制有关的信息都存储在struct sock的sk_security成员指针中。\n\n# socket访问控制\nSELinux实现了面向主客体的访问控制模型，即所谓的TEAC（Type Enforcement Access Control）。针对文件，SELinux通过在文件系统的扩展属性上设置标签（安全上下文），当进程（主体）访问该文件客体时，SELinux提供的`avc_has_perm`函数会通过查询内存中的policydb，以获取对应的决策结果。针对socket这一类客体，SELinux的工作原理类似，每个socket object都会被打上对应的标签，从而在系统调用的时候对其进行权限判断。\n\n## 打标签\n所有类型的socket，对socket打标签的方式都是基本一致的。下面以AF_UNIX socket为例解释Linux内核如何实现socket object打标签。\n\n由于socket object没有文件实体，所以没法像文件一样，通过给文件设置文件系统的扩展属性来实现。socket的标签设置在socket抽象层实现，具体即net/socket.c文件，通过LSM的接口调用SELinux层的接口实现“打标签”。\n<pre class=\"mermaid\">graph TD;\n    A[\"__sock_create\"] --> B[\"security_socket_create\"];\n    B --> C[\"pf->create\"];\n    C --> D[\"security_socket_post_create\"]</pre>\n\n<p><code>security_socket_create</code>和<code>security_socket_post_create</code>对应的SELinux hook函数如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSM_HOOK_INIT(socket_create, selinux_socket_create), </span><br><span class=\"line\">LSM_HOOK_INIT(socket_post_create, selinux_socket_post_create)</span><br></pre></td></tr></table></figure><br><code>security_socket_create</code>通过下面的代码实现了：</p>\n<ul>\n<li>family到security class的转换</li>\n<li>socket标签的生成<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u32 newsid;</span><br><span class=\"line\">secclass = socket_type_to_security_class(family, type, protocol);</span><br><span class=\"line\">rc = socket_sockcreate_sid(tsec, secclass, &amp;newsid);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要注意的是newsid仅仅是一个局部变量，可见该hook点，并未对socket的标签信息进行保存。那么:</p>\n<ol>\n<li>socket object的标签是在哪儿生成的呢？</li>\n<li>socket标签的值具体是什么呢？</li>\n</ol>\n<h3 id=\"标签的生成\"><a href=\"#标签的生成\" class=\"headerlink\" title=\"标签的生成\"></a>标签的生成</h3><p>第一个问题的答案可以在<code>security_socket_post_create</code>函数中找到。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sksec = sock-&gt;sk-&gt;sk_security;</span><br><span class=\"line\">sksec-&gt;sclass = sclass;</span><br><span class=\"line\">sksec-&gt;sid = sid;</span><br></pre></td></tr></table></figure><br>socket object的标签（SID）存储在struct sock结构体的sk_security的sid成员中。关于SID的内容可以参考[[详解SELinux SID]]。<br>下图显示了<code>security_socket_create</code>和<code>security_socket_post_create</code>中对socket SID的两次计算。由于未赋予正确的标签（type与user，role的组合不合法），且SELinux处于permissive模式，所以内核audit子系统报了两次告警。<br>![[对socket标签的两次计算.png]]</p>\n<blockquote>\n<p><strong>为什么要有两次SID计算？</strong><br>第一次是在创建socket之前，检查进程是否有权限创建该socket，此时尚不具备该socket object，所以自然无法记录。直到security_socket_post_create时，socket object已经创建完毕了，此时再计算出socket的SID，并予以记录。</p>\n</blockquote>\n<h3 id=\"标签的计算\"><a href=\"#标签的计算\" class=\"headerlink\" title=\"标签的计算\"></a>标签的计算</h3><p>不论是<code>security_socket_create</code>还是<code>security_socket_post_create</code>都会调用<code>socket_sockcreate_sid</code>函数来获取socket object的标签。获取的方法，分两步：</p>\n<ol>\n<li>如果进程设置了sockcreate属性，则使用该属性指定的标签</li>\n<li>否则通过security_transition_sid执行type transition</li>\n</ol>\n<h4 id=\"sockcreate\"><a href=\"#sockcreate\" class=\"headerlink\" title=\"sockcreate\"></a>sockcreate</h4><p>通过改写进程的sockcreate属性，每个进程可以决定其创建的socket object的标签属性。一旦为该属性赋值，那么socket object的type_transition不再生效。</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"写/proc/pid/attr/sockcreate文件\"] --> B[\"proc_pid_attr_write\"];\n    B --> C[\"security_setprocattr\"];\n    C --> D[\"__tsec->sockcreate_sid = xxx\"];</pre><br>通过下面的代码，用户态设置的属性值最终被写入到current-&gt;cred-&gt;security-&gt;sockcreate_sid成员中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in security/selinux/hooks.c, selinux_setprocattr函数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(name, <span class=\"string\">&quot;exec&quot;</span>)) &#123;</span><br><span class=\"line\">\ttsec-&gt;exec_sid = sid;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(name, <span class=\"string\">&quot;sockcreate&quot;</span>)) &#123;</span><br><span class=\"line\">\ttsec-&gt;sockcreate_sid = sid;</span><br><span class=\"line\">&#125; ...</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"type-transition\"><a href=\"#type-transition\" class=\"headerlink\" title=\"type transition\"></a>type transition</h4><p>关于type<em>transition可以参考[[28—(6 条消息) 深入理解 SELinux SEAndroid（第一部分）</em>阿拉神农的博客 - CSDN 博客_domain_auto_trans]]，也可以参考官方文档<a href=\"https://selinuxproject.org/page/TypeRules\">TypeRules - SELinux Wiki</a>。<br>socket的type_transition和其他类型的type_transtion没有区别。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type_transition proc_t, source_t, target_t, &#123; xxx_class &#125;</span><br></pre></td></tr></table></figure><br>这条语句的意思是：</p>\n<blockquote>\n<p>由类型为proc_t创建的，源标签为source_t的客体，如果其类型为xxx_class，则其目标标签为target_t。</p>\n</blockquote>\n<p>由于socket的起始默认标签，会继承进程的主体标签，所以如果是socket，则上面这样一条语句会变成：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这里以SOCK_STREAM类型的AF_UNIX socket为例</span><br><span class=\"line\">type_transition proc_t, proc_t, target_t, &#123; unix_stream_socket &#125;</span><br></pre></td></tr></table></figure><br>如果使用refpolicy提供的宏来编写，那么就会写作：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(proc_t, source_t, target_t, &#123; unix_stream_socket &#125;)</span><br></pre></td></tr></table></figure><br><code>filetrans_pattern</code>定义在policy/support/file_patterns.spt文件中。<br>最终socket的标签信息（SID）会被记录在struct sock的sk_security成员中。<br>一旦socket object有了标签信息，并且可以实施type_transition，那么我们就可以将某个进程创建的socket转换为任意我们想要的标签（type），并对其定义任意我们想要的allow规则。</p>\n<h2 id=\"AF-UNIX访问控制\"><a href=\"#AF-UNIX访问控制\" class=\"headerlink\" title=\"AF_UNIX访问控制\"></a>AF_UNIX访问控制</h2><p>AF_UNIX socket又称为Unix Domain Socket，简称UDS，中文称为域套接字。UDS还有一些比较特殊的地方。AF_UNIX socket通常用来进行操作系统内部的进程间通信。通过设置sun_family和sun_path来为UDS设置地址。从而完成客户端与服务端的绑定。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_un</span> *<span class=\"title\">addr</span>;</span></span><br><span class=\"line\">addr-&gt;sun_family = AF_UNIX;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(addr-&gt;sun_path, path, <span class=\"keyword\">sizeof</span>(addr-&gt;sun_path) - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>服务端进程可以调用bind，listen，accept来监听客户端的请求，并用recv和send来响应。客户端进程通过send和recv类接口发送请求。<br>当服务端创建好socket之后，会在目录下生成一个socket文件。而UDS除了标准的（或者通用的）socket object的权限控制之外，还可以对socket文件进行访问控制。</p>\n<p>UDS socket文件和普通文件类似，可以设置DAC权限，也可以打标签。区别是UDS socket不能在rootfs中集成，而是在运行时动态生成的。生成之后，可以通过restorecon或者chcon等SELinux工具或接口对其设置安全上下文。UDS socket文件同样可以实现type_transition。使用refpolicy的宏接口可以如下编写<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(proc_t, dir_t, target_t, &#123; sock_file &#125;;</span><br></pre></td></tr></table></figure><br>需要注意以下几点：</p>\n<ul>\n<li>UDS socket文件和普通文件一样，会默认继承其所在目录的标签，所以文件的源标签要设置成目录的标签</li>\n<li>UDS socket的类型（class）是sock_file，如果设置不正确，则type_transtion不会生效。<br>配置好type_transition之后，就可以针对UDS socket文件进行访问控制了。</li>\n</ul>\n<h3 id=\"匿名socket\"><a href=\"#匿名socket\" class=\"headerlink\" title=\"匿名socket\"></a>匿名socket</h3><p>UDS还有一种特殊的socket，即匿名socket，英文称为abstract namespace socket。此时sun_path的首字符为’\\0’。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_un</span> *<span class=\"title\">addr</span>;</span></span><br><span class=\"line\">addr-&gt;sun_family = AF_UNIX;</span><br><span class=\"line\">addr-&gt;sun_path[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(&amp;addr-&gt;sun_path[<span class=\"number\">1</span>], path, <span class=\"keyword\">sizeof</span>(addr-&gt;sun_path) - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>其实匿名socket比有名socket更简单，其丢失了socket文件的文件访问控制特性，只保留了socket object访问控制。</p>\n<h2 id=\"AF-INET访问控制\"><a href=\"#AF-INET访问控制\" class=\"headerlink\" title=\"AF_INET访问控制\"></a>AF_INET访问控制</h2><p>INET型socket除了通用的socket object之外，还针对一些网络属性进行了访问控制。主要包含三种语句：</p>\n<ul>\n<li>nodecon</li>\n<li>portcon</li>\n<li>netifcon<br>可以参考官方的网页<a href=\"https://selinuxproject.org/page/NetworkStatements\">NetworkStatements - SELinux Wiki</a>。本节挑选node和netif相关的控制做简单介绍。</li>\n</ul>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><p>SELinux的nodecon语句在编译时，被加载到policydb中。在security/selinux/hooks.c文件中定义的系统调用hook点的实现时，通过查询policydb，获得node的标签。其实现调用流程如下：</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"selinux_socket_bind\"] --> B[\"sel_netnode_sid\"];\n    B --> C[\"sel_netnode_sid_slow\"];\n    C --> D[\"security_node_sid\"]</pre><br>在<code>security_node_sid</code>中，查询policydb完成了node标签的查询。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for IPv4</span></span><br><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NODE];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c-&gt;u.node.addr == (addr &amp; c-&gt;u.node.mask))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for IPv6</span></span><br><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NODE6];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (match_ipv6_addrmask(addrp, c-&gt;u.node6.addr,</span><br><span class=\"line\">\t\t\t\tc-&gt;u.node6.mask))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>有了node的标签，SELinux就可以使用avc_has_perm了。<br>![[针对node的访问控制.png]]<br>node的标签为node_t, 其class属性跟随了socket object的class属性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sk_security_struct</span> *<span class=\"title\">sksec</span> =</span> sk-&gt;sk_security;</span><br><span class=\"line\">err = avc_has_perm(&amp;selinux_state,</span><br><span class=\"line\">\t\t\t\t   sksec-&gt;sid, sid,</span><br><span class=\"line\">\t\t\t\t   sksec-&gt;sclass, node_perm, &amp;ad);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>nodecon语句的特殊性</strong><br>![[nodecon在refpolicy中的支持情况.png]]<br>nodecon是不支持模块化策略的，也就是说在.pp文件中编写nodecon编译会报错（syntax error）。通过semanage工具可以增加nodecon标签条目，例如：semanage node -a -M 255.255.255.255 -t node_t -r s0:c20.c250 -p ipv4 127.0.0.2会生成nodecon语句nodecon ipv4 127.0.0.2 255.255.255.255 system_u:object_r:node_t:s0:c20.c250。<br>这里还需要注意的是：node的type属性不能随便赋予。否则会出现以下错误：<br>![[错误的node type.png]]</p>\n</blockquote>\n<h3 id=\"netif\"><a href=\"#netif\" class=\"headerlink\" title=\"netif\"></a>netif</h3><p>netif本身倒没什么特别之处，与node的控制方法类似。</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"selinux_inet_sys_rcv_skb\"] --> B[\"sel_netif_sid\"];\n    B --> C[\"sel_netif_sid_slow\"];\n    C --> D[\"security_netif_sid\"];</pre><br>在<code>security_netif_sid</code>中查找policydb中的netif表格。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = policydb-&gt;ocontexts[OCON_NETIF];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (c) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(name, c-&gt;u.name) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tc = c-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>netif的控制有两个比较有意思的地方，下面依次道来。</p>\n<h4 id=\"如何实现单网卡的绑定\"><a href=\"#如何实现单网卡的绑定\" class=\"headerlink\" title=\"如何实现单网卡的绑定\"></a>如何实现单网卡的绑定</h4><p>网上搜索了好久，大多是实现如何从指定的网卡发送报文（所谓的绑定）。因为操作系统通常会按照连接或网络的连通性，自动选择发送数据的网卡。也有不少提及通过SO_BINDTODEVICE绑定网卡的实现。但缺乏关键代码。最终通过下面的代码实现了demostration，摘取关键代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address.sin_family = AF_INET;</span><br><span class=\"line\">address.sin_addr.s_addr = INADDR_ANY;</span><br><span class=\"line\">address.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;ifr, <span class=\"number\">0x00</span>, <span class=\"keyword\">sizeof</span>(ifr));</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(ifr.ifr_name, <span class=\"string\">&quot;lo&quot;</span>, <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;lo&quot;</span>)); <span class=\"comment\">// &quot;lo&quot;就是网卡名</span></span><br><span class=\"line\">ioctl(server_fd, SIOCGIFINDEX, &amp;ifr);</span><br><span class=\"line\">setsockopt(server_fd, SOL_SOCKET, SO_BINDTODEVICE, (<span class=\"keyword\">char</span> *)&amp;ifr, <span class=\"keyword\">sizeof</span>(ifr));</span><br></pre></td></tr></table></figure><br>设置完socket之后，就可以像正常的socket一样访问和监听了。<br>这里要注意为socket设置的绑定地址，即<code>address.sin_addr.s_addr</code>要和SO_BINDTODEVICE指定的地址相匹配，否则会出现connection failed。例如：<code>address.sin_addr.s_addr</code>设置一个与ifreq指定的网卡IP地址不同的IP地址，则bind会返回connection failed的错误。<br>另外，SO_BINDTODEVICE实现的网卡绑定，也不适用netifcon的权限控制。</p>\n<h4 id=\"netifcon在哪些hook点生效？\"><a href=\"#netifcon在哪些hook点生效？\" class=\"headerlink\" title=\"netifcon在哪些hook点生效？\"></a>netifcon在哪些hook点生效？</h4><p>netifcon的策略检查点在<code>sel_netif_sid</code>中。该函数的调用者只有以下两个函数：</p>\n<ul>\n<li>selinux_inet_sys_rcv_skb<ul>\n<li>该函数只在fallback peer labelling生效时使用。关于fallback peer labelling，可以关注以下官方网页<a href=\"https://selinuxproject.org/page/NB_Networking\">NB Networking - SELinux Wiki</a>，以及一些相关的衍生阅读</li>\n<li>该函数也有两个调用点，分别是：<ul>\n<li>selinux_socket_sock_rcv_skb</li>\n<li>selinux_ip_forward</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>selinux_ip_postroute<ul>\n<li>该函数在NetFilter中使用，post routing是一个NetFilter的一个chain的名字。关于NetFilter以及iptables，可以参考[[iptables + SELinux控制socket packet]]。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AF-CAN访问控制\"><a href=\"#AF-CAN访问控制\" class=\"headerlink\" title=\"AF_CAN访问控制\"></a>AF_CAN访问控制</h2><p>CAN总线是有别于网络报文的另一种总线通信方式。我是用的demo程序是<a href=\"https://github.com/linux-can/can-utils\">linux-can/can-utils: Linux-CAN / SocketCAN user space applications</a> 中的candump。具体可以看candump.c这个文件。对CAN socket的调用方法大致如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_can</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class=\"line\">addr.can_family = AF_CAN;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(ifr.ifr_name, can_netif_name, name_size);</span><br><span class=\"line\">bind(sock_fd, (struct sockaddr *)&amp;addr, <span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">nbytes = recvmsg(sock_fd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>CAN设备可以被作为一张网卡，被监听和读写。如何插入一个虚拟CAN设备，可以参考[[52—How to create a virtual CAN interface on Linux - PragmaticLinux]]。<br>CAN设备的访问控制和其他的对socket object对访问控制是一样的。也可以实现type_transition:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filetrans_pattern(candump_t, candump_t, target_t, &#123; can_socket &#125;)</span><br></pre></td></tr></table></figure><br>需要注意的是，对于CAN设备，内核会根据其Address Family或Protocol Family识别其类型（class）。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> PF_CAN:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> SECCLASS_CAN_SOCKET;</span><br></pre></td></tr></table></figure><br>所以在写策略时，class一定要写对，如果写成了其他的class，那么策略是无法正确生效的。<br>另外，虽然CAN设备被当成一个netif在使用，但针对netif的hook点并没有对CAN设备有针对性的部署。根据[[#netif]]中的描述，针对netif的控制只发生在和网络相关的调用路径上。所以无法针对CAN设备使用netifcon语句。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文从Unix Domain Socket（UDS，域套接字，AF_UNIX或AF_LOCAL），INET socket和CAN socket的角度阐述了内核对socket的访问控制实现方式。<br>针对通用socket，内核通过将标签写入内核的socket object中，并在系统调用时，对其进行主客体匹配实现访问控制。<br>针对不同种类的socket，内核还辅以其他相关资源的控制，例如：</p>\n<ul>\n<li>如果是有名的域套接字还可以对socket文件进行控制，class属性为sock_file</li>\n<li>如果是IP地址，还可以结合nodecon进行控制，该语句只能在monolithic策略中编写，无法在modular策略中使能</li>\n<li>如果是网卡，可以结合netifcon进行控制，该语句只和网络相关的hook点相关</li>\n<li>CAN socket可以使用通用socket进行访问控制，不能使用netifcon进行访问控制。</li>\n</ul>\n",
            "tags": [
                "selinux",
                "can",
                "network"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/12/22/obsidian_posts/fPIC%20vs.%20fPIE/",
            "url": "https://zhougy0717.github.io/2021/12/22/obsidian_posts/fPIC%20vs.%20fPIE/",
            "title": "fPIC vs. fPIE",
            "date_published": "2021-12-22T11:56:23.176Z",
            "content_html": "<h1 id=\"fPIC-vs-fPIE\"><a href=\"#fPIC-vs-fPIE\" class=\"headerlink\" title=\"fPIC vs. fPIE\"></a>fPIC vs. fPIE</h1><p>这两个都是编译选项，具体可以参考<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html\">GCC的官方文档</a>  。其作用就是</p>\n<p>参考[4], 实际-fPIC和-fPIE的区别非常有限。  </p>\n<blockquote>\n<p>It works very much like what PIC does for dynamic libraries, the difference is that a Procedure Linkage Table (PLT) is not created, instead PC-relative relocation is used.  </p>\n</blockquote>\n<p>差别就是体现在导出的全局变量上。如果使用-fPIE编译的.o文件，则不会为这些全局变量创建PLT表项。但用-fPIC选项则会创建。则使用-fPIC编译的代码，性能会略差。参考[5]，这一点性能损失也非常有限  </p>\n<blockquote>\n<p><strong>注</strong>: 根据编译器同学的推测，这一差别也有可能在链接二进制的时候被抹去。  </p>\n</blockquote>\n<p>LLVM和GCC针对这两个编译选项的处理也不尽相同。GCC的处理可以参考[1]。而LLVM的处理是采用互相覆盖的方法。  </p>\n<p>clang++ -fPIE -fPIC -o a.o -c a.cpp<br>如果最后一个参数是-fPIC，则fPIE会被忽略。  </p>\n<p>clang++ -fPIE -fPIC -fPIE -o a.o -c a.cpp<br>同理，如果最后一个是-fPIE，那么-fPIC就会被忽略。这也是我们编译报错的原因。  </p>\n<h1 id=\"cmake编译时的默认选项\"><a href=\"#cmake编译时的默认选项\" class=\"headerlink\" title=\"cmake编译时的默认选项\"></a>cmake编译时的默认选项</h1><p>cmake在2.8以后加入了编译策略（policy），每个策略拥有一个CMP的编号，例如：<a href=\"https://cmake.org/cmake/help/latest/policy/CMP0018.html\">CMP0018 — CMake 3.22.1 Documentation</a>。编译策略可以通过<a href=\"https://cmake.org/cmake/help/latest/command/cmake_policy.html\">cmake_policy</a>命令进行设置。<br>在CMP0018中，就阐明了针对position independent相关编译选项的设置，即POSITION_INDEPENDENT_CODE。通过设置该选项，可以为构建目标加入-fPIE的编译选项，以及-pie的链接选项。  </p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.18</span>.<span class=\"number\">1</span>)  </span><br><span class=\"line\"><span class=\"keyword\">project</span>(<span class=\"keyword\">test</span>  </span><br><span class=\"line\">    VERSION <span class=\"number\">2.0</span>  </span><br><span class=\"line\">    LANGUAGES CXX  </span><br><span class=\"line\">)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">include</span>(CheckPIESupported)  </span><br><span class=\"line\">check_pie_supported()  <span class=\"comment\"># &lt;&lt;&lt; 加入这两行，-pie才能被成功添加，否则即便有POSITION_INDEPENDENT_CODE，也不会添加-pie的链接选项</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_VERBOSE_MAKEFILE <span class=\"keyword\">on</span>)  </span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(lib-static STATIC lib-static.cpp)  </span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(lib-shared SHARED lib-shared.cpp)  </span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(<span class=\"keyword\">test</span>-exe main.cpp lib-static.cpp)   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">set_target_properties</span>(<span class=\"keyword\">test</span>-exe  </span><br><span class=\"line\">    PROPERTIES  </span><br><span class=\"line\">    POSITION_INDEPENDENT_CODE <span class=\"keyword\">ON</span>   <span class=\"comment\"># &lt;&lt;&lt; 这一参数会为可执行二进制添加-fPIE和-pie</span></span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n<p>-fPIE的参数会通过该编译选项加入要链接到二进制的.o文件中，而动态库会默认加上-fPIC选项，即便设置了POSITION_INDEPENDENT_CODE，也不会加上-fPIE选项。当然如果通过CMAKE_C_FLAG之类的变量强行加上，还是可以的。<br>另外即便指定了POSITION_INDEPENDENT_CODE，-pie的链接选项仍然不会被加上。可以参考[3]。必须要指定这两行才可以:  </p>\n <figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span>(CheckPIESupported)  </span><br><span class=\"line\">check_pie_supported()</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><p><a href=\"https://hardenedlinux.github.io/system-security/2016/07/01/PIC_PIE_and_ASLR_analysis.html\">PIC/PIE&amp;ASLR分析</a></p>\n</li>\n<li><p><a href=\"https://www.cxyzjd.com/article/weixin_43820063/105555315\">安全编译选项之 PIE和PIC的区别_weixin_43820063的博客-程序员宅基地 - 程序员宅基地</a></p>\n</li>\n<li><p><a href=\"https://gitlab.kitware.com/cmake/cmake/-/issues/14983\">POSITION_INDEPENDENT_CODE does not add -pie (#14983) · Issues · CMake / CMake · GitLab</a></p>\n</li>\n<li><p><a href=\"https://newbedev.com/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld\">What is the -fPIE option for position-independent executables in gcc and ld? | Newbedev</a> </p>\n</li>\n<li><p><a href=\"https://lists.debian.org/debian-devel/2016/05/msg00309.html\">Re: PIE and static libraries</a></p>\n</li>\n</ol>\n",
            "tags": [
                "编译"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/10/02/obsidian_posts/%E6%96%B0%E4%BA%BA%E4%B8%8Ecode%20review/",
            "url": "https://zhougy0717.github.io/2021/10/02/obsidian_posts/%E6%96%B0%E4%BA%BA%E4%B8%8Ecode%20review/",
            "title": "新人与code review",
            "date_published": "2021-10-02T04:26:16.078Z",
            "content_html": "<p>通常commtter都是一些比较资深的员工，因为通过阅读代码发现问题，需要：</p>\n<ul>\n<li>迅速读懂代码，意味着比较好的代码抽象能力</li>\n<li>通过阅读代码识别问题，意味着比较丰富的编码经验和调试经验</li>\n</ul>\n<p>那是不是职场新人就不适合对别人的代码code review呢？这可能是很多人的第一印象，但如果你是新人，也这么想，那么你就失去了很多主动学习的机会。</p>\n<p>code review更多的是一个沟通过程。评审人毕竟不是owner，他对代码的熟悉程度大概率是远不如提交人的。评审者多是根据自身的开发经验，以及短时间内对提交代码的理解发现问题。大多数时候，因为每个人的经验，性格，看问题的角度不同，多数时候是抛出一些问题，并形成讨论。当思想发生碰撞时，确实会发现一些问题，或者形成一些更好的想法和设计。这些都是code review能够带来的好处。虽然代码评审需要比较深厚的编码功力，但并不意味着参与代码评审对新人没有任何意义。</p>\n<h1 id=\"新人参与code-review的好处\"><a href=\"#新人参与code-review的好处\" class=\"headerlink\" title=\"新人参与code review的好处\"></a>新人参与code review的好处</h1><p>据我看，至少有以下的好处：</p>\n<ul>\n<li>通常我们可以看到的都是同一个开发领域提交的代码。那么在评审代码的同时，可以阅读已有代码，通过新提交的代码了解某一块的实现逻辑，以学习存量代码。</li>\n<li>如果提交人是比较资深的开发，那么可以借此机会，提出一些问题，向前辈请教。在阅读资深开发提交的代码时，也可以学习一些好的编码实践，而这些通常书本上是不会有的。如果依靠阅读海量的存量代码来学习，可能很快就迷失了，效率也会比较低。而一次代码提交的代码量是比较有限的，且功能相对内聚，比较容易提炼一些抽象逻辑，是一个很好的学习的机会。并且由于提交人需要合入一份新的代码，他可能也更乐于讨论他提交的这一份代码，进而发现问题。所以，这时候提出问题，通常会得到比较积极的回复。</li>\n<li>如果提交人同样资历也比较浅，那么通过阅读别人的代码，来发现问题，通常是我们检验所学知识的很好的一次锻炼机会。知识管理学揭示，通过学习习得的知识只有通过不停的使用，才会内化，进而变成自己的知识。实际开发中使用可以内化知识，使用自己的经验和书本所学，对别人的代码进行评审，并发现问题，也是对所学知识的一种使用。</li>\n</ul>\n<h1 id=\"新人甚少参与code-review的原因剖析\"><a href=\"#新人甚少参与code-review的原因剖析\" class=\"headerlink\" title=\"新人甚少参与code review的原因剖析\"></a>新人甚少参与code review的原因剖析</h1><p>但可惜的是，据我观察，主动投入code review的职场新人真的太少了。我总结原因可能是：</p>\n<ol>\n<li>还是职场上磨不开面子，尤其是害羞腼腆的国内新职场人。如果参考Google的code review指南，把握提出问题的方式，应该没问题的</li>\n<li>中国教育造成的主动思维太少，新人们更关注安排的任务，而缺乏主动学习思考的锻炼。其实你的领导和同事，大多数时候关注的是工作输出，自己的进步还需要自己做主。因为你才是自己的owner。</li>\n<li>加班文化扼杀了很多思考的时间。本来国人的主观能动性就比较差，再加上996的璀璨，留给新人们思考总结和规划的时间就越来越少了。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所有的开发都应当积极的投身code review活动中，新手开发更应该参与其中。可能你一开始并不能很快提出有效意见，但code review更多的时候是一种学习和交流，投身其中有百利而无一害。祝愿所有新手能够迅速走出新手村。</p>\n",
            "tags": [
                "code review"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/30/obsidian_posts/Eminem%E7%9A%84%E4%BA%BA%E7%94%9F%E9%80%89%E6%8B%A9/",
            "url": "https://zhougy0717.github.io/2021/09/30/obsidian_posts/Eminem%E7%9A%84%E4%BA%BA%E7%94%9F%E9%80%89%E6%8B%A9/",
            "title": "Eminem的人生选择",
            "date_published": "2021-09-30T12:04:34.640Z",
            "content_html": "<p>Eminem的《8英里》和宋岳庭的《Life is struggle》是中外说唱届两首史诗级的歌曲。Eminem还有一部同名的自传体电影，讲述了Eminem的成名经历——他如何从一个街头小混混最后走上正轨。是的，不是成功，是正轨。可能Eminem认为这一步选择比Doctor Dre最后选择他，对他人生的意义更重大。</p>\n<p>影片的风格非常写实，与其他记录片不同的是，《8英里》电影结束的时候，Eminem还是一个名不见经传的打工人。电影最后一个镜头是Eminem坐在公交车上，背景音乐不断响起《8 mile》这首歌的片段。Eminem时而望向窗外的八英里路，时而低头写着什么。此时的他应该正在创作《8 mile》这首歌——他的成名曲，影响了成千上万rapper的金曲。也成功打动了他的伯乐Doctor Dre。</p>\n<p>整部影片的色调昏暗，剧情也很沉闷，所以<a href=\"https://www.imdb.com/title/tt0298203/\">IMDb</a>评分不高（7.1）。我看这部片子的时候还在读书，当时也只当是偶像的传记，仅此而已。</p>\n<p>若干年后，一次又一次听到这首歌，恍惚已经十来年了。这首歌常年在我的歌单中，只是人经历多了，就突然会有些感悟。</p>\n<p>Eminem起初是个小混混，没有正经工作，然后身边都是来自街头的狐朋狗友。Eminem喜欢rap，有点水平，也混迹于club。他的朋友们告诉他你就是个说唱天才，你随便去battle，就会有制作人来相中你。然后跪舔着让你出专辑，然后大卖，然后你就是巨星了。但实际上是，</p>\n<blockquote>\n<p>Sometimes I wanna jump on stage and just kill mics<br>And show these people what my level of skill’s like</p>\n<p>But I’m still white<br>Sometimes I just hate life</p>\n<p>I just can’t do it<br>My whole manhood’s just been stripped<br>I’ve just been ripped<br>So I must been dipped<br>Or the bustin split<br>Man fuck this shit yo<br>I’m goin the fuck home</p>\n</blockquote>\n<p>他渴望成功，他希望观众能知道他的说唱技巧有多牛。但是只要一上场就发蒙，因为他是个白人。和NBA一样，说唱圈是黑人的世界，白人是被歧视的。他没有像他朋友们吹捧的那样技惊四座，而是只想goin the <em>*</em> home。<br>后来Eminem通过他的那帮狐朋狗友的介绍，认识了一个制作人。辛辛苦苦攒钱，想出一张专辑，把自己最后的希望寄托在这张专辑上，希望能够出人头地，结果发现，这个所谓的制作人只是看上了她的女朋友。</p>\n<p>人生各种不如意在这一刻汇集。如果一个不够坚强的人可能就此沉沦。但毕竟他是Eminem，他的选择帮他走出人生的黄昏。其实并没有那么惊人，只是重新规划人生。不再寄希望于一鸣惊人。对他的狐朋狗友敬而远之，远离毫无意义的吹捧。努力挣钱，因为有钱才可以继续音乐上的锻炼。</p>\n<p>认清自己和牛人的差距。做好自己，努力投资自己，才会得到机会的垂青。不要只是一味地沉浸在对自己的幻想中，可能你以为的贵人只是看中了你的马子。另外除了那些别有用心的家伙，其实Eminem身边的那些狐朋狗友也并没有坏心。他们可能确实是那么想的。他们或存心或无意地制造了一些噪音，每个人应当能够保持自己的理智和判断力。认清自己眼下的形式，不要被噪音带偏了方向。就像《8英里》里面的Eminem一样。</p>\n<p>Eminem最终选择了一条脚踏实地的路。片尾的断断续续的背景音乐《8 mile》代表了Eminem的未来。他的只管付出，不问前程，终于让他具备了《8 mile》的水平。这首足足6分多钟的rap，歌词简直就是电影的浓缩版，完整地记录了这个Slim Shady曾经的生活窘迫。他试图打破命运的挣扎，和最终走出八英里的勇气。</p>\n<blockquote>\n<p><strong>注</strong><br>美国的城市喜欢用距离城区的距离作为路名。8 mile road代表一条叫做8英里的路，距离城区有8英里路程。也就是所谓的Up Town。这里是Eminem的家，也是他最潦倒的时候的家。他要走出8 mile road，才能登上更大的舞台。</p>\n</blockquote>\n",
            "tags": [
                "rap",
                "Eminem"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/29/obsidian_posts/%E4%BB%8E%E8%B4%BE%E7%91%9E%E7%9C%8B%E2%80%9C%E7%97%B4%E2%80%9D/",
            "url": "https://zhougy0717.github.io/2021/09/29/obsidian_posts/%E4%BB%8E%E8%B4%BE%E7%91%9E%E7%9C%8B%E2%80%9C%E7%97%B4%E2%80%9D/",
            "title": "从贾瑞看“痴”",
            "date_published": "2021-09-29T14:25:05.885Z",
            "content_html": "<p>红楼梦里面有一个无足轻重的“小人物”，叫贾瑞。他是荣宁两府的远房亲戚。贾瑞的爷爷贾代儒是代字辈的老学究，也就是贾宝玉的爷爷辈。贾代儒终身未取功名，只能在贾家的私塾当个教书先生，带一帮纨绔子弟读书。贾代儒的孙子也就是贾瑞，只能随爷爷做个小助教，越发的没有地位。贾瑞约摸20出头年纪，比起宝玉大不了几岁，论辈分还是个哥哥辈。但论地位，却如何比得上着红袍戴金冠的芊芊公子哥。偏偏这样一个小把戏，却爱上了两府最有势力，又最势利，最狠辣的凤辣子。可想见最后是没什么好果子的。但观其走向灭亡的过程，也是令人不甚唏嘘。</p>\n<p>第一遍读红楼的时候，也没太关注过这个人，只是对风月宝鉴略有印象。然后对贾瑞的印象，也就是个形容猥琐的好色之徒。这次读《蒋勋读红楼》的时候，通过蒋公的解读，才领略到贾瑞的可怜。其实贾瑞能和秦可卿同章去世，作为警幻仙子秦可卿的对照面，又死于风月宝鉴之下（红楼梦有一个版本就叫《风月宝鉴》），可见曹雪芹在这个人物身上是蕴含了深意的。</p>\n<p>佛教常说贪嗔痴三毒。贪字，嗔字好解，都是不好的意思。贪字为贪念，人如果欲望与现实脱节，就会产生贪念。嗔为嗔怒，因为欲望得不到满足，人就会出离愤怒。贪嗔二字给人带来不好的情绪。偏偏这个痴字不太好解。痴为妄想，执着一念，而抛弃理智，按佛道的观念，应当也是一种不好的情绪。人应当远离。但现今社会倒慢慢提倡这种痴，例如：对一个人忠贞不渝称为痴情，对一件事追求极致称为痴迷。似乎痴字都快成褒义词了。</p>\n<p>贾瑞对王熙凤的用情就可谓痴情。</p>\n<blockquote>\n<p>他们的家世完全不般配，而王熙凤又十分厉害。王熙凤每一次故意戏弄他，他总是一而再再而三地上当。<br>他其实很痴，他被王熙凤骗了一个晚上，寒冬腊月蹲在地上冻了一夜，回去又被他祖父打了一顿。第二天他去找王熙凤的时候，王熙凤立刻抱怨他，说你昨晚怎么没有来，他马上觉得是他自己错了，赶快跟王熙凤再约。</p>\n</blockquote>\n<p>曹雪芹刻画了一个彻头彻尾的呆瓜，被渣女玩弄的过程。最后呆瓜被玩死了。其实贾瑞最后还有救赎的机会。</p>\n<blockquote>\n<p>一个跛足道士要度化他，给他一面“风月宝鉴”镜子，让他不可以看正面，只可以看反面。<br>它的反面是一个骷髅。可是贾瑞觉得骷髅不好看。他翻过镜子的正面一看，王熙凤在里面向他招手，他便“荡悠悠”进镜子里跟她做爱，最后“纵欲而死”。</p>\n</blockquote>\n<p>读者从第三人称的角度很容易看破贾瑞的“痴”。贾瑞是个刚二十岁出头的小伙子，第一次情窦初开，陷入他的女神王熙凤的情网中不能自拔，也是可以理解的。如果他这次有幸能跳出这个”痴“，回归一点理性，他可能也会对自己的不能自拔付之莞尔。只可惜世事没那么多如果。</p>\n<p>佛家说痴字是毒，是要大家放下那份执念。那种不管不顾的感情所带来的美好，只存在于戏剧和文学作品中，或是人们想象里。现实生活中的执念往往都带会给人带来伤害。但如今纷繁尘世，又比曹雪芹时候诱惑更多。要抛去这个痴字谈何容易。毕竟千百年不变的是人性。就好比当下社会的中国家长，在子女教育上就深陷这个“痴”字，尤其是妈妈们。可能女性天生更容易焦虑吧。</p>\n<p>每位家长心目中都有一份痴情，那就是“望子成龙，望女成凤”。中国自古就有这个传统。人说时代变化快。但不变的是家长的“痴”。十几年前不也有一首儿歌，唱到：</p>\n<blockquote>\n<p>我学学这个<br>学学那个忙得不的了<br>我的烦恼<br>又有谁会知道<br>学的太多学的太杂消化不了<br>爸爸听我说<br>妈妈听我说<br>我喜欢和小朋友蹦蹦跳跳<br>……</p>\n</blockquote>\n<p>可见这自古时代变迁、社会进步，却改变不了人性。现今家长心目中如贾瑞那般对女神的情愫，就是希望孩子能金榜题名、前程似锦的梦想。而诸多的教育机构就有利用了这份”痴“，将家长们玩弄在股掌之中。好似王熙凤的狡诈与狠辣。我不知道，贾瑞有没有意识到王熙凤的存心玩弄。我想可能贾瑞偶尔会意识到，但只要王熙凤略施手段，他又相信他还是有机会了。我们现在的家长又何尝不是这样？在报补习班的时候，他们有没有想过，我的孩子能接受得了吗？在孩子出现这样那样的问题时，他们有没想过，是不是我哪里没做好呢？我想家长们的心里可能会时而冒出一些直击灵魂的瞬间，就像风月宝鉴的正面。虽然它能拯救贾瑞的身体和灵魂，但它并不能慰藉贾瑞的执念。虽然有跛足道人想度化贾瑞，但这时候谁也帮不了一个已经陷入“痴”字的人。只有自己能镇定心神，明白判断什么是自己需要的，才能走出这个执念，走出这个“痴”。如果走不出，时间也过去了，人生就这么短短几十年。像贾瑞一样，就再也没机会翻盘了。</p>\n",
            "tags": [
                "红楼梦",
                "教育"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/25/obsidian_posts/%E7%BE%A4%E6%99%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6%E5%9B%BE%E4%B9%A6%E9%A6%86/",
            "url": "https://zhougy0717.github.io/2021/09/25/obsidian_posts/%E7%BE%A4%E6%99%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6%E5%9B%BE%E4%B9%A6%E9%A6%86/",
            "title": "群晖搭建个人电子书图书馆",
            "date_published": "2021-09-25T14:24:30.253Z",
            "content_html": "<p>最近比较迷群晖的docker。虽然电子书库对我来说用处不是很大，但也忍不住折腾了一番。最后导入藏书的时候才发现，原来像收破烂一样，收了很多书，真正读的不过1，2成。最近看过一些整理笔记或者知识管理的博文，里面提到知识应当不断整理，才能转化为自己的知识。这些收藏在角落里的应当果断地断舍离。这是题外话了。<br>本文主要还是记录一些折腾心得，希望可以帮到需要的人，可以节省一些时间和精力。网络上其实有很多已经实践了的文章，可作参考：</p>\n<ul>\n<li><a href=\"https://sspai.com/post/64202\">打造基于 NAS 的个人随身数字书库 - 少数派</a></li>\n<li><a href=\"https://post.smzdm.com/p/534074/\">skylake架构DIY NAS 篇二：打造属于自己的私人云书库<em>NAS存储</em>什么值得买</a></li>\n<li><a href=\"https://www.jianshu.com/p/66c160ee6677\">[拍娃党之文件管理：NAS篇二]Calibre-web电子书库解决方案 - 简书</a></li>\n</ul>\n<p>Calibre是一个电子书管理软件，请看“<a href=\"https://calibre-ebook.com/zh_CN\">calibre - 电子书管理</a>”。然后，有热心网友，将其web化，提供了基于Bootstrap框架的web客户端，即“<a href=\"https://github.com/janeczku/calibre-web\">janeczku/calibre-web</a>”。再然后，docker镜像也就应运而生，于是群晖结合docker又具备了新的可玩性。Calibre-web的docker镜像主要有两个：</p>\n<ul>\n<li><a href=\"https://hub.docker.com/r/technosoft2000/calibre-web\">technosoft2000/calibre-web - Docker Image | Docker Hub</a></li>\n<li><a href=\"https://hub.docker.com/r/linuxserver/calibre-web\">linuxserver/calibre-web - Docker Image | Docker Hub</a></li>\n</ul>\n<p>在群晖的docker中都可以安装，两款docker的主要区别在于后者不包含电子书格式转换模块，而前者则是包含了转换模块。可以将电子书转换成不同格式，例如：PDF，EPUB，AZW3，MOBI等等。</p>\n<p>我最终选择了technosoft2000/calibre-web，倒不是因为电子书转换功能。而是因为linuxserver/calibre-web过于精简。该docker中vi工具都没有，也缺少calibredb工具。对于我这种需要批量导入已有图书的就不太友好了。后文有针对批量导入的一些个人的经验分享。</p>\n<p>后续章节罗列一些我遇到的问题和解决的方法。</p>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><p>第一次打开Calibre界面时，需要选择数据库地址。一开始选择的linuxserver/calibre-web镜像，怎么都没法进入主界面。参考<a href=\"https://zhuanlan.zhihu.com/p/357220232\">Calibre-web部署后一些细节问题答疑 - 知乎</a></p>\n<blockquote>\n<ol>\n<li>其他文章提到部署时需要metadata.db文件，不然在进入网页配置时会无法进行下一步。</li>\n</ol>\n<p>答：technosoft2000/calibre-web这个镜像倒是会自动去创建metadata.db文件，不需要像其他镜像那样需要用户先用PC版calibre来创建metadata.db然后复制进群晖相关文件夹。但更容易遇到另一个问题，我在问题2里说。</p>\n<ol>\n<li>最初运行technosoft2000/calibre-web镜像数分钟后，calibre-web会自动停止运行。并且在日志里查看会提示缺少“<code>***.py</code>”文件。</li>\n</ol>\n<p>答：虽然technosoft2000/calibre-web会自动下载运行所需的文件，但因为它本身服务器和国内连接不畅的原因，很容易出现下载失败的情况，然后就会有类似提示。需要等待其他时间段尝试让其自动下载文件，或者改善网络。</p>\n</blockquote>\n<p>我是使用technosoft2000/calibre-web镜像，直接可以生成metadata.db，并直接进入界面。如果是用linuxserver/calibre-web镜像可能要动点其他的小心思。比如用PC端Calibre生成好metadta.db文件，再拷过来。为了省事儿，可以直接上technosoft2000/calibre-web，各种定制性还是令人省心不少。</p>\n<h1 id=\"支持豆瓣\"><a href=\"#支持豆瓣\" class=\"headerlink\" title=\"支持豆瓣\"></a>支持豆瓣</h1><p>豆瓣已经在2020年8月无情地关闭了书籍元数据下载功能（俗称刮削）。网上搜到的大多是无效的解答，例如：“<a href=\"https://blog.csdn.net/wangrui1573/article/details/111880264\">calibre-web 获取元数据 豆瓣API失效解决办法_瑞哥的博客-CSDN博客_calibre 元数据</a>”。<br>最新（2021年9月）亲测可用的办法是使用这个docker镜像服务：<a href=\"https://github.com/fugary/simple-boot-douban-api\">fugary/simple-boot-douban-api: Simple douban book api</a>。具体方法也很简单，在群晖上下载好docker，并启动，然后再修改代码，重启Calibre-web docker镜像即可：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /calibre-web/app/cps/<span class=\"built_in\">static</span>/js/get_meta.js</span><br><span class=\"line\"><span class=\"comment\"># 找到 var douban = &quot;https://api.douban.com&quot;; 替换成自己的NAS_IP地址</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> douban = <span class=\"string\">&quot;http://NAS_IP:8085&quot;</span>;</span><br></pre></td></tr></table></figure><br>成功示例：<br><img src=\"/2021/09/25/obsidian_posts/%E7%BE%A4%E6%99%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6%E5%9B%BE%E4%B9%A6%E9%A6%86/Pasted%20image%2020210926070735.png\" alt></p>\n<p>另外值得一提的是，calibre-web集成的Google books搜索，在客户端（非NAS端）科学上网的情况下，就可以获取数据。针对日常刮削场景多一个选择总归是好的。<br><img src=\"/2021/09/25/obsidian_posts/%E7%BE%A4%E6%99%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6%E5%9B%BE%E4%B9%A6%E9%A6%86/Pasted%20image%2020210926071201.png\" alt></p>\n<h1 id=\"批量导入\"><a href=\"#批量导入\" class=\"headerlink\" title=\"批量导入\"></a>批量导入</h1><p>可以参考这一篇“<a href=\"https://blog.einverne.info/post/2020/02/qnap-calibre-web.html\">威联通折腾篇十九：Calibre-web | Verne in GitHub</a>”。其实就是会用这个命令就可以了：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calibredb add --library-path=/books -r /path/to/your/book_dir_you_want_to_add</span><br></pre></td></tr></table></figure><br>calibredb还有很多其他功能，看帮助文档就好了，简单易学：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: calibredb command [options] [arguments]</span><br><span class=\"line\"></span><br><span class=\"line\">calibredb is the command line interface to the calibre books database.</span><br><span class=\"line\"></span><br><span class=\"line\">command is one of:</span><br><span class=\"line\">  list</span><br><span class=\"line\">  add</span><br><span class=\"line\">  remove</span><br><span class=\"line\">  add_format</span><br><span class=\"line\">  remove_format</span><br><span class=\"line\">  show_metadata</span><br><span class=\"line\">  set_metadata</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"SSL-setting\"><a href=\"#SSL-setting\" class=\"headerlink\" title=\"SSL setting\"></a>SSL setting</h1><p>如果需要通过https访问calibre-web网页，建议通过群晖反向代理设置。只要配置好证书，就可以访问。不要轻易碰下面的配置。<br><img src=\"/2021/09/25/obsidian_posts/%E7%BE%A4%E6%99%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6%E5%9B%BE%E4%B9%A6%E9%A6%86/Pasted%20image%2020210928222325.png\" alt><br>如果一定需要，请参考<a href=\"https://github.com/Technosoft2000/docker-calibre-web/issues/98\">SSL setting · Issue #98 · Technosoft2000/docker-calibre-web · GitHub</a>。<br>我就是误配置，导致页面显示ERR_EMPTY_RESPONSE。最后需要将书库中的这几个文件删除，才能打开网页。</p>\n<ul>\n<li>app.db</li>\n<li>gdrive.db</li>\n</ul>\n<p>具体原因不详。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>建议选择technosoft2000/calibre-web镜像</li>\n<li>建议使用fugary/simple-boot-douban-api取代豆瓣API刮削</li>\n</ul>\n",
            "tags": [
                "群晖",
                "Calibre",
                "电子书"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/",
            "url": "https://zhougy0717.github.io/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/",
            "title": "单元测试 vs. 功能测试",
            "date_published": "2021-09-19T12:40:57.189Z",
            "content_html": "<p>最近在某一次讨论测试的话题中，有一位同事认为“重构结果看护，用集成测试（Integration Test）就可以了，UT看护的逻辑太小，导致修改过于频繁，维护成本太高，没必要。”</p>\n<blockquote>\n<p>几种测试名词：</p>\n<ul>\n<li>单元测试（Unit Test或UT）<br>针对小的代码逻辑编写的测试，不需要运行在真实环境上的，可以随时部署，随时运行，结果应当保持一致</li>\n<li>功能测试（Function Test）<br>针对特性功能编写的测试，应当与实际运行环境保持一致，测试软件产品端到端功能</li>\n<li>集成测试（Integration Test）<br>针对系统或子系统中某个组件的特性功能编写的测试，对其依赖组件进行打桩，并在真实环境进行部署测试，通常用于看护代码提交质量</li>\n<li>冒烟测试（Smoke Test）<br>我们通常说的ST指的是冒烟测试，而非系统测试（System Test），冒烟测试与集成测试指代同一种测试</li>\n</ul>\n<p>另外，IT或ST都是一种功能测试，除此之外，还有看护完整特性功能的测试，性能测试等，都属于功能测试</p>\n</blockquote>\n<p>这位同学给出IT可以胜任看护重构结果的原因有：</p>\n<ul>\n<li>IT通过对周边依赖进行打桩，可以达到80%的覆盖率，看护力度足够</li>\n<li>只要设计足够精巧，完成一个大型工程的IT只需要十分钟，运行速度足够快</li>\n</ul>\n<p>因为在重构中，IT完全可以看护代码质量<sup>1⃣️</sup>，所以UT的作用就削弱了<sup>2⃣️</sup>。又因为UT看护粒度过细，导致UT代码维护困难，维护UT得不偿失<sup>3⃣️</sup>。而实际上，那个榜样部门就是这样做的——只用IT看护重构，库上代码放弃开发维护UT。</p>\n<p>先不遑论该部门做法的对与错，我们首先针对上面提到的三个观点进行剖析。</p>\n<h1 id=\"IT完全可以看护代码质量\"><a href=\"#IT完全可以看护代码质量\" class=\"headerlink\" title=\"IT完全可以看护代码质量\"></a>IT完全可以看护代码质量</h1><p>这一点我是认同的。UT的关注点是组成接口代码的小逻辑。虽然理论上只要保证每个小逻辑的输入输出正确，就可以保证一个接口的正确性，进而到模块，组件，系统级别。但是，因为UT对模块的划分比较细，模块之间采用打桩的方式解决依赖问题，而mock质量参差不齐，势必会造成对接口间，模块间的测试误差。这也是不可测性的一种体现。相反，因为IT的测试关注点，在特性功能（至少是组件级的功能），所以IT更擅长于发现组件集成时的bug（所以叫集成测试嘛）。</p>\n<h1 id=\"UT的作用被削弱了\"><a href=\"#UT的作用被削弱了\" class=\"headerlink\" title=\"UT的作用被削弱了\"></a>UT的作用被削弱了</h1><p>刚才说到IT相比UT更擅长看护代码质量，那是不是意味着UT没用了呢？<br>答案是否定的。我们先看看什么是IT不擅长的：</p>\n<ol>\n<li>由于IT关注的代码粒度较大，看护的是模块或组件间的特性接口，不利于构造细粒度的case，这造成分支覆盖率低。或者说如果要实现超高分支覆盖率，IT付出的成本会比较高。其结果就是测试稳定性高了（随代码改动而失败的频率降低，只要组件间接口保持一致，IT就不需要变更），但对代码修改的敏感度降低。</li>\n<li>IT的开发成本高。因为涉及到多模块甚至多组件协同，case复杂度高。如果涉及模块间接口打桩，由于接口复杂度高，桩代码实现也更为复杂。在特性代码开发过程中，无法进行有效的IT开发和测试。</li>\n<li>IT运行时间久。前面说到一个比较大的工程运行一次IT，运行时间可以控制到十分钟。可能很多人都认为十分钟是能够忍受的长度。对于IT来说，这确实是一个很优秀的数字了（我想为了实现这一点本身也是要付出很大的代价的）。但是如果将其运用到red-green-refactor的开发节奏中，还是有些不合时宜。试想，你要运行一个预计十分钟会完成的测试，你会全身灌注地盯着屏幕，等待十分钟直到测试完成吗？</li>\n</ol>\n<p><img src=\"/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/Pasted%20image%2020210829201431.png\" alt></p>\n<p>我想通常是不会的。这时候，自制力差一点的同学就开始刷手机了，自制力好一点的同学会着手处理其他问题。这其实就是另一种被打断。而被打断是软件开发的大忌。你不仅失去进入“心流”的机会，并且你回到主线开发的时间间隔越长，花费在重建现场的额外开销就会越大，进而影响你的效率。</p>\n<p>先看看我们利用IT进行一次前文提到的大型“重构”的流程会是怎么样的？</p>\n<blockquote>\n<p>这里说的重构，我认为称为re-architecture更合适，和我们平时说的refactor还是不太一样。他们的共同点是，保证代码功能不变的前提下，优化代码架构和实现。区别是，re-architecture是一次根本性的架构变更，可能涉及到很多模块需要重写，而refactor更多的是在平时做一些代码调整，即所谓的小步重构。</p>\n</blockquote>\n<ol>\n<li>定好特性架构，开始特性开发</li>\n<li>特性代码接近完成时，开始开发IT</li>\n<li>开发IT的同时，一边调试IT，一边使用IT测试特性代码</li>\n<li>重复步骤3直到IT代码和特性代码均没有问题，即达到可交付状态。</li>\n</ol>\n<ul>\n<li>前文提到IT的测试时间相比UT还是比较久的，如果将其运用到red-green-refactor节奏中，则容易造成注意力分散，进而引起时间管理困境</li>\n<li>如果没有UT，步骤2通常会一直处于“裸奔”状态，“裸奔”的时间取决于开发者对特性代码开发状态的评估，一般要到特性代码比较接近完工水平时，才可以编写IT。由于IT开发调试难度高，基本也不太可能和特性代码一同开发。</li>\n<li>由于IT开发和运行的成本高，那么势必造成开发时，针对特性代码的测试运过少，那么由于开发的不稳定性，产生的返工可能性大，成本高。（换句话说，如果开发对于特性的熟悉程度非常高，实际上也可以不一定即时UT，还是选择与平衡问题。不过这种情况据我观察还是比较少的）</li>\n</ul>\n<p>所以抛弃UT，确实节省了一些代码开发时间，但也丢失了一件非常重要的武器，导致我们的开发节奏又回到了瀑布式开发，而无法实现小步快跑的即时重构开发方式。</p>\n<p>实际上我认为，<strong>引入UT就是为了引入reg-green-refactor的开发节奏，从而通过实时重构，及时消除代码坏味道，进而实现代码自下而上的架构设计</strong>。与前期自上而下的特性设计配合，以实现最合理的代码架构。避免在特性设计阶段过于关注实现细节，也避免在开发阶段，过于纠结权衡欠设计与过设计导致的效率低下。</p>\n<p>UT的运行成本非常低，这是因为UT不关注代码功能，只关注代码输入输出逻辑。全程对依赖接口进行打桩实现，运行速度很快（没有任何的延时和多线程操作，也可能连IO操作都没有）。UT针对小逻辑组织case，单case复杂度低，case之间的依赖关系被严格控制。所以运行的时候，一方面速度快，另一方面可以根据需要，随意组合运行的case以达到需要的测试范围和粒度。例如：可以选择运行一个case或是一个suite，也可以通过正则表达式运行多个case，或者完整运行所有的case。</p>\n<p>综上可见，UT和IT是两类用途完全不同的测试方法。一个好比军刀，可以上战场杀敌；一个好比菜刀，可以烹小鲜慰军。一个看护结果；一个促进过程。</p>\n<h1 id=\"UT维护困难，维护UT得不偿失\"><a href=\"#UT维护困难，维护UT得不偿失\" class=\"headerlink\" title=\"UT维护困难，维护UT得不偿失\"></a>UT维护困难，维护UT得不偿失</h1><blockquote>\n<p>那UT带来的工作量呢？</p>\n</blockquote>\n<p>刚才说，如果没有UT，其实会引入很多隐性工作量。如果要衡量工作量，更公平的比较应当是将维护UT的工作量与这些隐性工作量进行比较。通常我听到的对UT的抱怨大多是因为UT看护内部模块边界。当组件内部实现修改时，例如函数改名字，变更函数原型等一些特别频繁的重构操作，由于IT看护组件边界接口，IT更稳定不需要变动。而UT由于看护了内部模块边界，所以UT要随之更新。这些确实看起来是额外的工作量，但当前流行的开发工具，例如一些IDE或者VS code，都已经能够提供很好的重构工具，在修改函数名字，修改函数原型，或者抽取函数或内联函数等操作上，都已经可以大大减少开发者的操作难度。另外，由于UT对代码的敏感性，让你实时都感受到你的代码变动都是经过测试的，每一次变动都被看护，这种感觉不是很令人有安全感吗😊？</p>\n<p>而传统的瀑布式开发带来的隐性问题，很多是因为人类思考方式导致的。例如思路打断，对过设计和欠设计的恐惧，不停返工引起的沮丧心情。这些带来的影响很难去估量，他们可能很严重，也可能无足轻重，完全取决于开发者自身的素质。以我个人的经验看，我是更愿意花一些切实的UT成本，来消除这些不确定性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>再回过头来分析一下那个成功部门的做法。通过IT看护重构结果，并丢弃UT这种测试方法。首先，重构结果大概率不会有问题，因为有足够测试力度的IT作为看护工具。其次，因为缺乏及时运行的测试case，重构开发时效率得不到保证。大概率只能通过模块重写实现。另外，又因为重构效率低，成本高，重构只能积攒起来一次性完成。于是refactor变成re-architecture。</p>\n<p>不过话说回来，测试策略并没有对错之分，永远是项目组根据自身情况，权衡得出的。可能项目组一时无法获得UT的价值，或者项目组对UT对技术积累不充分，从而无法很好对实践UT。但我们还是应该厘清单元测试和功能测试的差别，分清应用场合，这样才能更好地朝正确的方向演进。</p>\n",
            "tags": [
                "UT",
                "TDD"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/RBAC/",
            "url": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/RBAC/",
            "title": "RBAC",
            "date_published": "2021-09-18T14:17:35.996Z",
            "content_html": "<p>RBAC, Role Based Access Control, 是SELinux的另一个重要的特性。但他并不是一种独立的控制方式，而是对TEAC的一种补充。其主要的作用是，构建SELinux提供的进程级的MAC机制与Linux的用户系统的映射关系。</p>\n<h1 id=\"RBAC工作原理\"><a href=\"#RBAC工作原理\" class=\"headerlink\" title=\"RBAC工作原理\"></a>RBAC工作原理</h1><p>RBAC并不提供强制访问控制，而是通过user，role，type之间的对应关系，来控制type_transition策略能否成功。</p>\n<h2 id=\"role-vs-type\"><a href=\"#role-vs-type\" class=\"headerlink\" title=\"role vs. type\"></a>role vs. type</h2><p>role based最基本的就是定义role到type到对应关系。使用role语句可以实现：<code>role role_name [types type_set];</code>。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">role user_r types user_t;</span><br><span class=\"line\">role user_r types &#123; staff_t, admin_t &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>role定义是累积的，即后面的对应关系不会覆盖前面语句定义的对应关系，而只会追加这种关系</li>\n<li>role语句通常定义在type声明附近，以确保该对应关系被及时定义</li>\n</ul>\n<blockquote>\n<p><strong>定义子role (period)</strong><br>A period is used to indicate restrictions on the set of types that may be assigned to a role. For example, the set of types for a role called <strong><em>apache.cgi</em></strong> must be a <strong><em>subset</em></strong> of the type set of a role called <strong><em>apache</em></strong>.</p>\n</blockquote>\n<p>role语句定义的基本逻辑就是，定义了role=&gt;{ types }集合的映射关系。当发生type transition时，如果转换后的{role，type}组合未定义，则视为权限错误。从这个层面看，role对应的是主体type，即domain type，而非object type。</p>\n<h3 id=\"特殊的role-object-r\"><a href=\"#特殊的role-object-r\" class=\"headerlink\" title=\"特殊的role: object_r\"></a>特殊的role: object_r</h3><p>object_r是内核SELinux模块预定义的一个role，无需在policy中声明。而这个object_r被专门用来定义客体的安全上下文。</p>\n<h2 id=\"user-vs-role\"><a href=\"#user-vs-role\" class=\"headerlink\" title=\"user vs. role\"></a>user vs. role</h2><p>user是对role的再一次扩充，通过user将role与Linux user的映射关系建立起来。SELinux的用户系统独立于Linux用户系统。通过seusers文件或者<code>semanage user</code>命令可以定义他们之间的映射关系。但实际可定义的自由度并没有那么高。</p>\n<blockquote>\n<p>The design decision for SELinux to have a distinct user identifier (rather than share that of Linux) is motivated by the desire to create an immutable SELinux user identifier.</p>\n</blockquote>\n<p>定义一个user与role的映射关系，可以使用user语句：<code>user user_name roles &#123; role_set &#125;;</code><br>user语句所体现的逻辑和role语句类似，即定义了user=&gt;{ roles }集合的映射关系。当应用启动时发生role transition时，如果转换后的{user, role}未定义，则视为权限错误。</p>\n<p>当SELinux通过RBAC，建立起user=&gt;role=&gt;type的映射关系以后，还获得了一个好处。Linux系统的用户数可能很多，而用户的类型很少。用户并不是为了定义权限的，不同的用户之间的使用数据需要隔离。但往往一类用户的权限是相同的。例如超级用户，管理员用户，普通用户等等。系统的权限集最小粒度由domain定义。可能每个进程的权限不同，也可能一组进程的权限相同。但往往domain的数量也很庞大。如果没有RBAC，我们需要定义user到domain到映射。这样也不是不能做，但却不太优雅。每次新增用户时，需要为新增用户绑定一堆domain。定义了role之后，role相当于较稳定的一层抽象，role到types的映射关系是在定义type时候就定义了的。增加新user的时候，只要定义user到role的映射即可。这就是引入RBAC的原因。</p>\n<pre class=\"mermaid\">graph LR\nA[user] --> B[role]\nA --> C[role]\nA --> D[role]\nC --> E[domain]\nC --> F[domain]\nC --> G[domain]</pre>\n\n<h3 id=\"Linux用户-vs-SELinux-user\"><a href=\"#Linux用户-vs-SELinux-user\" class=\"headerlink\" title=\"Linux用户 vs. SELinux user\"></a>Linux用户 vs. SELinux user</h3><ul>\n<li>当前系统的用户可以通过查看/etc/passwd文件获取，也可以参考<a href=\"https://zhuanlan.zhihu.com/p/41161408\">列出 Linux 系统上所有用户的 3 种方法</a>.</li>\n<li>查看SELinux的用户可以通过命令<code>semanage user -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               标记中        MLS/       MLS/                          </span><br><span class=\"line\">SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色</span><br><span class=\"line\"></span><br><span class=\"line\">guest_u         user       s0         s0                             guest_r</span><br><span class=\"line\">root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</span><br><span class=\"line\">staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r unconfined_r</span><br><span class=\"line\">sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r</span><br><span class=\"line\">system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">user_u          user       s0         s0                             user_r</span><br><span class=\"line\">xguest_u        user       s0         s0                             xguest_r</span><br></pre></td></tr></table></figure></li>\n<li>查看两者的映射关系可以通过命令<code>semanage login -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名                  SELinux 用户           MLS/MCS 范围           服务</span><br><span class=\"line\"></span><br><span class=\"line\">__default__          unconfined_u         s0-s0:c0.c1023       *</span><br><span class=\"line\">john                 user_u               s0                   *</span><br><span class=\"line\">root                 unconfined_u         s0-s0:c0.c1023       *</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Linux用户和SELinux用户的初始映射关系由seusers文件指定。这个文件不属于策略二进制的一部分，而可以直接修改生效。当然更优雅的办法是通过semanage命令来修改。<br>另外，在修改了context以后，或者新建了用户以后，必须要使用注销登录的方法，才能使新的context生效，而只使用su命令切换用户，并不会切换context。推测注销登录使用的是PAM登录程序，而su命令中，并没有重新加载user context的功能。<br>Linux用户登录后，获取shell安全上下文的步骤，可以参考文献【2】。简述如下：</p>\n<ol>\n<li>根据seusers文件，映射SELinux用户，如果没有seusers文件，系统就无法启动了。如果seusers文件没有对应的用户描述，则统一映射为<code>__default__</code>用户。如果<code>__default__</code>用户描述不存在，则无法登录。</li>\n<li>根据SELinux的搜索优先级，找到对应SELinux用户的安全上下文。</li>\n</ol>\n<blockquote>\n<p><strong>勘误</strong><br>在[1]中，对Linux用户和SELinux的映射关系有如下描述：<br>On login, if there is an SELinux user identifier that is exactly the same as the Linux user identifier, the matching SELinux user identifier becomes the user identifier in the security context for the initial shell process. In this way, if a Linux user identifier also exists as a user identifier in the SELinux policy, all login processes will set the initial shell process security context user identifier to that matching Linux identity.<br>经实验证明，并非如此：</p>\n<ul>\n<li>定义了一个guest_u用户，登录后，其shell的安全上下文仍为：<br><img src=\"/2021/09/18/obsidian_posts/RBAC/163C5090-847B-49EC-B709-3AAA87D776D9.png\" alt=\"1ca6909a350aa84947ea565bb4c8eaa2\"></li>\n<li>但事实证明，明明就有guest_u这个用户<br><img src=\"/2021/09/18/obsidian_posts/RBAC/CA68A544-BEE4-4B4E-9BC5-EA3452F816F9.png\" alt=\"7737fbc74190005733b9f01b60178907\"><br>推测，可能是因为SELinux也一直在发展改进中。[1]d 成书时间是2006年，彼时还是FC（Fedora Core）5的年代，现在最新版已经是Fedora 33，2020年10月份发布。</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在可以引用[1]中的一幅图来总结一下RBAC的工作原理了。<br><img src=\"/2021/09/18/obsidian_posts/RBAC/6903A6B7-B8D6-4621-8AF4-C276F4EAD57F.png\" alt=\"115b4d2e2576fd1b93937d66425645d5\"></p>\n<ul>\n<li>Linux系统有一个用户较joe</li>\n<li>SELinuxcelue中规定joe和user_r绑定，user_r和user_t绑定</li>\n<li>当joe登录时，系统根据seusers（此处与图不同，参见上一章勘误），找到对应的SELinux user，找不到就是<strong>default</strong>, <strong>default</strong>没有就不能登录了</li>\n<li>根据以下context文件顺序，决定其shell的安全上下文，即joe:user_r:user_t<ul>\n<li>/etc/selinux/specified-policy/contexts/users</li>\n<li>/etc/selinux/specified-policy/contexts/default_contexts</li>\n<li>/etc/selinux/specified-policy/contexts/failsafe_context</li>\n<li>sid kernel的安全上下文</li>\n</ul>\n</li>\n<li>joe执行了一个应用，开始进行domain_transition, 要从user_t切换到passwd_t<ul>\n<li>如果定义了<code>role user_r types passwd_t</code>和<code>role user_r types user_t</code>，则这次domain transition可以成功</li>\n<li>否则任意一个未定义，domain transition都会失败</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"高阶用法\"><a href=\"#高阶用法\" class=\"headerlink\" title=\"高阶用法\"></a>高阶用法</h1><h2 id=\"role-transition\"><a href=\"#role-transition\" class=\"headerlink\" title=\"role_transition\"></a>role_transition</h2><p>role transition和domain transition非常类似，也是在某个domain进程在执行某个可执行文件时，即exec系统调用时，切换进程主体的安全上下文。domain transition切换的时domain，role transtion切换的是role。实现方式通过以下两条语句：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow staff_r sysadm_r; # 允许从staff_r切换到sysadm_r</span><br><span class=\"line\">role_transition sysadm_r http_exec_t system_r; # sysadm_r进程执行http_exec_t类型文件时，role切换为system_r</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"role-dominance\"><a href=\"#role-dominance\" class=\"headerlink\" title=\"role_dominance\"></a>role_dominance</h2><p>可以利用role来定义其他role，即role dominance。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dominance &#123; role super_r &#123;role sysadm_r; role secadm_r; &#125;</span><br></pre></td></tr></table></figure><br>上面例子中的super_r称为dominant role，它可以从它关联的role中即成types。但它只能继承该条语句之前关联的types。我们之前说role语句是可以累积的。那么在role_dominance语句之后定义的types，并不能动态的添加到dominant role上。</p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><p>跟role相关的主要是semnage的一些用法，另外[1]还介绍了一个apol的可视化工具，可以检索user和role的数据。我理解semanage通过命令行也都可以实现。</p>\n<ol>\n<li>前文介绍过的<code>semanage user -l</code>和<code>semanage login -l</code>, 前者用来查看所有SELinux的用户，后者用来查看Linux用户和SELinux用户两者的映射关系.</li>\n<li>Modify the default user on the system to the guest_u user<ul>\n<li><code>semanage login -m -s guest_u __default__</code></li>\n</ul>\n</li>\n<li>修改user和role的对应关系<ul>\n<li><code>semanage user -m -R &quot;message_filter_r unconfined_r&quot; user_u</code></li>\n</ul>\n</li>\n<li>添加一个用户并指定SELinux用户<ul>\n<li><code>useradd joe -Z user_u</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://app.yinxiang.com/shard/s10/nl/161681/ea41e2f7-d7a8-4629-9f8c-c08696f578af/\">SELinux by Example_ Using Security Enhanced Linux</a><br>[2] <a href=\"https://blog.csdn.net/keheinash/article/details/81047520\">SELinux初始化登录用户安全上下文的方法</a></p>\n",
            "tags": [
                "security",
                "SELinux"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/initializer-list%E5%92%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "url": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/initializer-list%E5%92%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "title": "initializer-list和列表初始化",
            "date_published": "2021-09-18T14:07:11.246Z",
            "content_html": "<h1 id=\"C-11的列表初始化\"><a href=\"#C-11的列表初始化\" class=\"headerlink\" title=\"C++11的列表初始化\"></a>C++11的列表初始化</h1><p>在C语言和C++98/03中，大括号可以用来初始化数组，例如：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;; <span class=\"comment\">// 如果个数不足的，用0初始化</span></span><br></pre></td></tr></table></figure></p>\n<p>C++11将这类大括号初始化，扩展到自定义类型，但需要满足一定的条件，否则会编译报错。</p>\n<blockquote>\n<p>参考<a href=\"https://blog.csdn.net/JinhuCheng/article/details/107330983\">C++11新特性之列表初始化、POD、聚合类</a></p>\n<ol>\n<li>C++98/03标准中对于普通数组和POD类型可以直接使用列表初始化；</li>\n<li>C++11标准中对于普通数组和聚合类型可以直接使用列表初始化；</li>\n<li>C++11标准中对于非聚合类型可以通过自定义构造函数的方式使用列表初始化。<br><a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a>提到非聚合类型不能使用列表初始化是不对的。实验证明，不论是不是聚合类型，均可以采用列表初始化。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">A</span>(<span class=\"keyword\">int</span> a1) &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"keyword\">int</span>&gt; l) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tA a = &#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n首先声明<code>A a=&#123;123&#125;</code>或者<code>A a&#123;123&#125;</code>这两种构造方法是一致的。<br>其次，对于这种构造方法，编译器会先尝试用<code>A(std::initializer_list&lt;int&gt; l)</code>去匹配，如果不成功，则会尝试<code>A(int)</code>，如果这两种构造函数都未定义，就会编译报错。<br>另外，成员变量也可以采用就地初始化, 虽然这会导致类成为非聚合类，但并不妨碍其采用列表初始化方法。使用虚函数，有基类的效果都是一样的，不影响列表初始化方法的使用。<h2 id=\"C-11中的几种初始化方法\"><a href=\"#C-11中的几种初始化方法\" class=\"headerlink\" title=\"C++11中的几种初始化方法\"></a>C++11中的几种初始化方法</h2></li>\n<li>就地初始化<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a1 &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> a2 = &#123;<span class=\"number\">12.0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> a3 = <span class=\"number\">12.0</span></span><br><span class=\"line\">        B b&#123;<span class=\"number\">123</span>&#125;</span><br><span class=\"line\">        C c = &#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>构造函数初始化列表<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">A</span>() : <span class=\"built_in\">a</span>(<span class=\"number\">123</span>), <span class=\"built_in\">b</span>(<span class=\"number\">456</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>列表初始化<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) &#123;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先匹配A(std::initializer_list&lt;int, int&gt;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 再匹配A(int, int)</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则报错</span></span><br><span class=\"line\">    A a &#123;<span class=\"number\">123</span>, <span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>就地初始化会最先得到执行，构造函数初始化列表会覆盖就地初始化的值</li>\n<li>如果采用初始化列表，即<code>a&#123;...&#125;</code>初始化，<code>std::initializer_list&lt;T&gt;</code>的构造函数会优先得到执行</li>\n<li>如果采用原生构造函数，即<code>a(int)</code>初始化，<code>A(init)</code>优先得到执行<h1 id=\"什么是initializer-list\"><a href=\"#什么是initializer-list\" class=\"headerlink\" title=\"什么是initializer-list\"></a>什么是initializer-list</h1><strong>摘录<a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a></strong>-初始化列表</li>\n</ul>\n<ol>\n<li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的一些概念。 </li>\n<li>initialzer-list<T>来说，它可以接受任意长度的初始化列表，但是元素必须是要相同的或者可以转换为T类型的。  </T></li>\n<li>三个成员接口，begin(),end(),size(),其中size()返回initialzer-list的长度。  </li>\n<li>能被整体的初始化和赋值，遍历只能通过begin和end迭代器来，遍历取得的数据是可读的，是不能对单个进行修改的。  </li>\n</ol>\n</blockquote>\n<p>注意一：<br>initialzer-list<T>保存的是T类型的引用，并不对T类型的数据进行拷贝，因此需要注意变量的生存期</T></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::initializer_list&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123; <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> c = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = c.<span class=\"built_in\">begin</span>(); it != c.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; it - c.<span class=\"built_in\">begin</span>() &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; (*it) &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处打印是乱的。因为func返回的是右值引用，在退出函数后失效。</p>\n<p>注意二：<br>列表初始化防止类型收窄<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1.1</span>; <span class=\"comment\">//OK</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b&#123; <span class=\"number\">1.1</span> &#125;; <span class=\"comment\">//error</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">float</span> f1 = <span class=\"number\">1e40</span>; <span class=\"comment\">//OK, 科学计数法10^40</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> f2&#123; <span class=\"number\">1e40</span> &#125;; <span class=\"comment\">//error</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x = <span class=\"number\">1024</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c = x; <span class=\"comment\">//OK</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> d&#123; x &#125;;<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> e = y;<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> f&#123; y &#125;;<span class=\"comment\">//error</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://en.cppreference.com/w/cpp/utility/initializer_list\">initializer_list - cppreference.com</a><br><a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a><br><a href=\"https://blog.csdn.net/JinhuCheng/article/details/107330983\">C++11新特性之列表初始化、POD、聚合类</a></p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "url": "https://zhougy0717.github.io/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "title": "聚合类型&POD",
            "date_published": "2021-09-18T14:03:05.792Z",
            "content_html": "<h1 id=\"什么是聚合类型\"><a href=\"#什么是聚合类型\" class=\"headerlink\" title=\"什么是聚合类型\"></a>什么是聚合类型</h1><blockquote>\n<p><strong>C++03定义</strong><br>An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).</p>\n<p><strong>C++11定义</strong><br>An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>结合C++03和C++11标准定义，罗列一下聚合类型的特性：</p>\n<ul>\n<li>聚合类型可以有构造函数，但只能是编译器定义的默认构造函数，或者用<code>=default</code>定义的构造函数</li>\n<li>聚合类型不能有private，protected非static变量</li>\n<li>聚合类型可以有copy-assignment operator and/or destructor</li>\n<li>数组是聚合类型，即便数组成员是非聚合类型</li>\n<li>聚合类型的数组可以是非聚合类型</li>\n<li>聚合类型不能用brace-or-equal-initializers（即就地初始化）初始化非static成员。</li>\n</ul>\n<h2 id=\"聚合类型变量初始化\"><a href=\"#聚合类型变量初始化\" class=\"headerlink\" title=\"聚合类型变量初始化\"></a>聚合类型变量初始化</h2><p>聚合类型可以采用列表初始化（其实非聚合类型，通过自定义构造函数，也可以采用列表初始化）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(m == n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the ith element of the array is initialized with ai</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the first m elements of the array are initialized with a1,  a2, …, am and the other n - m elements are, if possible, value-initialized (see below for the explanation of the term)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &gt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the compiler will issue an error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"comment\">/*(this is the case when n isn&#x27;t specified at all like int a[] = &#123;1, 2, 3&#125;;) */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the size of the array (n) is assumed to be equal to m, so int a[] = &#123;1, 2, 3&#125;; is equivalent to int a[3] = &#123;1, 2, 3&#125;;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>聚合变量最大的特点可以做<strong>聚合初始化</strong>，除了基本的列表初始化规则，聚合初始化还体现在可以递归初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i1;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Y</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"keyword\">float</span> f; </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> d;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>&#123;&#125;      </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Z</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"built_in\">Z</span>(<span class=\"keyword\">char</span> a1) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y y = &#123;<span class=\"string\">&#x27;a&#x27;</span>, &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;, &#123;<span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><br><code>y.x</code>也被初始化了。如果对Z用递归聚合初始化，例如<code>Z z = &#123;&#39;a&#39;, &#123;&#39;b&#39;&#125;&#125;</code>，编译器就会报错。因为Z不是聚合类型，编译器会去找对应的构造函数，显然Z没定义这样的构造函数。<br>具体介绍可以参考<a href=\"https://en.cppreference.com/w/cpp/language/aggregate_initialization\">Aggregate initialization</a>。</p>\n<h1 id=\"什么是POD变量\"><a href=\"#什么是POD变量\" class=\"headerlink\" title=\"什么是POD变量\"></a>什么是POD变量</h1><p>POD = Plain Old Data，可见这是一种兼容型比较好的形态。甚至可以导出与其他语言共享此类变量定义。</p>\n<blockquote>\n<p><strong>C++03定义</strong><br>A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.</p>\n<p>C++11定义变得非常优雅<br><strong>A POD struct is a non-union class that is both a trivial class and a standard-layout class</strong>, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>总而言之：<br>POD类型是一种特殊的聚合类型，一个POD类型为：</p>\n<ul>\n<li>标量类型。</li>\n<li>满足以下条件的自定义类型：<ul>\n<li>C++11之前：<ul>\n<li>聚合类型。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n<li>没有引用类型的非静态成员变量。</li>\n<li>没有自定义的构造函数或析构函数。</li>\n</ul>\n</li>\n<li>C++11之后：<ul>\n<li>是平凡类。</li>\n<li>是标准布局类。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>POD类型的数组。</li>\n</ul>\n<h1 id=\"聚合类型或是POD变量有什么好处？\"><a href=\"#聚合类型或是POD变量有什么好处？\" class=\"headerlink\" title=\"聚合类型或是POD变量有什么好处？\"></a>聚合类型或是POD变量有什么好处？</h1><p>聚合类最大的特点就是可以采用聚合初始化。<br>POD的特点更为实用一些</p>\n<blockquote>\n<p><strong>POD的用途</strong><br>平凡类的用途：</p>\n<ul>\n<li>平凡类的对象可以与字节流之间安全转换，即：<ul>\n<li>若要将对象转为字节流，直接取其地址即可。</li>\n<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>\n<li>直接通过复制字节的方式复制对象。</li>\n</ul>\n</li>\n<li>安全的静态初始化。<ul>\n<li>C++11的thread_local变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的__thread只能使用POD类型。</li>\n</ul>\n</li>\n</ul>\n<p><strong>标准布局类的用途：</strong><br>跨进程、跨语言使用。</p>\n</blockquote>\n<h1 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h1><h2 id=\"value-initialization\"><a href=\"#value-initialization\" class=\"headerlink\" title=\"value initialization\"></a>value initialization</h2><ul>\n<li>对于普通类型变量(bool, int, char, double, pointers, etc.)<br>it means it is initialized with 0 for that type (false for bool, 0.0 for double, etc.). </li>\n<li>对于class类型<ul>\n<li>如果有自定义构造函数，则调用自定义构造函数</li>\n<li>如果没有自定一构造函数，则调用默认构造函数</li>\n<li>如果没有对应的构造函数，则报错</li>\n</ul>\n</li>\n</ul>\n<p>举例<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span>) &#123;&#125; <span class=\"comment\">//no default constructor</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">B</span>() &#123;&#125; <span class=\"comment\">//default constructor available</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  A a1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>), <span class=\"built_in\">A</span>(<span class=\"number\">1</span>), <span class=\"built_in\">A</span>(<span class=\"number\">14</span>)&#125;; <span class=\"comment\">//OK n == m</span></span><br><span class=\"line\">  A a2[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>)&#125;; <span class=\"comment\">//ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]</span></span><br><span class=\"line\">  B b1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">B</span>()&#125;; <span class=\"comment\">//OK b1[1] and b1[2] are value initialized, in this case with the default-ctor</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array1[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//All elements are initialized with 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array2[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">//Attention: only the first element is 1, the rest are 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> Array3[<span class=\"number\">1000</span>] = &#123;&#125;; <span class=\"comment\">//the braces can be empty too. All elements initialized with false</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array4[<span class=\"number\">1000</span>]; <span class=\"comment\">//no initializer. This is different from an empty &#123;&#125; initializer in that</span></span><br><span class=\"line\">  <span class=\"comment\">//the elements in this case are not value-initialized, but have indeterminate values </span></span><br><span class=\"line\">  <span class=\"comment\">//(unless, of course, Array4 is a global array)</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> array[<span class=\"number\">2</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;; <span class=\"comment\">//ERROR, too many initializers</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>大括号中个数不足的，用value initialization补足。这就是<code>A a = &#123;1&#125;;</code>或者<code>A a = &#123;&#125;</code>的含义。大括号中个数超过声明的个数的，则编译报错。</p>\n<h2 id=\"brace-or-equal-initializers\"><a href=\"#brace-or-equal-initializers\" class=\"headerlink\" title=\"brace-or-equal-initializers\"></a>brace-or-equal-initializers</h2><p>类成员的一种初始化方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"keyword\">int</span>)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b &#123;<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    B c &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">    B d = &#123;<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copy-assignment-operator\"><a href=\"#copy-assignment-operator\" class=\"headerlink\" title=\"copy-assignment operator\"></a>copy-assignment operator</h2><p>拷贝赋值方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\">A <span class=\"title\">A</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">const</span> &amp;) &#123;&#125;</span><br><span class=\"line\">    A&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> A&amp;a) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    A b = a; <span class=\"comment\">// 这里调用的是拷贝构造函数</span></span><br><span class=\"line\">    A c;</span><br><span class=\"line\">    c = a; <span class=\"comment\">// 这里才会调用拷贝复制函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"trial-stuff\"><a href=\"#trial-stuff\" class=\"headerlink\" title=\"trial stuff\"></a>trial stuff</h2><h3 id=\"trivial-copyable\"><a href=\"#trivial-copyable\" class=\"headerlink\" title=\"trivial copyable\"></a>trivial copyable</h3><p>参考<a href=\"https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable\">C++ named requirements: TriviallyCopyable</a></p>\n<blockquote>\n<p>The following types are collectively called trivially copyable types:</p>\n<ul>\n<li>Scalar types</li>\n<li>Trivially copyable classes, i.e. classes satisfying following requirements:<ul>\n<li>At least one copy constructor, move constructor, copy assignment operator, or move assignment operator is eligible</li>\n<li>Every eligible copy constructor (if any) is trivial</li>\n<li>Every eligible move constructor (if any) is trivial</li>\n<li>Every eligible copy assignment operator (if any) is trivial</li>\n<li>Every eligible move assignment operator (if any) is trivial</li>\n<li>Has a trivial non-deleted destructor</li>\n</ul>\n</li>\n<li>Arrays of TriviallyCopyable objects</li>\n</ul>\n<p>This implies that a trivially copyable class has no virtual functions or virtual base classes.</p>\n</blockquote>\n<p>通过模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivially_copyable\">std::is_trivially_copyable</a>可以检验一个类是否trivially copyable。</p>\n<h3 id=\"trivial-constructor-destructor\"><a href=\"#trivial-constructor-destructor\" class=\"headerlink\" title=\"trivial constructor/destructor\"></a>trivial constructor/destructor</h3><ul>\n<li>编译器定义的构造/析构函数</li>\n<li>用<code>=default</code>定义的构造析构函数<h3 id=\"trivial-class\"><a href=\"#trivial-class\" class=\"headerlink\" title=\"trivial class\"></a>trivial class</h3>The standard defines a trivial class as follows:</li>\n</ul>\n<p>A trivially copyable class is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n<p>A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n<p>[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes. ]<br>另外trivial class是递归的，即trivial class不能有非trivial class的非static成员。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivial\">std::is_trivial</a>来测试</p>\n<h2 id=\"standard-layout\"><a href=\"#standard-layout\" class=\"headerlink\" title=\"standard layout\"></a>standard layout</h2><p>A standard-layout class is a class that:</p>\n<ul>\n<li><p>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p>\n</li>\n<li><p>has no virtual functions (10.3) and no virtual base classes (10.1),</p>\n</li>\n<li><p>has the same access control (Clause 11) for all non-static data members,</p>\n</li>\n<li><p>has no non-standard-layout base classes,</p>\n</li>\n<li><p>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, (要么终点类没有非静态成员，并且只有一个基类有非静态成员；要么没有基类有非静态成员)，and</p>\n</li>\n<li><p>has no base classes of the same type as the first non-static data member.</p>\n</li>\n</ul>\n<p>A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.</p>\n<p>A standard-layout union is a standard-layout class defined with the class-key union.</p>\n<p>[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.]</p>\n<p>标准内存分布，确保对象内存和C语言的结构体内存分布完全一致。使得POD变量具备了C兼容性。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_standard_layout\">std::is_standard_layout</a>可以测试</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>用<a href=\"https://en.cppreference.com/w/cpp/types/is_pod\">std::is_pod</a>来测试你的类吧。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">What are Aggregates and PODs and how/why are they special?</a></li>\n<li><a href=\"https://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/\">C++对象模型（三）POD</a></li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/12/obsidian_posts/setcap%20vs.%20LD_PRELOAD/",
            "url": "https://zhougy0717.github.io/2021/09/12/obsidian_posts/setcap%20vs.%20LD_PRELOAD/",
            "title": "setcap vs. LD_PRELOAD",
            "date_published": "2021-09-12T06:29:34.553Z",
            "content_html": "<p>在Linux中，一个进程拉起另一个进程的流程大致如下：</p>\n<p><pre class=\"mermaid\">graph LR;\nF[parent process] --> A[start]\nA --fork--> B[child]\nA --> C[wait]\nB --exec--> D[new process]\nD --> E[end]\nC --> E</pre><br>最常见的就是通过shell终端执行命令。此场景下，/bin/bash就是这个parent process，而要执行的那个命令就是new process。<br>Linux有一些特性，可以使得创建出的进程比拉起的进程权限高。例如可执行文件配置了set-user-ID位，则拉起的进程就是root权限，而其父进程有可能是普通用户权限。如果可执行文件配置了file capability，则创建出的进程就具备了某些capability，如果父进程没有这些capability，则这也是一种权限放大的场景。<br>当发生这种权限放大的场景时，Linux的安全特性要求，此时子进程中的某些敏感环境变量会被清空，例如：LD_PRELOAD,LD_LIBRARY_PATH。由于这些环境变量都是从父进程继承过来的，如果不清空，则表明会使用高权限级别执行这些环境变量指定的可执行代码。</p>\n<h1 id=\"LD-LIBRARY-PATH\"><a href=\"#LD-LIBRARY-PATH\" class=\"headerlink\" title=\"LD_LIBRARY_PATH\"></a>LD_LIBRARY_PATH</h1><p>参考文献[1]，ld.so搜索动态库的顺序如下：</p>\n<ol>\n<li>DT_PATH指定的库文件（deprecated）</li>\n<li>LD_LIBRARY_PATH指定的库文件</li>\n<li>DT_RUNPATH指定的库文件</li>\n<li>/etc/ld.so.cache这个二进制文件指定的库文件，该文件通过ldconfig命令生成</li>\n<li>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</li>\n</ol>\n<p>所以针对LD_LIBRARY_PATH，除了第二条的方法失效，其他的都可以用。</p>\n<h1 id=\"LD-PRELOAD\"><a href=\"#LD-PRELOAD\" class=\"headerlink\" title=\"LD_PRELOAD\"></a>LD_PRELOAD</h1><p>那针对LD_PRELOAD，是不是就没法用呢？其实也不是。<br>在没有setcap以及set-user-ID的情况下，如果ld.so需要预加载一个库文件，指定方法在文献[1]中同样有描述：</p>\n<ol>\n<li>The <code>LD_PRELOAD</code> environment variable.</li>\n<li>The <code>--preload</code> command-line option when invoking the dynamic linker directly.</li>\n<li>The <code>/etc/ld.so.preload</code> file.</li>\n</ol>\n<p>在secure-execution模式下，方法2和方法3均不受影响。方法1也仍然可以使用。但是需要一些特殊的设置，在[1]中也有描述。</p>\n<blockquote>\n<p>In secure-execution mode, <strong>preload pathnames containing slashes are ignored</strong>.  Furthermore, shared objects are preloaded <strong>only from the standard search directories</strong> and only if <strong>they have set-user-ID mode bit enabled</strong> (which is not typical).</p>\n</blockquote>\n<p>综上，需要3点配置：</p>\n<ul>\n<li>LD_PRELOAD环境变量指定的库文件不能包含斜线’/‘</li>\n<li>库文件只会从标准路径下加载。这里标准路径可以参考LD_LIBRARY_PATH中的描述。注意，此时ld.so只会搜索标准路径，不会搜索通过其他手段配置的路径（如上一节描述的）。</li>\n<li>库文件必须使能了set-user-id位</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>代码目录树：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ tree .</span><br><span class=\"line\">.</span><br><span class=\"line\">├── lib.c</span><br><span class=\"line\">├── libtest.so</span><br><span class=\"line\">├── main</span><br><span class=\"line\">├── main.c</span><br><span class=\"line\">├── test</span><br><span class=\"line\">└── test.c</span><br></pre></td></tr></table></figure><br>main.c生成main可执行程序，test.c生成test可执行程序，lib.c生成libtest.so。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">pid_t</span> pid = fork();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *envp[] = &#123;</span><br><span class=\"line\">                        <span class=\"string\">&quot;LD_PRELOAD=libtest.so&quot;</span>,</span><br><span class=\"line\">                        <span class=\"comment\">// &quot;LD_PRELOAD=./libtest.so&quot;,</span></span><br><span class=\"line\">                        <span class=\"literal\">NULL</span></span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *argv[] = &#123;</span><br><span class=\"line\">                        <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">                        <span class=\"literal\">NULL</span></span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> err = execve(<span class=\"string\">&quot;./test&quot;</span>, argv, envp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">                wait(&amp;status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *preload = getenv(<span class=\"string\">&quot;LD_PRELOAD&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;LD_PRELOAD = %s\\n&quot;</span>, preload);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> __<span class=\"title\">attribute__</span><span class=\"params\">((constructor))</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;m libtest.so loaded\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在test可执行程序是普通的二进制时，输出为<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">I&#x27;m libtest.so loaded</span><br><span class=\"line\">LD_PRELOAD = ./libtest.so</span><br></pre></td></tr></table></figure><br>当test配置了capability以后：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ sudo setcap cap_net_admin,cap_net_raw=eip ./test</span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>可见LD_PRELOAD指定libtest.so未被加载，且LD_PRELOAD环境变量被清空了。</p>\n<h2 id=\"LD-PRELOAD不含斜线\"><a href=\"#LD-PRELOAD不含斜线\" class=\"headerlink\" title=\"LD_PRELOAD不含斜线\"></a>LD_PRELOAD不含斜线</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure>\n<p>LD_PRELOAD仍然被清空了，但ld.so似乎尝试去加载libtest.so了，但是没找着。</p>\n<h2 id=\"将libtest-so放入标准路径\"><a href=\"#将libtest-so放入标准路径\" class=\"headerlink\" title=\"将libtest.so放入标准路径\"></a>将libtest.so放入标准路径</h2><p>如果没有配置set-user-id位：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>仍然提示找不到。如果设置了set-user-id位：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ sudo chmod a+s /usr/lib64/libtest.so </span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">I&#x27;m libtest.so loaded</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>在满足上一节提到的3个条件时，libteso.so就可以正常加载了。<br>看看如果放到/usr/lib下面会怎么样？<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ls /usr/lib/libtest.so -l</span><br><span class=\"line\">-rwsr-sr-x. 1 root root 8208 1月  24 19:48 /usr/lib/libtest.so</span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>看看还是一样找不到。可见在x64平台上，/usr/lib并非标准路径，而/usr/lib64以及/lib64才是。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://man7.org/linux/man-pages/man8/ld.so.8.html\">ld.so(8) — Linux manual page</a><br>[2] <a href=\"https://stackoverflow.com/questions/18058426/does-using-linux-capabilities-disables-ld-preload\">Stackoverflow - Does using linux capabilities disables LD_PRELOAD</a></p>\n",
            "tags": [
                "Linux",
                "capability",
                "LD_PRELOAD"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "url": "https://zhougy0717.github.io/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "title": "详解SELinux SID",
            "date_published": "2021-09-12T06:26:36.976Z",
            "content_html": "<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p>SID = Security Identifier (即Security ID)。其作用就是取代安全上下文，在权限匹配时，提升规则搜索速度，以及降低整个策略数据的空间复杂度，提升了整个SELinux特性的性能损耗。<br>例如一次权限匹配的函数调用原型如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_has_perm</span><span class=\"params\">(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t u32 requested, struct common_audit_data *auditdata)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>其中ssid, tsid就代表了源(source)SID和目的(target)SID。在最终的av(access vector)计算中，SID被转化为context。</p>\n<blockquote>\n<p>什么是context？<br>context，即安全上下文，是SELinux的核心概念。形如<code>user_u:role_r:type_t:s0-s1:c0,c1-c255</code>的就是context。其中user字段和role字段用于RBAC，type字段用于TEAC，后面的s0-s1,c1-c255用于mls/mcs。而所有的这些字段，都由策略编译工具生成了整数数据，在SELinux加载策略时一并加载到内存policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// context定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// context加载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">context_read_and_validate</span><span class=\"params\">(struct context *c,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     struct policydb *p,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     <span class=\"keyword\">void</span> *fp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    c-&gt;user = le32_to_cpu(buf[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    c-&gt;role = le32_to_cpu(buf[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    c-&gt;type = le32_to_cpu(buf[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>在真正的权限匹配时，SELinux通过SID获取到对应的context，再通过context中的type属性，所搜policydb中相应的hash表找到对应的map array，并获取对应某个权限的一个bit位，来得到权限判定结果。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 搜索sidtab获取SID对应的context，并用context数据结构来计算权限</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    scontext = sidtab_search(sidtab, ssid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    tcontext = sidtab_search(sidtab, tsid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    context_struct_compute_av(policydb, scontext, tcontext, tclass, avd,</span><br><span class=\"line\">\t\t\t\t  xperms);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过context的type字段从policydb中获取权限数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">context_struct_compute_av</span><span class=\"params\">(struct policydb *policydb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *scontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *tcontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   scontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    tattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   tcontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    ebitmap_for_each_positive_bit(sattr, snode, i) &#123;</span><br><span class=\"line\">        ebitmap_for_each_positive_bit(tattr, tnode, j) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (node = avtab_search_node(&amp;policydb-&gt;te_avtab,</span><br><span class=\"line\">                              &amp;avkey);</span><br><span class=\"line\">                 node;</span><br><span class=\"line\">                 node = avtab_search_node_next(node, avkey.specified)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Get and assign perm data</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"initial-SID\"><a href=\"#initial-SID\" class=\"headerlink\" title=\"initial SID\"></a>initial SID</h1><p>initial SID是一种比较特殊的SID。他在策略编译和SELinux启动中都扮演了非常重要的角色。通常在编译policy的时候，需要一些flask文件，例如Fedora refpolicy：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> ls refpolicy-master/policy/flask/</span></span><br><span class=\"line\">access_vectors   initial_sids     security_classes</span><br></pre></td></tr></table></figure>\n<p>其中initial_sids就指定了policy二进制中所有的initial SID。内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># FLASK</span><br><span class=\"line\"></span><br><span class=\"line\">#</span><br><span class=\"line\"># Define initial security identifiers</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\">sid kernel</span><br><span class=\"line\">sid security</span><br><span class=\"line\">sid unlabeled</span><br><span class=\"line\">sid fs</span><br><span class=\"line\">sid file</span><br><span class=\"line\">sid file_labels</span><br><span class=\"line\">sid init</span><br><span class=\"line\">sid any_socket</span><br><span class=\"line\">sid port</span><br><span class=\"line\">sid netif</span><br><span class=\"line\">sid netmsg</span><br><span class=\"line\">sid node</span><br><span class=\"line\">sid igmp_packet</span><br><span class=\"line\">sid icmp_socket</span><br><span class=\"line\">sid tcp_socket</span><br><span class=\"line\">sid sysctl_modprobe</span><br><span class=\"line\">sid sysctl</span><br><span class=\"line\">sid sysctl_fs</span><br><span class=\"line\">sid sysctl_kernel</span><br><span class=\"line\">sid sysctl_net</span><br><span class=\"line\">sid sysctl_net_unix</span><br><span class=\"line\">sid sysctl_vm</span><br><span class=\"line\">sid sysctl_dev</span><br><span class=\"line\">sid kmod</span><br><span class=\"line\">sid policy</span><br><span class=\"line\">sid scmp_packet</span><br><span class=\"line\">sid devnull</span><br><span class=\"line\"></span><br><span class=\"line\"># FLASK</span><br></pre></td></tr></table></figure>\n<p>参考《Building The Sample Policy》中的介绍，这些flask文件的内容将被写到最终的policy二进制文件中（即policy.conf),如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notebook-tools/build-sepolicy -o policy.conf -d ../../flask-files</span><br></pre></td></tr></table></figure><br>build-sepolicy是一个python的示例程序，他是这样处理flask文件的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    f = Flask()</span><br><span class=\"line\">    f.parseSids(flask_dir + <span class=\"string\">&quot;/initial_sids&quot;</span>)</span><br><span class=\"line\">    f.parseClasses(flask_dir + <span class=\"string\">&quot;/security_classes&quot;</span>)</span><br><span class=\"line\">    f.parseVectors(flask_dir + <span class=\"string\">&quot;/access_vectors&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Open the file and then create the requested policy source file</span></span><br><span class=\"line\">    of = <span class=\"built_in\">open</span>(outf, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> include == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicyHdr(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output header file&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> cil == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL policy&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> class_perm == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilClassPerms(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL class permission sets&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> sids == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilInitialSIDS(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL initial SIDs&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output Kernel Language policy&quot;</span>)</span><br><span class=\"line\">    of.close()</span><br></pre></td></tr></table></figure><br>可见这些文件的内容，被写入到一个Flask对象中，而该对象的内容最终会被写入策略二进制数据。在后续的策略编译中，这些文件会被checkpolicy来处理。</p>\n<blockquote>\n<p><strong>initial SID的作用</strong><br><em>from “SELinux by Example: Using Security Enhanced Linux”</em><br>Some objects are labeled via an initial SID early in system initialization, <strong><em>even before the policy is loaded</em></strong>. This labeling behavior is needed, for example, to label objects such as the kernel security server and the root filesystem, which are present in the system before the first policy load. <strong><em>When the policy is eventually loaded, the initial SIDs are then associated with the appropriate security context</em></strong>.<br><strong><em>Initial SIDs are also used to prevent objects from having a missing or invalid security context, which would make it impossible for SELinux to correctly enforce access</em></strong>. Instead, SELinux associates these objects with the special unlabeled initial SID. The unlabeled initial SID should have a security context that allows only limited access, thereby preventing inappropriate access until the objects can be relabeled by the administrator or destroyed.<br>Invalid security contexts most commonly result from loading a new policy that removes users, roles, or types, or changes role or type authorizations. In this situation, the <strong><em>SIDs representing security contexts that use these invalid names or associations will become invalid and are mapped to the unlabeled SID at policy load</em></strong>. Invalid security contexts can also arise when transferring object instances between systems (for example, using removable media). Further, if the objects are created on a non-SELinux system, they will have no associated security context. Regardless of whether the security context is invalid or missing, SELinux will use the unlabeled initial SID on first access to the object as the security context.</p>\n</blockquote>\n<p>总结一下，一共有这几点：</p>\n<ul>\n<li>系统启动时，policy尚未加载，也就是所有的context还没被抽象成SID，存储在内存中的policydb里。allow规则也还没加载，这时候，为了保证代码归一，所以需要这些unlabeled SID，在SELinux启动流程中，再具体介绍。</li>\n<li>当系统策略变化时，有些role，user或type被删除，导致一些安全上下文失效了，此时这些安全上下文，在策略加载时，会被映射到这些initial SID上。（这里还没找到具体的代码位置）</li>\n</ul>\n<h2 id=\"启动时的使用\"><a href=\"#启动时的使用\" class=\"headerlink\" title=\"启动时的使用\"></a>启动时的使用</h2><p>init进程在加载策略之前，首先将SELinux的enforcing模式打开。其打开的方式就是往selinuxfs的enforce文件写1。注意此时策略未加载，初始化也未完成。所以策略判断直接取allow。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!state-&gt;initialized)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> allow;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">allow:</span><br><span class=\"line\">\tavd-&gt;allowed = <span class=\"number\">0xffffffff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但由于用户态的入口是一致的，即启动完成后，用户态可以写同样的enforce文件完成SELinux状态的切换，所以为了判断此时用户态进程是否具有设置的权限，在enforce文件的入口处，对用户态进程权限进行了判定：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length = avc_has_perm(&amp;selinux_state,</span><br><span class=\"line\">                  current_sid(), SECINITSID_SECURITY,</span><br><span class=\"line\">                  SECCLASS_SECURITY, SECURITY__SETENFORCE,</span><br><span class=\"line\">                  <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure><br>这里就用到了initial SID - <code>SECINITSID_SECURITY</code>。这里其实已经可以使用selinuxfs的inode.i_security.sid，但由于selinuxfs未通过系统的file open调用，所以无法使用到inode下的SID标签。</p>\n<h2 id=\"系统标签无效时\"><a href=\"#系统标签无效时\" class=\"headerlink\" title=\"系统标签无效时\"></a>系统标签无效时</h2><p>以socket bind时，对IP地址进行权限判断为例。该权限判断流程大致如下：</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"selinux_socket_bind\"]\nA --> B[\"sock_has_perm(SOCKET__BIND)\"]\nB --> C[\"get nodecon sid by sel_netnode_sid\"]\nC --> D[\"av_has_perm\"]</pre><br><code>security_node_sid</code>会从<code>policydb-&gt;ocontexts[OCON_NODE]</code>中搜索policydb中关于该IP地址的nodecon定义，如果找不着，说明此IP相关的nodecon无效（未定义），则会走默认的initial SID。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c-&gt;sid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        rc = sidtab_context_to_sid(sidtab,</span><br><span class=\"line\">                       &amp;c-&gt;context[<span class=\"number\">0</span>],</span><br><span class=\"line\">                       &amp;c-&gt;sid[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rc)</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *out_sid = c-&gt;sid[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    *out_sid = SECINITSID_NODE; <span class=\"comment\">// &lt;===== intial SID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"其他SID\"><a href=\"#其他SID\" class=\"headerlink\" title=\"其他SID\"></a>其他SID</h1><p>除了initial SID由内核直接加载生成，其他的SID则由对应的打标签流程生成。例如：文件的SID则由setfiles/restorecon工具打入文件系统的扩展属性上，socket则由socket系统调用创建时生成。<br>以socket bind为例，因为比较简单。当socket bind系统调用被执行时，一个socket object被绑定到一个node上。而此时该node的SID才被写入policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sel_netnode_sid</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, u16 family, u32 *sid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sel_netnode</span> *<span class=\"title\">node</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_read_lock();</span><br><span class=\"line\">\tnode = sel_netnode_find(addr, family);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t*sid = node-&gt;nsec.sid;</span><br><span class=\"line\">\t\trcu_read_unlock();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trcu_read_unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sel_netnode_sid_slow(addr, family, sid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>sel_netnode_sid_slow</code>调用<code>security_node_sid</code>,并最终调用<code>sidtab_context_to_sid</code>将相关的SID以及对应的context数据结构插入到表中。</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"security_node_sid\"]\nA --> B[\"search policydb->ocontexts[OCON_NODE]\"]\nB --> C{\"find?\"}\nC --> |N| B\nC --> |Y| D[\"sidtab_context_to_sid(context，&sid)\"]\nD --> E(\"end\")\nC --> |Never find| F[\"set an initial SID\"]\nF --> E</pre></p>\n<ul>\n<li><code>security_node_sid</code>使用传入的IP地址在policydb中匹配查找context，如果找到则进行下一步，匹配或生成SID，找不到，则直接使用initial SID。</li>\n<li><code>sidtab_context_to_sid</code>将context写入sidtab，并获取返回的SID记入policydb中，后续通过context找SID，直接匹配<code>policydb-&gt;ocontexts[OCON_NODE];</code>即可。对于SID本身的生成也很简单，就是一个单向增长的整形数字，在<code>sidtab_context_to_sid</code>中。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sid = sidtab_search_context(s, context);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sid)</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> unlock_out;</span><br><span class=\"line\">...</span><br><span class=\"line\">sid = s-&gt;next_sid++;</span><br><span class=\"line\">..</span><br><span class=\"line\">ret = sidtab_insert(s, sid, context);</span><br></pre></td></tr></table></figure>\n先尝试在sidtab中查找，如果找不到就加一条记录，并为sid赋值。<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>SID在整个SELinux子系统中的作用就是提升匹配性能（从安全上下文的字符串匹配，降低到整数匹配）,所以在整个SELinux子系统生命周期内，SID总是与安全上下文（context）一一对应的。在一次权限匹配过程中，SID的使用如下：<br><img src=\"/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/948A5192-E302-40F3-9A2D-D3C2D5B2FF75.png\" alt=\"7fe0cdf2b84938b1e0610fe99bd3c917\"><br>context和SID的定义分别为：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u32 sid;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1>没有一个专门的工具用来转换SID与context。但libselinux提供了相应的接口，参考<a href=\"https://linux.die.net/man/3/sidget\">sidget(3) - Linux man page</a>。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_context_to_sid</span><span class=\"params\">(<span class=\"keyword\">security_context_t</span> ctx, <span class=\"keyword\">security_id_t</span> *sid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_sid_to_context</span><span class=\"params\">(<span class=\"keyword\">security_id_t</span> sid, <span class=\"keyword\">security_context_t</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"seinfo\"><a href=\"#seinfo\" class=\"headerlink\" title=\"seinfo\"></a>seinfo</h2></li>\n</ul>\n<ol>\n<li>打印所有initial SID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --initialsid</span><br><span class=\"line\"></span><br><span class=\"line\">Initial SIDs: 27</span><br><span class=\"line\">   any_socket</span><br><span class=\"line\">   devnull</span><br><span class=\"line\">   file</span><br><span class=\"line\">   file_labels</span><br><span class=\"line\">   fs</span><br><span class=\"line\">   icmp_socket</span><br><span class=\"line\">   igmp_packet</span><br><span class=\"line\">   init</span><br><span class=\"line\">   kernel</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>打印selinuxfs context<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --genfscon|grep selinux</span><br><span class=\"line\">   genfscon selinuxfs /  system_u:object_r:security_t:s0</span><br></pre></td></tr></table></figure>\n<h2 id=\"initial-contexts\"><a href=\"#initial-contexts\" class=\"headerlink\" title=\"initial_contexts\"></a>initial_contexts</h2>策略加载后，每个initial SID都有一个对应的context。这些context在各策略模块中定义。这些context在selinuxfs可以查看：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ sudo cat /sys/fs/selinux/initial_contexts/kernel</span><br><span class=\"line\">system_u:system_r:kernel_t:s0</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1></li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/fedora-selinux/selinux-policy\">Fedora refpolicy</a></li>\n<li>Frank Mayer, Karl MacMillan, David Caplan， July 27, 2006- “SELinux by Example: Using Security Enhanced Linux”</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook</a>“ Volume II, Building The Sample Policy</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook 4th Edition</a>“</li>\n</ul>\n",
            "tags": [
                "SELinux"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/09/09/obsidian_posts/RSS%20Everywhere/",
            "url": "https://zhougy0717.github.io/2021/09/09/obsidian_posts/RSS%20Everywhere/",
            "title": "RSS Everywhere",
            "date_published": "2021-09-08T23:31:18.755Z",
            "content_html": "<p>links:</p>\n<hr>\n<p>最近捣鼓群晖上的docker发现了一个很有意思的镜像<a href=\"https://registry.hub.docker.com/r/diygod/rsshub/\">diygod/rsshub - Docker Image | Docker Hub</a>，提倡所谓的“万物皆可 RSS”。<br>接触RSS始于Google Reader，后来被Google弃坑后，一直用Feedly。现在国内能订阅的源越来越少了。各家巨头都想构建封闭的生态，用户进来了就别出去。通过RSS抓取全文更是不可能。我想RSS诞生的初衷本就应该是打破互联网的壁垒，构建定制化的阅读体验，减少到处充斥的垃圾信息污染，回归阅读的本质。还好我认识了RSS Hub这个项目。<br>本文会引用我在操作时参考的网络链接，并分享我踩过的坑，以节省诸君的时间，提供更好的构建服务的体验。</p>\n<h1 id=\"Synology-Docker\"><a href=\"#Synology-Docker\" class=\"headerlink\" title=\"Synology + Docker\"></a>Synology + Docker</h1><p>我今年升级了群晖NAS到新款DS220+，基于x86芯片，性能足够强大，运行docker也不是问题。这其实一下降低了NAS的折腾门槛。像之前手动装optware的工作完全没必要了，dockerhub中的资源很丰富，社区也很活跃。网上推荐NAS docker玩法的帖子很多，不过也大同小异。可以参考这篇：<a href=\"https://post.smzdm.com/p/avwd6ngn/\">如何优雅的使用群晖NAS？我的套件和Docker镜像推荐！</a>。</p>\n<p>除了官方应用moment，video station之类的，重点是文中推荐的docker镜像。我选择了这几个服务：</p>\n<ul>\n<li>aria2pro，ariang：<ul>\n<li>前者是下载工具，用于取代download station和transmission。不得不说这个镜像做得不错，以前自己整aria总是没法下磁链，或者超级不稳定，但用了这个就没问题了。配合手机端但<a href=\"https://play.google.com/store/apps/details?id=com.gianlu.aria2app\">Aria2App (open source) - Apps on Google Play</a>，效果美滋滋。</li>\n<li>如果没有客户端应用，后者提供了ariang的服务，用chrome做客户端，效果依然杠杠的。</li>\n</ul>\n</li>\n<li>rsshub：这就是本篇的主角，提供“RSS everywhere”的体验，配合衍生品chrome插件RSS radar，添加feed也变的毫无压力</li>\n<li>ttrss：即Tiny Tiny RSS，作为RSS Hub的客户端。因为毕竟我们订阅很多国内资源，用feedly或者inoreader还是有些水土不服。不如既然自建，就全部自己搞定了。</li>\n<li>syncthing：用于替代cloud station。配合Obsidian，终于可以摆脱臃肿的大象了。syncthing本身在同步这件事情上比cloud station还是要强一些。配合手机使用，完全可以放弃安卓上的DS cloud。毕竟那位已经3年没更新了。</li>\n<li>wallabag：稍后阅读服务，Instapaper的替代者。</li>\n</ul>\n<p>在真正安装之前，对docker做个简单的介绍。其实真的非常简单。我也是自行摸索的，一开始也并没有去找教程。但针对一些复杂的docker，还是需要一些指导。</p>\n<h2 id=\"Synology的docker界面\"><a href=\"#Synology的docker界面\" class=\"headerlink\" title=\"Synology的docker界面\"></a>Synology的docker界面</h2><p><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210912115716.png\" alt><br>总览就不说了，就是个dashboard。</p>\n<ul>\n<li>注册表默认提供了docker hub源上的docker镜像搜索。搜索到你想要的docker，双击就可以下载</li>\n<li>下载完，docker镜像会出现在映像页面。这时候选中你心仪的docker，再点启动就好了。</li>\n<li>启动之后可以啥也不用设置，一路下一步就可以。通常还可以做一些配置，包括：<ul>\n<li>通常会设置以下三处，包括：<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210910215359.png\" alt><ul>\n<li>存储空间：方便docker与宿主机进行文件交换</li>\n<li>端口映射：选择好本地端口，我们通过电脑连接时，使用地就是该端口。<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210910215623.png\" alt></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最后点击启动，就可以在容器页面看到启动的容器，双击容器，可以看到一些基本信息。这里比较有用的一个是容器的本地端口（方便电脑手机端进行连接），日志（可以调试），终端（可以访问docker环境，最好还是用docker exec命令行来连接对应的容器。群晖页面里的终端界面的按键映射似乎不完整）。还有一个比较重要的信息就是环境变量，如下，右侧可以看到对应的值。经常有一些docker镜像通过环境变量来进行配置。所以环境变量有时很有用。<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210910220107.png\" alt></li>\n</ul>\n<p>群晖的docker应用实际上就是docker命令行工具的一个封装，提供了易用性。有时候配合命令行食用更佳。</p>\n<h2 id=\"绑定域名-https\"><a href=\"#绑定域名-https\" class=\"headerlink\" title=\"绑定域名+https\"></a>绑定域名+https</h2><p>群晖贴心的为用户提供了默认的DDNS域名，即synology.me。配合用户注册的二级域名外加群晖内置的证书，可以实现外网https访问NAS。并且群晖还提供了方便的反向代理工具，如下图：<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210910222353.png\" alt><br>唯一的缺点就是，没有三级域名来替代端口绑定。也就是说docker里刚才设置了一个端口，那个端口用来提供http服务，然后反向代理不得不使用另外一个端口来提供https服务，给外网连接时使用。那么一个服务就得消耗两个端口，还得废脑细胞记住。《<a href=\"https://post.smzdm.com/p/avwd6ngn/\">如何优雅的使用群晖NAS？我的套件和Docker镜像推荐！</a>》中推荐了<a href=\"https://hub.docker.com/r/linuxserver/heimdall\">linuxserver/heimdall</a>镜像，可以实现自建服务的导航页，不过我是没成功跑起来。留作以后再调试吧。</p>\n<p>另一个曲线救国的方法就是，申请一个域名，然后使用那个域名的二级域名来绑定相应的服务就好了。1块钱包邮，买不了吃亏，先用一年再说。而且证书是免费申请的，针对每个二级域名申请好证书，再下载后导入NAS即可，非常方便。可以参考这个帖子，《<a href=\"https://post.smzdm.com/p/a3g7g39k/\">45元购买腾讯云十年白金域名，外网访问黑群晖，链接加上小绿锁<em>NAS存储</em>什么值得买</a>》。之后，外网连接就可以告别不安全告警，从此拥有小绿锁了。</p>\n<h2 id=\"内网域名-https\"><a href=\"#内网域名-https\" class=\"headerlink\" title=\"内网域名+https\"></a>内网域名+https</h2><p>这个就要看网络布局了，如果是比较简单的单体网络，如下：</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[入户电信光猫] --> B[\"终端1（电脑）\"]\n    A --> C[\"终端2（手机1）\"]\n    A --> D[\"群晖NAS\"]</pre><br>那么，我们只要配置NAS上的DNS服务器，将我们的域名映射到一个局域网地址即可。然后，局域网下的节点先访问NAS的DNS服务器，获取针对我们设置的域名的解析得到的IP地址。<br>如果不幸的是，你家装修的时候，整了个和我一样的网络布局，那就凉凉了。</p>\n<p><pre class=\"mermaid\">graph TD;\n    A[\"入户电信光猫\"] --> B[\"终端1（电脑）\"]\n    A --> C[\"子路由\"]\n    C --> D[\"群晖NAS\"]\n    C --> E[\"终端2（手机1）\"]</pre><br>当手机在子路由的局域网下，可以通过群晖DNS服务器，解决域名与局域网地址映射的问题，但当手机在上一级但局域网中时，就没办法解决域名解析问题了。由于NAT回流，在该局域网下就没法访问我们但域名了。这就导致一些需要指定域名但服务没法用了。<br>增加记录的方法和DNS解析的地方一样，增加A记录就可以了，将域名和局域网IP地址绑定。</p>\n<h1 id=\"RSS-Hub\"><a href=\"#RSS-Hub\" class=\"headerlink\" title=\"RSS Hub\"></a>RSS Hub</h1><p>RSS Hub的安装还是很简单的，一键式安装即可。我使用的是这个镜像<a href=\"https://registry.hub.docker.com/r/diygod/rsshub/\">diygod/rsshub </a>。RSS Hub主页还提供了现有的路由列表<a href=\"https://docs.rsshub.app/\">介绍 | RSSHub</a>。这个列表是实时刷新的，而且本身就可以成为一个RSS源，一旦有人提供了新的路由，你就可以接收到推送。这个列表里还有很多不可描述的东西，宅男福音啊。RSS Hub主页还提供了部署指南<a href=\"https://docs.rsshub.app/install/#pei-zhi-dai-li-pei-zhi\">部署 | RSSHub</a>。里面有一些配置项可能会是有用的，例如：<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210911063409.png\" alt><br>代理选项可能在订阅被墙挡掉的feed时是有用的，不过我没有尝试。其实一键式安装已经很不错了，需要折腾的时候可以再回过头来看这里。</p>\n<h1 id=\"TTRSS\"><a href=\"#TTRSS\" class=\"headerlink\" title=\"TTRSS\"></a>TTRSS</h1><p>有了RSS Hub之后，就可以用你的RSS阅读器进行订阅了，RSS Hub提供的源地址通常是这样的，<code>https://[你的域名]/[路由名]</code>，如果你的NAS支持https访问的话。现在几家比较知名的RSS订阅网站，例如feedly，inoreader，the old reader等等，都是国外的服务，访问速度慢不说，这些网站会不会被墙干扰，以至于访问不到你的NAS也不好说。手机上，电脑上还有不少可以直接订阅feed的软件，也就是真正的RSS阅读器。这些软件订阅的时候直接通过你的终端网址访问NAS服务，不会存在墙的问题，但因为缺少SaaS，影响了用户粘性，比如没法多端同步，阅读记录，笔记啥的。所以最后我选择的方案是，直接群晖上安装Tiny Tiny RSS服务。因为有docker，这也是一键式的哦。以前都不敢想。</p>\n<p>用的是这个源<a href=\"https://ttrss.henry.wang/#about\">🐋 Awesome TTRSS | 🐋 Awesome TTRSS</a>。这个是TTRSS主仓的下游fork仓，针对国内的使用情况做了一些适配，使用起来毫无压力。</p>\n<p>这里有个小技巧，对于docker小白的我，第一次习得。因为要一次性安装好几个依赖服务，所以要使用docker-compose。当然仓库主页已经提供了<a href=\"https://github.com/HenryQW/Awesome-TTRSS/blob/main/docker-compose.yml\">docker-compose.yml的样例</a>，最简单的就是copy过来，直接使用<code>docker-compose up -d</code>命令即可，有需要再配置。<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210911064537.png\" alt><br>有两个配置，需要关注一下：</p>\n<ul>\n<li>SELF_URL_PATH：需要配置成TTRSS服务的路径，假如不匹配，访问时会报错。例你将这个选项配置成域名，然后在家里尝试用局域网地址访问，那么TTRSS就会告警，说域名URL不匹配</li>\n<li>ALLOW_PORTS：配置成你设置的本地端口。这里有个问题，当时搜索也花了蛮久，参考<a href=\"https://github.com/HenryQW/Awesome-TTRSS/issues/184\">[BUG] ttrss 禁止非80和443端口feed更新，导致不能订阅自建huginn、rsshub的问题 · Issue #184 · HenryQW/Awesome-TTRSS</a>。大意是，因为上游TTRSS主仓因为安全风险审查，关闭了非80和443端口的订阅，导致无法使用非80和443端口。但由于电信封锁，关闭了所有个人但网络服务，所有跑在80和443端口下的网络服务必须备案，并且可能需要走商用宽带。违法的事儿咱们不能干，但好在社区已经通过ALLOW_PORTS环境变量开了这个口子，解决了这个问题。当然风险是要个人承担了。这也是我们为什么要用国内定制镜像的原因了，毕竟国情不同嘛。</li>\n<li>ENABLE_PLUGINS：配置系统插件。插件配置里面有下面这个选项，这意味着，需要在拉起容器的时候，做一些配置，也就是配置这个环境变量。如果针对wallabag_v2这个插件，那么如此定义就好了<code>ENABLE_PLUGINS=wallabag</code>。如果还有其他的插件，用逗号分割，例如<code>ENABLE_PLUGINS=wallabag,api_newsplus</code>。</li>\n</ul>\n<p><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210911081841.png\" alt></p>\n<p>和RSS Hub配套的RSS radar插件，添加源到TTRSS服务的时候，会报错。参考<a href=\"https://community.tt-rss.org/t/using-chrome-rss-extension-to-add-feeds-to-ttrss/4715\">Using Chrome RSS Extension to add feeds to ttrss - Tiny Tiny RSS / Support - Tiny Tiny RSS: Community</a>。应该是RSS radar的bug，静待社区修复。在这之前，只能手动拷贝添加了。<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210911085210.png\" alt></p>\n<h2 id=\"添加订阅源\"><a href=\"#添加订阅源\" class=\"headerlink\" title=\"添加订阅源\"></a>添加订阅源</h2><p>配置很简单，为什么单独开个章节呢？因为在这里跌倒过。。<br><img src=\"/2021/09/09/obsidian_posts/RSS%20Everywhere/Pasted%20image%2020210911082241.png\" alt><br>这个路径应该如何填？是不是觉得这个问题很愚蠢？填RSS Hub中的源地址就好了。但请注意的是，这里不要填域名，填局域网地址就好了。因为通常我们的RSS Hub和TTRSS服务在同一个NAS上。如果要填域名，你得先解决NAT回流问题。所以填局域网地址是最方便的，因为也不牵扯外网访问，甚至RSS Hub服务不用在公网提供。我现在甚至认为填127.0.0.1或者类似services.rsshub:[port]也是可以的。不过实在没精力去尝试了。至少填局域网地址是可以用了。</p>\n<h1 id=\"Wallabag\"><a href=\"#Wallabag\" class=\"headerlink\" title=\"Wallabag\"></a>Wallabag</h1><p>自从有了电纸书，我发现稍后阅读还是很不错的选择。电纸书没有那么多让人分心的功能，对手写笔记支持也更好，而且久看眼睛也没那么疲劳，非常适合沉浸式阅读。恰好在少数派的《<a href=\"https://sspai.com/post/68516\">安全性和用户体验俱佳，这 20+ Android 开源软件值得一试 - 少数派</a>》博文中刚好看到推荐Wallabag，而群晖docker上也支持这个镜像，于是就下载来，准备替代Instapaper。毕竟那个是个国外服务，各种不稳定，不能连，抓取全文还经常出问题。现在大多只是当作网页保存工具，并不能很好地实现阅读功能。<br>使用的镜像是<a href=\"https://registry.hub.docker.com/r/wallabag/wallabag/\">wallabag/wallabag/</a>，基于docker-compose进行安装。过程很easy，记得设置<code>SYMFONY__ENV__DOMAIN_NAME</code>这个环境变量。如果配置的值与你连接使用的值不同，那么加载网页资源（图片，CSS风格）会出问题。</p>\n<p>另外TTRSS也贴心地支持了一键式导出文章至wallabag，不过需要在安装时指定，要设置这个环境变量为：<code>ENABLE_PLUGINS=wallabag_v2,auth_internal</code>。两个环境变量都要，否则TTRSS启动会失败。之后再在TTRSS偏好设置-&gt;插件-&gt;wallabag_v2页面中，设置好wallabag路径，用户密码，client ID和client secret即可。<br>TTRSS同时支持手动一键导出，和自动过滤导出，功能恰到好处。</p>\n<h1 id=\"我的工作流\"><a href=\"#我的工作流\" class=\"headerlink\" title=\"我的工作流\"></a>我的工作流</h1><p>这次折腾，我在群晖NAS上安装了：</p>\n<ul>\n<li>RSS Hub</li>\n<li>TTRSS</li>\n<li>wallabag</li>\n</ul>\n<p>在手机上安装了</p>\n<ul>\n<li>知微作为主力RSS reader：唯一不用付费的支持多账号的RSS reader，来自酷安社区。因为还需要feedly看一些墙外的源。</li>\n<li>FeedMe作为辅助RSS reader：各种贴心小功能，还支持电纸书</li>\n<li>wallabag：将文章分享至wallabag，用于继续在电纸书上进行沉浸式阅读</li>\n</ul>\n<p>Boox电子阅读器上安装了</p>\n<ul>\n<li>wallabag</li>\n<li>FeedMe</li>\n</ul>\n<p>Chrome上安装了</p>\n<ul>\n<li>RSS radar插件</li>\n<li>wallabag插件，用于收集文章作稍后精读，取代Instapaper</li>\n</ul>\n<p>平时手机或电脑Chrome中刷到的精品帖子共享给Wallabag作稍后阅读，可以电脑，手机或电纸书，全终端制霸。<br>由于RSS Hub的源远比之前的丰富的多，而且支持通过插件（mercury_fulltext）实现全文抓取。大部分时间可以避免在今日头条这样的充斥着垃圾信息的软件上浪费时间，而可以花更多的时间作沉浸式阅读。既能提高阅读体验，也能一定程度上缓解知识焦虑。</p>\n<blockquote>\n<p>所以推荐给所有人<br><strong>RSS everywhere！！！</strong></p>\n</blockquote>\n<p>RSS Hub本身支持订阅微信公众号，不过我没成功过。最近又发现另外一个开源项目将公众号转换成订阅源，叫做<a href=\"https://feeddd.org/feeds\">订阅源 · Feeddd</a>。目前已经支持不少公众号了，不过我感兴趣的几个都还没支持。感兴趣的朋友可以自行翻阅。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://docs.rsshub.app/install/#shou-dong-bu-shu-an-zhuang\">部署 | RSSHub</a></li>\n<li><a href=\"https://ttrss.henry.wang/#fever-api\">🐋 Awesome TTRSS | 🐋 Awesome TTRSS</a></li>\n<li><a href=\"https://post.smzdm.com/p/avwd6ngn/\">如何优雅的使用群晖NAS？我的套件和Docker镜像推荐！<em>NAS存储</em>什么值得买</a></li>\n<li><a href=\"https://github.com/HenryQW/Awesome-TTRSS/issues/184\">[BUG] ttrss 禁止非80和443端口feed更新，导致不能订阅自建huginn、rsshub的问题 · Issue #184 · HenryQW/Awesome-TTRSS</a></li>\n<li><a href=\"https://wp.gxnas.com/3483.html\">群晖给DNSPod（腾讯云国内）域名设置DDNS动态解析教程 - GXNAS博客</a></li>\n<li><a href=\"https://airwb.myds.me:9212/nas/41.html\">群晖NAS配置自带DDNS动态域名解析教程 - AIR的小窝</a></li>\n<li><a href=\"https://www.ioiox.com/archives/81.html\">docker compose 部署配置 Awesome TTRSS 教程 - 思有云 - IOIOX</a></li>\n<li><a href=\"https://community.tt-rss.org/t/using-chrome-rss-extension-to-add-feeds-to-ttrss/4715\">Using Chrome RSS Extension to add feeds to ttrss - Tiny Tiny RSS / Support - Tiny Tiny RSS: Community</a></li>\n<li><a href=\"https://github.com/HenryQW/Awesome-TTRSS/blob/main/docker-compose.yml\">Awesome-TTRSS/docker-compose.yml at main · HenryQW/Awesome-TTRSS</a></li>\n<li><a href=\"https://ttrss.henry.wang/zh/#rsshub\">🐋 Awesome TTRSS | 🐋 Awesome TTRSS</a></li>\n<li><a href=\"https://wiki-power.com/%E5%9F%BA%E4%BA%8ERSSHub%E6%90%AD%E5%BB%BARSS%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88%E7%BE%A4%E6%99%96Docker%EF%BC%89\">基于 RSSHub 搭建 RSS 生成器（群晖 Docker） | Power’s Wiki</a></li>\n<li><a href=\"https://blog.csdn.net/xiezuoyong/article/details/97272059\">Windows Sever 2016 创建DNS服务器并配置转发器及条件转发器_白昼的技术专栏-CSDN博客_dns转发器</a></li>\n<li><a href=\"https://post.smzdm.com/p/a3g7g39k/\">45元购买腾讯云十年白金域名，外网访问黑群晖，链接加上小绿锁<em>NAS存储</em>什么值得买</a></li>\n<li><a href=\"https://sspai.com/post/68516\">安全性和用户体验俱佳，这 20+ Android 开源软件值得一试 - 少数派</a></li>\n</ul>\n",
            "tags": [
                "群晖",
                "docker",
                "ttrss",
                "rsshub",
                "wallabag"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/08/30/obsidian_posts/%E6%88%91%E7%9A%84Code%20Review%E5%BF%83%E5%BE%97/",
            "url": "https://zhougy0717.github.io/2021/08/30/obsidian_posts/%E6%88%91%E7%9A%84Code%20Review%E5%BF%83%E5%BE%97/",
            "title": "Code Review",
            "date_published": "2021-08-30T14:57:57.572Z",
            "content_html": "<p>记得某一场合，一位领导说过，这次可信变革大概率会留下两样东西，一个是committer机制，另一个是代码白盒评价。而对于committer来说，code review就是其最重要的工作。</p>\n<p>第一次接触code review还是在前公司。那时候，代码合入要请人点“ship it”。后来工具切换成了gerrit，不过code review基本上还是流于形式，和朋友圈点赞差不多。有一些比较较真的老外会给出不少意见，同事间还颇有不忿。<br>”连拼写错误也要提！“<br>”烦死了，他根本就不懂！“<br>国内的开发同学基本上是磨不开面子的，反正代码又不是我维护，就给你点个赞有啥关系。</p>\n<p>真正第一次被评审代码是初入我司的时候。那时候与隔壁部门的同事一起参与一个操作系统项目。其中一位专家在评审代码的时候非常认真。每次提交MR，该专家在评审的时候都会提一堆问题。而且，这些问题点都或多或少确实存在问题，或者存在优化的可能。或修改，或解释，或补充注释。不过，最终我的MR也并没有合入，就切换到另外一个项目去了。经过这次刻骨铭心的合作，我也算是经历了一次真正的代码评审。后来，这位专家以及和他同组的小兄弟，在我司屡次的committer评选中，斩获了数次优秀committer的殊荣。很荣幸和他们能有过一段“不太愉快”的合作经历。在之后的项目里，我也被任命为committer，我希望把这份“不愉快”原汁原味地传递下去。</p>\n<p>code review，又叫代码评审，是代码开发很必要的一环，也是代码合入的最后一环。我们通常说，问题发现得越早，修复问题花费的成本月底。code review通常就是靠看看代码，就能发现一些潜在的问题，成本是非常低的。试想代码合入之后再发现问题，会引入多少overloading——沟通，重现，定界，抓log……</p>\n<p>code review既然这么好，那为什么总做不好呢？因为大家都是职场人，磨不开面儿。通常我们看到别人做的不好的地方，都不会当面戳破。关系好的，可能私底下会提醒一下，绝大多数情况就当作视而不见。所以committer课程通常第一句话都是教大家“要敢于说不”。话是不错，不过如果没有具体怎么做，就略显空洞，缺乏实操性。好在Google提供了一份详尽的code review指南（《<a href=\"https://github.com/google/eng-practices\">google/eng-practices: Google’s Engineering Practices documentation</a>》），从提交人和评审人的角度，给出了切实的做法，值得大家阅读。</p>\n<p>下面结合我自身的一些评审经验和Google指南，从committer的角度谈一谈我的心得。</p>\n<h1 id=\"如何提出评审意见？\"><a href=\"#如何提出评审意见？\" class=\"headerlink\" title=\"如何提出评审意见？\"></a>如何提出评审意见？</h1><p>尽量保持就事论事的态度，避免采用情绪化的表达方式，例如：</p>\n<blockquote>\n<p>不好的例子: “你为什么会在这里使用线程，这样做难道会有任何好处？”</p>\n<p>好的例子: “我并没有发现这个并发模块给程序带来了多少帮助，并且还增加了<strong>程序的复杂性，因此我认为这段代码最好是用单线程而不是多线程。</strong></p>\n</blockquote>\n<p>及时的评审，也可以减少负面评论带来的“挫败感”。<br>评审人如果能够主动地与提交人进行交流探讨，接受提交人的解释，也可以很大程度避免在MR中发生键盘侠现象。</p>\n<h1 id=\"问题太多怎么办？\"><a href=\"#问题太多怎么办？\" class=\"headerlink\" title=\"问题太多怎么办？\"></a>问题太多怎么办？</h1><p>问题太多应不应该提出来？会不会得罪提交人？会不会来得及修，影响交付进度？<br>Google给出的答案是“如果确定是问题，应当尽量提出”。</p>\n<p>首先需要明确的是哪些问题需要提出来。code review并不是为了追求完美。不应当苛责提交人写出完美代码。问题解决也要顾及成本。只要保证提交的代码对原有代码有了明显的提升，且能正常工作，就应该尽快合入。识别出的问题可以等待未来修复，只要确保有合适的跟踪方式即可。</p>\n<p>其次，如果确实有问题，就应当及时提出。如果我们能够及时响应评审请求，并且避免情绪化观点，通常不太会令提交人感觉不舒服。大部分情况下，很多问题都是一些编写风格的问题，一旦修改了，后续可能就不会再出现。那么后续的代码评审速度就会变快。</p>\n<h1 id=\"code-review应当何时进行\"><a href=\"#code-review应当何时进行\" class=\"headerlink\" title=\"code review应当何时进行\"></a>code review应当何时进行</h1><p>code review应当及时，因为通常提交人需要等待评审结果，再进行下一步开发。code review拖得比较就，如果涉及大面积改动，那么后续开发代码的merge成本就会很高。可能造成团队开发配合进度受影响。所以建议code review的时间不要超过一天。</p>\n<p>code review应当及时，但如果评审人正在处理需要集中注意力的事情时，例如正在开发代码时，就不应当被打断。因为一旦被打断，那么恢复现场的时间成本就会比较高。比较合理的着手处理code review的时间是处理事情的间歇，例如：每天开始工作之前，或者吃完午餐，或者从茶水间回来……</p>\n<h1 id=\"与提交人发生意见不一致怎么办？\"><a href=\"#与提交人发生意见不一致怎么办？\" class=\"headerlink\" title=\"与提交人发生意见不一致怎么办？\"></a>与提交人发生意见不一致怎么办？</h1><p>如果你坚信有问题，应当更积极地和提交人沟通。如果最终无法说服提交人，应当以提交人的意见为准，毕竟他才是代码owner。</p>\n<h1 id=\"与项目交付节点冲突怎么办？\"><a href=\"#与项目交付节点冲突怎么办？\" class=\"headerlink\" title=\"与项目交付节点冲突怎么办？\"></a>与项目交付节点冲突怎么办？</h1><p>除了确实会引起问题的代码需要修正之外，其他的改进意见是需要权衡的，如果无法在项目交付节点之内完成，或者完成会引入很大的交付风险，那应该选择规避项目风险，并留下跟踪项，以尽快解决或优化潜在问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总而言之，还是鼓励大家多参与code review。如果你不知道怎么做，可以阅读《<a href=\"https://github.com/google/eng-practices\">google/eng-practices: Google’s Engineering Practices documentation</a>》。另外，把code review当成一种交流，一次思想碰撞，而不是一次评审。不论你是提交人，还是评审人，take it easy！</p>\n",
            "tags": [
                "code review",
                "committer"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "url": "https://zhougy0717.github.io/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "title": "我眼中的单元测试",
            "date_published": "2021-08-29T09:11:09.223Z",
            "content_html": "<p>在最近的一些针对毕业生的面试中，我都会问一下他们对单元测试的理解。得到的答案无一例外都是不知道，不清楚，或是按字面意思的解释。其实，这也难怪。虽然我司可信变革对单元测试的要求越来越严苛，但真正能够理解并正确使用单元测试的同学也还是比较少的。至少在我周围是这样。</p>\n<p>想想这也正常，记得曾经刚毕业时，我根本都不知道单元测试这个名词。直到后来，以前任职的公司专门外聘了专业的机构，做了相关的培训之后，我算是认识了这个词。但彼时的理解，有点像现在我司推行的Fuzz测试。也就是，代码写好后，通过工具生成各种各样的参数，调用待测代码，从而保证代码输出质量。现在可能很多同学还是这样的思路。回过头来再审视当时的观点，不免觉得过于片面了。单元测试最重要的作用其实并不是保证代码质量，对代码质量的改进可以说是它的一个副作用。</p>\n<p>后来对于单元测试有了更深入的理解，是在阅读了下面三本书之后：</p>\n<ul>\n<li>《敏捷软件开发-原则模式与实践》 — Robert C. Martin</li>\n<li>《测试驱动开发》— Kent Beck</li>\n<li>《重构-改善既有代码的设计》— Martin Fowler</li>\n</ul>\n<p>值得一提的是这三本书的作者都是<a href=\"https://agilemanifesto.org/iso/zhchs/manifesto.html\">敏捷软件开发宣言</a>的发起者，也是<a href=\"https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B\">极限编程（Extreme Programming）</a>的践行者。书也都是高分经典著作，非常推荐给大家阅读。</p>\n<h1 id=\"单元测试提升代码信心\"><a href=\"#单元测试提升代码信心\" class=\"headerlink\" title=\"单元测试提升代码信心\"></a>单元测试提升代码信心</h1><p>现在谈谈我对单元测试的认识。在刚毕业的那一段时间，我的开发流程是这样的：</p>\n<ol>\n<li>先尝试设计，思考代码的执行流程，画一些时序图和流程图</li>\n<li>开始编程</li>\n<li>发现问题<br> 1). 如果是设计问题，导致开发不下去，那么回到步骤1<br> 2). 如果发现有更好的实现方法，那么擦掉已有的代码，回到步骤2</li>\n<li>所有问题都解决了，开发结束，开始写功能测试代码，验证特性代码。如果发现问题，重复步骤3</li>\n</ol>\n<p>这样完成整个开发循环，通常要至少半天时间。有时半天甚至一天，也没留下几行特性代码。整个开发过程不断地陷入编写和整体推翻的循环中。即便最终完成了前3步，准备开始第4步功能测试的时候，也是战战兢兢的。如果功能测试发现问题，又会陷入不停地调试，修改，推翻设计的死循环。我相信很多同学都遇到过这样的问题，并因此而感到困惑。到底该怎么摆脱这样效率低下的不断重复？</p>\n<p>现在就让我们诊断一下。通常我们做完前3步流程都会花比较久的时间。按照我的经验，一般一个新特性的开发，少则若干个小时，多则一天，甚至数天。整个流程来到第4步，我们才第一次开始测试我们的特性代码。之前顶多就是编译通过。运行测试的时候才会发现很多问题，进而反思我们的实现逻辑是否与我们开始设计时思考的逻辑相符合。编写代码，实际是将物理世界，翻译成用代码表述的，严谨的逻辑语言。而通常我们并不能一次性地完成这样的翻译。而且即便完成了，也无法避免引入bug。我们只有通过测试不断地完成负反馈，来验证我们的代码，找到错误，最终收敛成正确的代码逻辑，从而完成现实世界到代码逻辑的翻译工作。软件的迭代开发，就像控制系统一样，测试就如控制系统中的负反馈，如果没有负反馈的，控制系统是无法达到稳定收敛的。</p>\n<p>由于我们前面的步骤过于依赖功能测试，所以需要我们等很久，也就是功能代码编写完以后，才可以进行第一次测试。由于功能测试与特性逻辑相关，其运行花费的时间往往很久。用例要覆盖端到端功能，测试逻辑也比较复杂，写起来也比较耗时。这几点从本质上就会限制功能测试的运行次数。功能测试虽然能发现，且擅长发现代码逻辑问题，但开发和执行成本高，导致运行的次数不会太多。测试运行次数少，导致我们不知道我们自己写出来的特性逻辑是否真实地反映了我们的设计。那么这就会影响我们对代码的信心。所以，在进行第4步功能测试之前，我们总是战战兢兢的。</p>\n<p>我们等不及到所有特性代码开发完成再进行测试。因为通过昂贵的功能测试来试错发现问题，返工所花费的成本太高了。所以，我们需要一种针对小逻辑的（这样单case复杂度更低，有利于测试case之间的解耦），覆盖率高（通过mock依赖实现），运行快速的（方便不断运行）测试。于是，单元测试就应运而生了。为了编写单元测试，我们首先会把大的特性分解成小的模块；其次，通过编写单元测试，我们会不断地思考代码实现逻辑，这样就可以实时地发现逻辑问题，及时返工修正。而通常单元测试速度是很快的，这使得我们有条件可以完成下面的red-&gt;green-&gt;refactor的开发节奏。<br><img src=\"/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/Pasted%20image%2020210829201431.png\" alt><br>在每一次red-&gt;green的变化中，我们都会运行一次单元测试。而每次完成refactor后，我们又会使用单元测试，验证我们重构后的代码是否破坏了原有的逻辑。所以引入单元测试，并不是为了直接提升我们的代码质量，而是为了能让我们：</p>\n<ol>\n<li>切分原先整块的代码逻辑，变成一个个小的积木逻辑</li>\n<li>充分测试我们的特性代码逻辑，并且达到足够的覆盖率（越高越好）</li>\n<li>在重构时，有足够覆盖率的测试帮助我们验证逻辑是否遭到破坏</li>\n</ol>\n<p>当我们严格按照red-&gt;green-&gt;refactor的节奏不断推进时，我们的代码架构就会变好，代码经过更多的测试，代码质量也会得到一定的保证。而这只是单元测试带来的附加值。</p>\n<p>现在我们有了单元测试这个武器后，看看我们的开发流程会变成怎样？</p>\n<ol>\n<li>设计代码逻辑，与前面不同之处在于，我们先不深入到具体的代码逻辑，而是将功能模块化，将模块接口化</li>\n<li>挑一个接口开始编程</li>\n<li>按照开发顺序，写好待测逻辑的单元测试</li>\n<li>开发特性代码逻辑，让单元测试通过</li>\n<li>如果发现设计逻辑导致无法开发，回到步骤1</li>\n<li>重复3-4步，直到接口完成</li>\n<li>重复1-6，直到特性代码完成</li>\n<li>编写功能测试，调试，如果发现问题，检验代码逻辑，如果有设计问题，仍然要回到步骤1</li>\n</ol>\n<p>可以看到，从第3步开始，我们就不断地测试，不断验证我们的逻辑。虽然到达最后一步功能测试验证时，如果发现设计问题，仍然要返工回到步骤1，但因为我们期间不断地测试，不断地思考，并验证逻辑，我们可能很早就发现了设计问题，而不会等到最后一步才需要返工。正因为如此，当我们在准备进行功能测试验证的时候，我们对自己开发的代码更有信心。</p>\n<h1 id=\"单元测试带来的额外好处\"><a href=\"#单元测试带来的额外好处\" class=\"headerlink\" title=\"单元测试带来的额外好处\"></a>单元测试带来的额外好处</h1><h2 id=\"单元测试帮助你进入心流\"><a href=\"#单元测试帮助你进入心流\" class=\"headerlink\" title=\"单元测试帮助你进入心流\"></a>单元测试帮助你进入心流</h2><p>单元测试提升了我们对开发代码的信心，让我们有机会实现red-&gt;green-&gt;refactor的开发节奏，从而优化代码架构。单元测试让我们能够更focus，从而更容易进入心流状态。进入心流状态，意味着注意力极为集中，工作效率很高。</p>\n<blockquote>\n<p><strong>心流</strong>（英语：Flow），也有别名以化境（Zone）表示，亦有人翻译为<strong>神驰</strong>或<strong>沉浸</strong>状态，是由匈牙利裔美籍心理学家<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%93%88%E9%87%8C%C2%B7%E5%A5%91%E5%85%8B%E6%A3%AE\" title=\"米哈里·契克森\">米哈里·契克森</a>首度提出，定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生同时会有高度的兴奋感及充实感等正向情绪。<br>Martin Fowler的<a href=\"https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073\">The Clean Coder: A Code of Conduct for Professional Programmers: Martin, Robert: 4708364241379: Amazon.com: Books</a>一书告诉我们，心流对程序员来说并不一定是好事，但大多数情况它还是好的。心流并不在本文讨论范围之内。</p>\n</blockquote>\n<p>《测试驱动开发》一书给出了一种撰写单元测试的最佳实践。即<strong>每次关注一个足够小的逻辑，并在完成之后再完善它</strong>。</p>\n<p>因为人的注意力是有限的，不能一次性关注太多的东西。在开发某一个逻辑中间，如果被其他事情分散了注意力，往往会造成逻辑发散。例如：你在实现一个上报故障逻辑，但你希望记录每个故障的时间戳，你又不记得时间戳函数的具体使用方法。这时候如果你选择去google这个函数，并搞清楚它的使用方法，有可能你需要花很久时间才会回到你原先的主线逻辑继续开发。这和你的开发被打断没有区别，你失去了进入心流的机会，你需要花很长的时间再重新回顾原先的开发现场，导致你的效率不可能很高。但这还不是最糟糕的。最糟糕的是，你在google的过程中，又发现了其他问题，你又去看那个问题，或者不巧在这过程中被访客打断（实际工作中经常发生，这也是通常我认为在家远程办公的效率可能更高）。你离开原先的开发主线的时间越长，则需要重建现场的时间就越长。这和操作系统的中断很像，你离开的时间越长，很多cache都被flush掉了，那么你再次回到原先的工作状态就要花费更多的overloading。</p>\n<p>Kent Beck给出的建议是，以最简单的方法解决当前的问题，让你每一个开发逻辑都原子化地完成。例如：刚才我们的上报故障功能需要一个时间戳，我们现在不知道怎么写那个时间戳方法，于是就先hard code一个时间戳，并在我们的TODO list上记录一个事项。等我们完成了当前的开发逻辑，再去除TODO list，依次解决上面的问题。等问题都解决完了，再进行下一步开发。每件事务的处理保持原子化，要么没做，要么就做完。这样多出来记录TODO list的时间，但节省了被打断并且恢复现场的时间，并且你有更多的机会进入“心流”。</p>\n<h2 id=\"单元测试帮助你克服内心的恐惧\"><a href=\"#单元测试帮助你克服内心的恐惧\" class=\"headerlink\" title=\"单元测试帮助你克服内心的恐惧\"></a>单元测试帮助你克服内心的恐惧</h2><p>通常一个有责任心的程序员，都会有“完美程序”情节。你希望你写出来的代码是完美抽象的，通用性好，扩展性强，性能佳，等等。这本没有错，也是一个程序员的基本素养。但如果你总是想毕其功于一役，却并没有那么简单。这曾经也深深地困扰过我。在一个支线逻辑上踟蹰不前，严重影响开发效率。在现实的开发中，我也观察到很多同事有和我一样的困扰。针对这个问题， Kent Beck给出的建议是，先实现你的预定计划（除非你可以立即证明它完全是错误的，无法实现）。之后，再通过不断的重构，在必要的时候优化它，避免过设计。直到它能满足你的需求。</p>\n<p>我们总是提倡编写好代码，优美的代码，但事实上，并没有放之四海而皆准的好代码标准。好的代码应该是动态的，能够满足当下可见的需求（功能性和扩展性）的代码就是好代码。当有新需求的时候，比如开发新特性，或需要做性能优化，及时地重构就可以了。重构应当是实时进行的，是自下而上的。通过一些技巧和工具，我们在重构中就能让代码进化到一个更适合当前需求的状态，从而更易于开发新特性，或者继续重构优化。</p>\n<p>再回头看，为什么程序员会有完美代码情结？没错，因为他们自律，有责任心，且见贤思齐。但换个角度说，也可能因为他们内心有一种焦虑，或者恐惧。这是程序员对自己代码没有信心的表现。担心因为一时考虑不周全，在未来会付出更大的返工。每时每刻需要在欠设计和过设计之间做权衡。但请记住，代码是动态的，只要保证代码能够实时地被重构，尽量减少代码的坏味道，代码架构通常大概率是合理的。架构合理的代码，不论做架构调整或性能优化，都是比较容易的。没必要追求所谓的“完美代码”。</p>\n<p>我们平时编程时，应当尽力克服自己内心对未知的恐惧，用单元测试和重构来武装自己。这时，我常常想到一个词“Zen Coding”。做一个佛系的程序员，运用禅编程。</p>\n<h1 id=\"单元测试的误区\"><a href=\"#单元测试的误区\" class=\"headerlink\" title=\"单元测试的误区\"></a>单元测试的误区</h1><p>公司在施行可信变革时，要求单元测试能够达到一定的覆盖率数值。这是完全正确的，应该被提倡。因为只有单元测试的覆盖率足够高，才能在重构时捕获每一个轻微的逻辑破损，避免因为即时重构引入的问题。而单元测试因为通常采用mock依赖实现，理论上只要mock实现的足够优秀，是可以实现100%的覆盖率的。但真正在项目运行的时候，因为覆盖率是一个很容易感知的指标，所以单元测试慢慢地沦为实现覆盖率的附属品。也就是只是为了实现超高覆盖率而写单元测试。这表现在：</p>\n<ul>\n<li>每个测试case不是为了覆盖一个小逻辑而产生，为了迅速满足覆盖率要求，很多个测试断言放在一起，产生巨大的composite case</li>\n<li>为了完成超高覆盖率，随意运用核武器来mock依赖函数，造成mock了过多的内部实现，测试代码变得异常脆弱，一旦依赖实现需要变更，整棵依赖树上的测试case都要跟着改</li>\n<li>测试代码缺乏重构，随处可见重复代码，一旦变更要涉及多处更改</li>\n<li>测试case之间耦合严重，一个特性代码的修改理想情况下只会导致一个相关case失败，但耦合严重的case，往往会失败一大片。一个特性代码改动导致一个完全不相干的case失败。这是很令人崩溃的事情。令人崩溃的事情往往就会成为一个包袱，随时等待被丢弃。</li>\n</ul>\n<p>在我接触到的项目中，这样的情况非常普遍。虽然我们每日的CI报告中，单元测试覆盖率数值是很好看的。但实际单元测试应该产生的作用很小，甚至沦为了开发的负担。通常听到一个词语叫“补单元测试”。可见单元测试并没有被正确的使用。打个比方，登山运动员都有一个很大的背包，背包里面放满了各种救命用的工具。你见别人的包挺大，你也整了个大背包，然后背了一堆你爱吃的零食。这些零食在一开始的时候，让你挺happy，到了关键时刻，别人从背包里拿出救命的工具，你的背包只会成为累赘，不如早早丢弃。</p>\n<p>正确的做法应当是，每写一个小逻辑（接口实现级别，若干个小逻辑组成一个接口），就完成一个单元测试case与之对应，不论你是先写case（TDD），还是先写特性代码（非TDD）。当整个特性代码完成后，单元测试也是完备的，并且提交MR之前，应当即时完成重构，并修复能识别到的坏味道。如果因为交付时间问题，不能即时解决的应当添加FIXME注释，并且在你的TODO list上添加一条，以跟踪该事项。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>单元测试是工具不是目的。</li>\n<li>单元测试用于即时重构，优化代码逻辑和结构，功能测试用于看护代码质量</li>\n<li>流水不腐，户枢不蠹，好的代码应该不断地流动，在变化中达到平衡</li>\n</ul>\n",
            "tags": [
                "UT",
                "TDD"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/08/22/obsidian_posts/%E7%8F%8D%E7%88%B1%E7%94%9F%E5%91%BD%EF%BC%8C%E8%BF%9C%E7%A6%BB%E5%A4%A7%E8%B1%A1/",
            "url": "https://zhougy0717.github.io/2021/08/22/obsidian_posts/%E7%8F%8D%E7%88%B1%E7%94%9F%E5%91%BD%EF%BC%8C%E8%BF%9C%E7%A6%BB%E5%A4%A7%E8%B1%A1/",
            "title": "珍爱生命，远离大象",
            "date_published": "2021-08-22T14:55:52.549Z",
            "content_html": "<p>从2010年开始用印象笔记，将近11年了，实在忍受不了大象的臃肿，各种bug，虽然还充了5年会员，还是决定忍痛告别。全面拥抱[[Obsidian资源索引]] + syncthing。</p>\n<blockquote>\n<p>Obsidian入坑指南</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/364702744\">笔记软件及剪藏：Obsidian与Markdownload</a></li>\n<li><a href=\"https://sspai.com/post/62414\">玩转 Obsidian |  打造知识循环利器 - 少数派</a></li>\n</ul>\n</blockquote>\n",
            "tags": [
                "印象笔记",
                "Obsidian"
            ]
        },
        {
            "id": "https://zhougy0717.github.io/2021/08/22/obsidian_posts/Hexo%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/",
            "url": "https://zhougy0717.github.io/2021/08/22/obsidian_posts/Hexo%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/",
            "title": "Hexo实现博客使用本地图片",
            "date_published": "2021-08-22T11:28:23.669Z",
            "content_html": "<p>links: </p>\n<ul>\n<li>[[hexo-renderer-marked]]</li>\n</ul>\n<h1 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h1><ol>\n<li>安装插件hexo-asset-image</li>\n<li>修改_config.yml, <code>post_asset_folder: false</code>。将false改为true</li>\n<li>在与md文件同目录下，创建一个同名文件夹，放入需要的图片文件</li>\n<li>在md文件中，这样引用就好了<code>![](file-name.png)</code></li>\n<li><p>Hexo在生成时</p>\n<ol>\n<li><p>会自动处理这些图片标签，生成结果：<code>/path_to_post/post_name/iamge-name</code>。例如<code>/2021/08/22/my-post/post123/my-img.png</code>。source目录结果如下：<br> |—source</p>\n<pre><code> |--post123.md\n |--post123\n     |--my-img.png\n</code></pre></li>\n<li><p>Hexo的hexo-asset-image插件自动扫描目录，将md同目录下，与md文件同名的目录，拷贝到最终生成的index.html相同层级的目录下。<br> |—public</p>\n<pre><code> |--2021\n     |--08\n         |--22\n             |--post123\n                 |--index.html\n                 |--my-img.png\n</code></pre></li>\n</ol>\n</li>\n</ol>\n<p>同时，md文件里通过<code>![](my-img.png)</code>一样也可以访问到。</p>\n<h1 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h1><p>没试过，仅作参考</p>\n<blockquote>\n<p>《<a href=\"https://ashooter.github.io/2018-11-15/%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/\">如何在Hexo中添加本地图片 | BiuBiu</a>》</p>\n<p>以上方法可以解决本地图片上传和引用的问题，但是在每个文章下建立资源文件夹好处是分类清楚，缺点是图片复用不方便，也不符合网站设计的一般规范。</p>\n<p>所以我们可以第二种方案：</p>\n<ul>\n<li>在本地source中建立img文件夹，将引用到的图片全部放在此文件夹中。这样操作也便于图片的复用。</li>\n<li><strong>注意，采用这种方法时无需修改_config.yml,也无需安装hexo-asset-image</strong></li>\n</ul>\n</blockquote>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://ashooter.github.io/2018-11-15/%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/\">如何在Hexo中添加本地图片 | BiuBiu</a></li>\n<li><a href=\"https://hexo.io/docs/asset-folders\">Asset Folders | Hexo</a></li>\n<li>[[hexo-renderer-marked]]: <a href=\"https://github.com/hexojs/hexo-renderer-marked\">hexojs/hexo-renderer-marked: Markdown renderer for Hexo</a></li>\n</ul>\n",
            "tags": [
                "hexo"
            ]
        }
    ]
}