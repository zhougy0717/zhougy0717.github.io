{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben • All posts by \"计算机技术\" category",
    "description": null,
    "home_page_url": "https://blog.zhougy.top",
    "items": [
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "title": "聚合类型&POD",
            "date_published": "2021-09-18T14:03:05.792Z",
            "content_html": "<h1 id=\"什么是聚合类型\"><a href=\"#什么是聚合类型\" class=\"headerlink\" title=\"什么是聚合类型\"></a>什么是聚合类型</h1><blockquote>\n<p><strong>C++03定义</strong><br>An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).</p>\n<p><strong>C++11定义</strong><br>An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>结合C++03和C++11标准定义，罗列一下聚合类型的特性：</p>\n<ul>\n<li>聚合类型可以有构造函数，但只能是编译器定义的默认构造函数，或者用<code>=default</code>定义的构造函数</li>\n<li>聚合类型不能有private，protected非static变量</li>\n<li>聚合类型可以有copy-assignment operator and/or destructor</li>\n<li>数组是聚合类型，即便数组成员是非聚合类型</li>\n<li>聚合类型的数组可以是非聚合类型</li>\n<li>聚合类型不能用brace-or-equal-initializers（即就地初始化）初始化非static成员。</li>\n</ul>\n<h2 id=\"聚合类型变量初始化\"><a href=\"#聚合类型变量初始化\" class=\"headerlink\" title=\"聚合类型变量初始化\"></a>聚合类型变量初始化</h2><p>聚合类型可以采用列表初始化（其实非聚合类型，通过自定义构造函数，也可以采用列表初始化）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(m == n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the ith element of the array is initialized with ai</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the first m elements of the array are initialized with a1,  a2, …, am and the other n - m elements are, if possible, value-initialized (see below for the explanation of the term)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &gt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the compiler will issue an error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"comment\">/*(this is the case when n isn&#x27;t specified at all like int a[] = &#123;1, 2, 3&#125;;) */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the size of the array (n) is assumed to be equal to m, so int a[] = &#123;1, 2, 3&#125;; is equivalent to int a[3] = &#123;1, 2, 3&#125;;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>聚合变量最大的特点可以做<strong>聚合初始化</strong>，除了基本的列表初始化规则，聚合初始化还体现在可以递归初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i1;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Y</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"keyword\">float</span> f; </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> d;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>&#123;&#125;      </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Z</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"built_in\">Z</span>(<span class=\"keyword\">char</span> a1) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y y = &#123;<span class=\"string\">&#x27;a&#x27;</span>, &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;, &#123;<span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><br><code>y.x</code>也被初始化了。如果对Z用递归聚合初始化，例如<code>Z z = &#123;&#39;a&#39;, &#123;&#39;b&#39;&#125;&#125;</code>，编译器就会报错。因为Z不是聚合类型，编译器会去找对应的构造函数，显然Z没定义这样的构造函数。<br>具体介绍可以参考<a href=\"https://en.cppreference.com/w/cpp/language/aggregate_initialization\">Aggregate initialization</a>。</p>\n<h1 id=\"什么是POD变量\"><a href=\"#什么是POD变量\" class=\"headerlink\" title=\"什么是POD变量\"></a>什么是POD变量</h1><p>POD = Plain Old Data，可见这是一种兼容型比较好的形态。甚至可以导出与其他语言共享此类变量定义。</p>\n<blockquote>\n<p><strong>C++03定义</strong><br>A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.</p>\n<p>C++11定义变得非常优雅<br><strong>A POD struct is a non-union class that is both a trivial class and a standard-layout class</strong>, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>总而言之：<br>POD类型是一种特殊的聚合类型，一个POD类型为：</p>\n<ul>\n<li>标量类型。</li>\n<li>满足以下条件的自定义类型：<ul>\n<li>C++11之前：<ul>\n<li>聚合类型。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n<li>没有引用类型的非静态成员变量。</li>\n<li>没有自定义的构造函数或析构函数。</li>\n</ul>\n</li>\n<li>C++11之后：<ul>\n<li>是平凡类。</li>\n<li>是标准布局类。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>POD类型的数组。</li>\n</ul>\n<h1 id=\"聚合类型或是POD变量有什么好处？\"><a href=\"#聚合类型或是POD变量有什么好处？\" class=\"headerlink\" title=\"聚合类型或是POD变量有什么好处？\"></a>聚合类型或是POD变量有什么好处？</h1><p>聚合类最大的特点就是可以采用聚合初始化。<br>POD的特点更为实用一些</p>\n<blockquote>\n<p><strong>POD的用途</strong><br>平凡类的用途：</p>\n<ul>\n<li>平凡类的对象可以与字节流之间安全转换，即：<ul>\n<li>若要将对象转为字节流，直接取其地址即可。</li>\n<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>\n<li>直接通过复制字节的方式复制对象。</li>\n</ul>\n</li>\n<li>安全的静态初始化。<ul>\n<li>C++11的thread_local变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的__thread只能使用POD类型。</li>\n</ul>\n</li>\n</ul>\n<p><strong>标准布局类的用途：</strong><br>跨进程、跨语言使用。</p>\n</blockquote>\n<h1 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h1><h2 id=\"value-initialization\"><a href=\"#value-initialization\" class=\"headerlink\" title=\"value initialization\"></a>value initialization</h2><ul>\n<li>对于普通类型变量(bool, int, char, double, pointers, etc.)<br>it means it is initialized with 0 for that type (false for bool, 0.0 for double, etc.). </li>\n<li>对于class类型<ul>\n<li>如果有自定义构造函数，则调用自定义构造函数</li>\n<li>如果没有自定一构造函数，则调用默认构造函数</li>\n<li>如果没有对应的构造函数，则报错</li>\n</ul>\n</li>\n</ul>\n<p>举例<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span>) &#123;&#125; <span class=\"comment\">//no default constructor</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">B</span>() &#123;&#125; <span class=\"comment\">//default constructor available</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  A a1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>), <span class=\"built_in\">A</span>(<span class=\"number\">1</span>), <span class=\"built_in\">A</span>(<span class=\"number\">14</span>)&#125;; <span class=\"comment\">//OK n == m</span></span><br><span class=\"line\">  A a2[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>)&#125;; <span class=\"comment\">//ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]</span></span><br><span class=\"line\">  B b1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">B</span>()&#125;; <span class=\"comment\">//OK b1[1] and b1[2] are value initialized, in this case with the default-ctor</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array1[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//All elements are initialized with 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array2[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">//Attention: only the first element is 1, the rest are 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> Array3[<span class=\"number\">1000</span>] = &#123;&#125;; <span class=\"comment\">//the braces can be empty too. All elements initialized with false</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array4[<span class=\"number\">1000</span>]; <span class=\"comment\">//no initializer. This is different from an empty &#123;&#125; initializer in that</span></span><br><span class=\"line\">  <span class=\"comment\">//the elements in this case are not value-initialized, but have indeterminate values </span></span><br><span class=\"line\">  <span class=\"comment\">//(unless, of course, Array4 is a global array)</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> array[<span class=\"number\">2</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;; <span class=\"comment\">//ERROR, too many initializers</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>大括号中个数不足的，用value initialization补足。这就是<code>A a = &#123;1&#125;;</code>或者<code>A a = &#123;&#125;</code>的含义。大括号中个数超过声明的个数的，则编译报错。</p>\n<h2 id=\"brace-or-equal-initializers\"><a href=\"#brace-or-equal-initializers\" class=\"headerlink\" title=\"brace-or-equal-initializers\"></a>brace-or-equal-initializers</h2><p>类成员的一种初始化方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"keyword\">int</span>)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b &#123;<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    B c &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">    B d = &#123;<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copy-assignment-operator\"><a href=\"#copy-assignment-operator\" class=\"headerlink\" title=\"copy-assignment operator\"></a>copy-assignment operator</h2><p>拷贝赋值方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\">A <span class=\"title\">A</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">const</span> &amp;) &#123;&#125;</span><br><span class=\"line\">    A&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> A&amp;a) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    A b = a; <span class=\"comment\">// 这里调用的是拷贝构造函数</span></span><br><span class=\"line\">    A c;</span><br><span class=\"line\">    c = a; <span class=\"comment\">// 这里才会调用拷贝复制函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"trial-stuff\"><a href=\"#trial-stuff\" class=\"headerlink\" title=\"trial stuff\"></a>trial stuff</h2><h3 id=\"trivial-copyable\"><a href=\"#trivial-copyable\" class=\"headerlink\" title=\"trivial copyable\"></a>trivial copyable</h3><p>参考<a href=\"https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable\">C++ named requirements: TriviallyCopyable</a></p>\n<blockquote>\n<p>The following types are collectively called trivially copyable types:</p>\n<ul>\n<li>Scalar types</li>\n<li>Trivially copyable classes, i.e. classes satisfying following requirements:<ul>\n<li>At least one copy constructor, move constructor, copy assignment operator, or move assignment operator is eligible</li>\n<li>Every eligible copy constructor (if any) is trivial</li>\n<li>Every eligible move constructor (if any) is trivial</li>\n<li>Every eligible copy assignment operator (if any) is trivial</li>\n<li>Every eligible move assignment operator (if any) is trivial</li>\n<li>Has a trivial non-deleted destructor</li>\n</ul>\n</li>\n<li>Arrays of TriviallyCopyable objects</li>\n</ul>\n<p>This implies that a trivially copyable class has no virtual functions or virtual base classes.</p>\n</blockquote>\n<p>通过模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivially_copyable\">std::is_trivially_copyable</a>可以检验一个类是否trivially copyable。</p>\n<h3 id=\"trivial-constructor-destructor\"><a href=\"#trivial-constructor-destructor\" class=\"headerlink\" title=\"trivial constructor/destructor\"></a>trivial constructor/destructor</h3><ul>\n<li>编译器定义的构造/析构函数</li>\n<li>用<code>=default</code>定义的构造析构函数<h3 id=\"trivial-class\"><a href=\"#trivial-class\" class=\"headerlink\" title=\"trivial class\"></a>trivial class</h3>The standard defines a trivial class as follows:</li>\n</ul>\n<p>A trivially copyable class is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n<p>A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n<p>[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes. ]<br>另外trivial class是递归的，即trivial class不能有非trivial class的非static成员。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivial\">std::is_trivial</a>来测试</p>\n<h2 id=\"standard-layout\"><a href=\"#standard-layout\" class=\"headerlink\" title=\"standard layout\"></a>standard layout</h2><p>A standard-layout class is a class that:</p>\n<ul>\n<li><p>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p>\n</li>\n<li><p>has no virtual functions (10.3) and no virtual base classes (10.1),</p>\n</li>\n<li><p>has the same access control (Clause 11) for all non-static data members,</p>\n</li>\n<li><p>has no non-standard-layout base classes,</p>\n</li>\n<li><p>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, (要么终点类没有非静态成员，并且只有一个基类有非静态成员；要么没有基类有非静态成员)，and</p>\n</li>\n<li><p>has no base classes of the same type as the first non-static data member.</p>\n</li>\n</ul>\n<p>A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.</p>\n<p>A standard-layout union is a standard-layout class defined with the class-key union.</p>\n<p>[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.]</p>\n<p>标准内存分布，确保对象内存和C语言的结构体内存分布完全一致。使得POD变量具备了C兼容性。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_standard_layout\">std::is_standard_layout</a>可以测试</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>用<a href=\"https://en.cppreference.com/w/cpp/types/is_pod\">std::is_pod</a>来测试你的类吧。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">What are Aggregates and PODs and how/why are they special?</a></li>\n<li><a href=\"https://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/\">C++对象模型（三）POD</a></li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/",
            "url": "https://blog.zhougy.top/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/",
            "title": "unique_ptr到底是否能按值传递？",
            "date_published": "2021-08-22T02:36:37.359Z",
            "content_html": "<p>答案是否定的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::unique_ptr&lt;<span class=\"keyword\">int</span>&gt; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> a = std::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">func</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这段代码是不能编译的，因为uniqe_ptr没有拷贝构造函数。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ben@LUbuntu ~/t/unique_ptr&gt; g++ -o <span class=\"built_in\">test</span> main.cpp -std=c++14</span><br><span class=\"line\"></span><br><span class=\"line\">main.cpp: In <span class=\"keyword\">function</span> ‘int main()’:</span><br><span class=\"line\"></span><br><span class=\"line\">main.cpp:10:11: error: use of deleted <span class=\"keyword\">function</span> ‘std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]’</span><br><span class=\"line\"></span><br><span class=\"line\">10 | func(a);</span><br><span class=\"line\"></span><br><span class=\"line\">|</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>那为什么问这个问题？看下面这段代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::unique_ptr&lt;<span class=\"keyword\">int</span>&gt; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(std::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个是可以编译的，执行也没问题。再看make_unique的原型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt; class T, class... Args &gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">( Args&amp;&amp;... args )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt; class T &gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">( std::<span class=\"keyword\">size_t</span> size )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">Args</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* unspecified */</span> <span class=\"built_in\">make_unique</span>( Args&amp;&amp;... args ) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可见make_unique的返回值是unique_ptr。那么前面那段代码就给人造成了unique_ptr似乎也可以按值传递的假象。到底是什么原因呢？后面我们结合汇编一起分析一下，编译器针对这样的场景做了什么优化。</p>\n<h1 id=\"make-unique的返回值直接作为函数参数的真相\"><a href=\"#make-unique的返回值直接作为函数参数的真相\" class=\"headerlink\" title=\"make_unique的返回值直接作为函数参数的真相\"></a>make_unique的返回值直接作为函数参数的真相</h1><p>直接通过<code>objectdum -tCS test &gt; test.dump</code>命令对可执行文件进行反汇编。注意编译时，要指定<code>-g -O0</code>。这样反汇编时，信息更多一些。</p>\n<p>由于STL扩展代码，外加C++编译器插入的一些初始化和退出清理代码，反汇编产生的文件行数较多，我们只需关注核心的main函数以及一些相关的函数即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">4008a8: a9be7bfd stp x29, x30, [sp, #-32]! // 将x29,x30存储于sp-32处，且sp = sp-32</span><br><span class=\"line\"></span><br><span class=\"line\">4008ac: 910003fd mov x29, sp</span><br><span class=\"line\"></span><br><span class=\"line\">func(std::make_unique&lt;int&gt;(1));</span><br><span class=\"line\"></span><br><span class=\"line\">4008b0: 52800020 mov w0, #0x1 // #1</span><br><span class=\"line\"></span><br><span class=\"line\">4008b4: b9001fe0 str w0, [sp, #28]</span><br><span class=\"line\"></span><br><span class=\"line\">4008b8: 910073e0 add x0, sp, #0x1c</span><br><span class=\"line\"></span><br><span class=\"line\">4008bc: 910043e1 add x1, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008c0: aa0103e8 mov x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\">4008c4: 94000027 bl 400960 &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4008c8: 910043e0 add x0, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008cc: 97fffff2 bl 400894 &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4008d0: 910043e0 add x0, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008d4: 94000035 bl 4009a8 &lt;std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;::~unique_ptr()&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">4008d8: 52800000 mov w0, #0x0 // #0</span><br><span class=\"line\"></span><br><span class=\"line\">4008dc: a8c27bfd ldp x29, x30, [sp], #32</span><br><span class=\"line\"></span><br><span class=\"line\">4008e0: d65f03c0 ret</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">///@&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"调用make-unique前的准备\"><a href=\"#调用make-unique前的准备\" class=\"headerlink\" title=\"调用make_unique前的准备\"></a>调用make_unique前的准备</h2><p>main函数的第一行指令，将栈指针（sp）移动到了栈底，并保存了x29和x30寄存器。寄存器含义可以参考附录。在调用make_unique前，栈内存如下图。<br><img src=\"/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/Pasted%20image%2020210822121125.png\" alt></p>\n<h3 id=\"ARM函数调用约定\"><a href=\"#ARM函数调用约定\" class=\"headerlink\" title=\"ARM函数调用约定\"></a>ARM函数调用约定</h3><p>也叫AAPCS，Procedure Call Standard for the Arm Architecture。对于aarch64，简而言之就是：</p>\n<ul>\n<li><p>小于8个参数时，使用x0-x7寄存器</p>\n</li>\n<li><p>超过8个参数，按顺序从右往左入栈（因为栈是先入后出的）</p>\n</li>\n<li><p>返回地址在lr寄存器，返回值的值在x0寄存器</p>\n</li>\n</ul>\n<h3 id=\"make-unique的参数传递\"><a href=\"#make-unique的参数传递\" class=\"headerlink\" title=\"make_unique的参数传递\"></a>make_unique的参数传递</h3><p>按照AAPCS的理解，make_unique的实现函数实际有两个入参：一个是uniuqe_ptr的构造函数参数1，另一个就是用来存放unique_ptr对象指针的地址，即x1。</p>\n<p>这样就很好理解了，调用完make_unique，下一步就是使用make_unique的输出调用func了。也就是<code>add x0, sp, #0x10</code>z这一行。将保存了unique_ptr指针的地址赋予了func函数的唯一一个参数。</p>\n<blockquote>\n<p><strong>所以可见，func函数并不是传递unique_ptr的值，而是通过编译器生成了一个临时变量保存了make_unique返回的unique_ptr对象指针，并传递给了func。</strong></p>\n</blockquote>\n<h3 id=\"按引用传递会怎么样？\"><a href=\"#按引用传递会怎么样？\" class=\"headerlink\" title=\"按引用传递会怎么样？\"></a>按引用传递会怎么样？</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> a = <span class=\"built_in\">std</span>::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    func(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">int</span> main()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>a8: a9bd7bfd stp x29, x30, [<span class=\"built_in\">sp</span>, #-<span class=\"number\">48</span>]!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>ac: <span class=\"number\">910003</span>fd <span class=\"keyword\">mov</span> x29, <span class=\"built_in\">sp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b0: f9000bf3 <span class=\"keyword\">str</span> x19, [<span class=\"built_in\">sp</span>, <span class=\"number\">#16</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">auto</span> a = std::make_unique&lt;int&gt;(<span class=\"number\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b4: <span class=\"number\">52800020</span> <span class=\"keyword\">mov</span> w0, <span class=\"number\">#0x1</span> <span class=\"comment\">// #1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b8: b9002fe0 <span class=\"keyword\">str</span> w0, [<span class=\"built_in\">sp</span>, <span class=\"number\">#44</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>bc: <span class=\"number\">9100</span>b3e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x2c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c0</span>: <span class=\"number\">910083</span>e1 <span class=\"keyword\">add</span> x1, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c4</span>: aa0103e8 <span class=\"keyword\">mov</span> x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c8</span>: <span class=\"number\">94000029</span> <span class=\"keyword\">bl</span> <span class=\"number\">40096</span>c &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">func</span>(a)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>cc: <span class=\"number\">910083</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">d0</span>: <span class=\"number\">97</span>fffff1 <span class=\"keyword\">bl</span> <span class=\"number\">400894</span> &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///@&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/Pasted%20image%2020210822121232.png\" alt></p>\n<p>如出一辙，对make_unique的调用是一样的，只不过这里多存了一个局部变量a，所以多话费了几个字节的栈空间。而前文的临时变量存在寄存器即可。</p>\n<h3 id=\"传右值引用呢？\"><a href=\"#传右值引用呢？\" class=\"headerlink\" title=\"传右值引用呢？\"></a>传右值引用呢？</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b8: <span class=\"number\">910073</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x1c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>bc: <span class=\"number\">910043</span>e1 <span class=\"keyword\">add</span> x1, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c0</span>: aa0103e8 <span class=\"keyword\">mov</span> x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c4</span>: <span class=\"number\">94000027</span> <span class=\"keyword\">bl</span> <span class=\"number\">400960</span> &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c8</span>: <span class=\"number\">910043</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>cc: <span class=\"number\">97</span>fffff2 <span class=\"keyword\">bl</span> <span class=\"number\">400894</span> &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可见传右值引用和传值一模一样。</p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"AARCH64寄存器\"><a href=\"#AARCH64寄存器\" class=\"headerlink\" title=\"AARCH64寄存器\"></a>AARCH64寄存器</h2><p>参考<a href=\"https://winddoing.github.io/post/7190.html\">ARMv8-aarch64 寄存器和指令集</a></p>\n<h3 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h3><ul>\n<li><p>参数寄存器（X0-X7）： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8 个寄存器可用于传递参数）</p>\n</li>\n<li><p>来电保存的临时寄存器（X9-X15）： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。</p>\n</li>\n<li><p>被调用者保存的寄存器（X19-X29）： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。</p>\n</li>\n</ul>\n<h3 id=\"特殊用途寄存器（X8，X16-X18，X29，X30）：\"><a href=\"#特殊用途寄存器（X8，X16-X18，X29，X30）：\" class=\"headerlink\" title=\"特殊用途寄存器（X8，X16-X18，X29，X30）：\"></a>特殊用途寄存器（X8，X16-X18，X29，X30）：</h3><p>X8： 是间接结果寄存器，用于保存子程序返回地址，尽量不使用</p>\n<p>X16 和 X17： 程序内调用临时寄存器</p>\n<p>X18： 平台寄存器，保留用于平台 ABI，尽量不使用</p>\n<p>X29： 帧指针寄存器（FP）</p>\n<p>X30： 链接寄存器（LR）</p>\n<p>X31： 堆栈指针寄存器 SP 或零寄存器 ZXR</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><p><a href=\"https://code.woboq.org/appleseed/include/boost/move/make_unique.hpp.html\">make_unique源码</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/forever_2015/article/details/50283747\">[AAPCS 学习课后练习 - 通过一个小例子来讲解]</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/42486116\">基于ARM64 的常见汇编命令记录</a></p>\n</li>\n<li><p><a href=\"https://winddoing.github.io/post/7190.html\">ARMv8-aarch64 寄存器和指令集</a></p>\n</li>\n</ul>\n",
            "tags": [
                "C++",
                "coding"
            ]
        }
    ]
}