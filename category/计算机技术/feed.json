{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben • All posts by \"计算机技术\" category",
    "description": null,
    "home_page_url": "https://blog.zhougy.top",
    "items": [
        {
            "id": "https://blog.zhougy.top/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/",
            "url": "https://blog.zhougy.top/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/",
            "title": "单元测试 vs. 功能测试",
            "date_published": "2021-09-19T12:40:57.189Z",
            "content_html": "<p>最近在某一次讨论测试的话题中，有一位同事认为“重构结果看护，用集成测试（Integration Test）就可以了，UT看护的逻辑太小，导致修改过于频繁，维护成本太高，没必要。”</p>\n<blockquote>\n<p>几种测试名词：</p>\n<ul>\n<li>单元测试（Unit Test或UT）<br>针对小的代码逻辑编写的测试，不需要运行在真实环境上的，可以随时部署，随时运行，结果应当保持一致</li>\n<li>功能测试（Function Test）<br>针对特性功能编写的测试，应当与实际运行环境保持一致，测试软件产品端到端功能</li>\n<li>集成测试（Integration Test）<br>针对系统或子系统中某个组件的特性功能编写的测试，对其依赖组件进行打桩，并在真实环境进行部署测试，通常用于看护代码提交质量</li>\n<li>冒烟测试（Smoke Test）<br>我们通常说的ST指的是冒烟测试，而非系统测试（System Test），冒烟测试与集成测试指代同一种测试</li>\n</ul>\n<p>另外，IT或ST都是一种功能测试，除此之外，还有看护完整特性功能的测试，性能测试等，都属于功能测试</p>\n</blockquote>\n<p>这位同学给出IT可以胜任看护重构结果的原因有：</p>\n<ul>\n<li>IT通过对周边依赖进行打桩，可以达到80%的覆盖率，看护力度足够</li>\n<li>只要设计足够精巧，完成一个大型工程的IT只需要十分钟，运行速度足够快</li>\n</ul>\n<p>因为在重构中，IT完全可以看护代码质量<sup>1⃣️</sup>，所以UT的作用就削弱了<sup>2⃣️</sup>。又因为UT看护粒度过细，导致UT代码维护困难，维护UT得不偿失<sup>3⃣️</sup>。而实际上，那个榜样部门就是这样做的——只用IT看护重构，库上代码放弃开发维护UT。</p>\n<p>先不遑论该部门做法的对与错，我们首先针对上面提到的三个观点进行剖析。</p>\n<h1 id=\"IT完全可以看护代码质量\"><a href=\"#IT完全可以看护代码质量\" class=\"headerlink\" title=\"IT完全可以看护代码质量\"></a>IT完全可以看护代码质量</h1><p>这一点我是认同的。UT的关注点是组成接口代码的小逻辑。虽然理论上只要保证每个小逻辑的输入输出正确，就可以保证一个接口的正确性，进而到模块，组件，系统级别。但是，因为UT对模块的划分比较细，模块之间采用打桩的方式解决依赖问题，而mock质量参差不齐，势必会造成对接口间，模块间的测试误差。这也是不可测性的一种体现。相反，因为IT的测试关注点，在特性功能（至少是组件级的功能），所以IT更擅长于发现组件集成时的bug（所以叫集成测试嘛）。</p>\n<h1 id=\"UT的作用被削弱了\"><a href=\"#UT的作用被削弱了\" class=\"headerlink\" title=\"UT的作用被削弱了\"></a>UT的作用被削弱了</h1><p>刚才说到IT相比UT更擅长看护代码质量，那是不是意味着UT没用了呢？<br>答案是否定的。我们先看看什么是IT不擅长的：</p>\n<ol>\n<li>由于IT关注的代码粒度较大，看护的是模块或组件间的特性接口，不利于构造细粒度的case，这造成分支覆盖率低。或者说如果要实现超高分支覆盖率，IT付出的成本会比较高。其结果就是测试稳定性高了（随代码改动而失败的频率降低，只要组件间接口保持一致，IT就不需要变更），但对代码修改的敏感度降低。</li>\n<li>IT的开发成本高。因为涉及到多模块甚至多组件协同，case复杂度高。如果涉及模块间接口打桩，由于接口复杂度高，桩代码实现也更为复杂。在特性代码开发过程中，无法进行有效的IT开发和测试。</li>\n<li>IT运行时间久。前面说到一个比较大的工程运行一次IT，运行时间可以控制到十分钟。可能很多人都认为十分钟是能够忍受的长度。对于IT来说，这确实是一个很优秀的数字了（我想为了实现这一点本身也是要付出很大的代价的）。但是如果将其运用到red-green-refactor的开发节奏中，还是有些不合时宜。试想，你要运行一个预计十分钟会完成的测试，你会全身灌注地盯着屏幕，等待十分钟直到测试完成吗？</li>\n</ol>\n<p><img src=\"/2021/09/19/obsidian_posts/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20vs.%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/Pasted%20image%2020210829201431.png\" alt></p>\n<p>我想通常是不会的。这时候，自制力差一点的同学就开始刷手机了，自制力好一点的同学会着手处理其他问题。这其实就是另一种被打断。而被打断是软件开发的大忌。你不仅失去进入“心流”的机会，并且你回到主线开发的时间间隔越长，花费在重建现场的额外开销就会越大，进而影响你的效率。</p>\n<p>先看看我们利用IT进行一次前文提到的大型“重构”的流程会是怎么样的？</p>\n<blockquote>\n<p>这里说的重构，我认为称为re-architecture更合适，和我们平时说的refactor还是不太一样。他们的共同点是，保证代码功能不变的前提下，优化代码架构和实现。区别是，re-architecture是一次根本性的架构变更，可能涉及到很多模块需要重写，而refactor更多的是在平时做一些代码调整，即所谓的小步重构。</p>\n</blockquote>\n<ol>\n<li>定好特性架构，开始特性开发</li>\n<li>特性代码接近完成时，开始开发IT</li>\n<li>开发IT的同时，一边调试IT，一边使用IT测试特性代码</li>\n<li>重复步骤3直到IT代码和特性代码均没有问题，即达到可交付状态。</li>\n</ol>\n<ul>\n<li>前文提到IT的测试时间相比UT还是比较久的，如果将其运用到red-green-refactor节奏中，则容易造成注意力分散，进而引起时间管理困境</li>\n<li>如果没有UT，步骤2通常会一直处于“裸奔”状态，“裸奔”的时间取决于开发者对特性代码开发状态的评估，一般要到特性代码比较接近完工水平时，才可以编写IT。由于IT开发调试难度高，基本也不太可能和特性代码一同开发。</li>\n<li>由于IT开发和运行的成本高，那么势必造成开发时，针对特性代码的测试运过少，那么由于开发的不稳定性，产生的返工可能性大，成本高。（换句话说，如果开发对于特性的熟悉程度非常高，实际上也可以不一定即时UT，还是选择与平衡问题。不过这种情况据我观察还是比较少的）</li>\n</ul>\n<p>所以抛弃UT，确实节省了一些代码开发时间，但也丢失了一件非常重要的武器，导致我们的开发节奏又回到了瀑布式开发，而无法实现小步快跑的即时重构开发方式。</p>\n<p>实际上我认为，<strong>引入UT就是为了引入reg-green-refactor的开发节奏，从而通过实时重构，及时消除代码坏味道，进而实现代码自下而上的架构设计</strong>。与前期自上而下的特性设计配合，以实现最合理的代码架构。避免在特性设计阶段过于关注实现细节，也避免在开发阶段，过于纠结权衡欠设计与过设计导致的效率低下。</p>\n<p>UT的运行成本非常低，这是因为UT不关注代码功能，只关注代码输入输出逻辑。全程对依赖接口进行打桩实现，运行速度很快（没有任何的延时和多线程操作，也可能连IO操作都没有）。UT针对小逻辑组织case，单case复杂度低，case之间的依赖关系被严格控制。所以运行的时候，一方面速度快，另一方面可以根据需要，随意组合运行的case以达到需要的测试范围和粒度。例如：可以选择运行一个case或是一个suite，也可以通过正则表达式运行多个case，或者完整运行所有的case。</p>\n<p>综上可见，UT和IT是两类用途完全不同的测试方法。一个好比军刀，可以上战场杀敌；一个好比菜刀，可以烹小鲜慰军。一个看护结果；一个促进过程。</p>\n<h1 id=\"UT维护困难，维护UT得不偿失\"><a href=\"#UT维护困难，维护UT得不偿失\" class=\"headerlink\" title=\"UT维护困难，维护UT得不偿失\"></a>UT维护困难，维护UT得不偿失</h1><blockquote>\n<p>那UT带来的工作量呢？</p>\n</blockquote>\n<p>刚才说，如果没有UT，其实会引入很多隐性工作量。如果要衡量工作量，更公平的比较应当是将维护UT的工作量与这些隐性工作量进行比较。通常我听到的对UT的抱怨大多是因为UT看护内部模块边界。当组件内部实现修改时，例如函数改名字，变更函数原型等一些特别频繁的重构操作，由于IT看护组件边界接口，IT更稳定不需要变动。而UT由于看护了内部模块边界，所以UT要随之更新。这些确实看起来是额外的工作量，但当前流行的开发工具，例如一些IDE或者VS code，都已经能够提供很好的重构工具，在修改函数名字，修改函数原型，或者抽取函数或内联函数等操作上，都已经可以大大减少开发者的操作难度。另外，由于UT对代码的敏感性，让你实时都感受到你的代码变动都是经过测试的，每一次变动都被看护，这种感觉不是很令人有安全感吗😊？</p>\n<p>而传统的瀑布式开发带来的隐性问题，很多是因为人类思考方式导致的。例如思路打断，对过设计和欠设计的恐惧，不停返工引起的沮丧心情。这些带来的影响很难去估量，他们可能很严重，也可能无足轻重，完全取决于开发者自身的素质。以我个人的经验看，我是更愿意花一些切实的UT成本，来消除这些不确定性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>再回过头来分析一下那个成功部门的做法。通过IT看护重构结果，并丢弃UT这种测试方法。首先，重构结果大概率不会有问题，因为有足够测试力度的IT作为看护工具。其次，因为缺乏及时运行的测试case，重构开发时效率得不到保证。大概率只能通过模块重写实现。另外，又因为重构效率低，成本高，重构只能积攒起来一次性完成。于是refactor变成re-architecture。</p>\n<p>不过话说回来，测试策略并没有对错之分，永远是项目组根据自身情况，权衡得出的。可能项目组一时无法获得UT的价值，或者项目组对UT对技术积累不充分，从而无法很好对实践UT。但我们还是应该厘清单元测试和功能测试的差别，分清应用场合，这样才能更好地朝正确的方向演进。</p>\n",
            "tags": [
                "UT",
                "TDD"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "title": "RBAC",
            "date_published": "2021-09-18T14:17:35.996Z",
            "content_html": "<p>RBAC, Role Based Access Control, 是SELinux的另一个重要的特性。但他并不是一种独立的控制方式，而是对TEAC的一种补充。其主要的作用是，构建SELinux提供的进程级的MAC机制与Linux的用户系统的映射关系。</p>\n<h1 id=\"RBAC工作原理\"><a href=\"#RBAC工作原理\" class=\"headerlink\" title=\"RBAC工作原理\"></a>RBAC工作原理</h1><p>RBAC并不提供强制访问控制，而是通过user，role，type之间的对应关系，来控制type_transition策略能否成功。</p>\n<h2 id=\"role-vs-type\"><a href=\"#role-vs-type\" class=\"headerlink\" title=\"role vs. type\"></a>role vs. type</h2><p>role based最基本的就是定义role到type到对应关系。使用role语句可以实现：<code>role role_name [types type_set];</code>。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">role user_r types user_t;</span><br><span class=\"line\">role user_r types &#123; staff_t, admin_t &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>role定义是累积的，即后面的对应关系不会覆盖前面语句定义的对应关系，而只会追加这种关系</li>\n<li>role语句通常定义在type声明附近，以确保该对应关系被及时定义</li>\n</ul>\n<blockquote>\n<p><strong>定义子role (period)</strong><br>A period is used to indicate restrictions on the set of types that may be assigned to a role. For example, the set of types for a role called <strong><em>apache.cgi</em></strong> must be a <strong><em>subset</em></strong> of the type set of a role called <strong><em>apache</em></strong>.</p>\n</blockquote>\n<p>role语句定义的基本逻辑就是，定义了role=&gt;{ types }集合的映射关系。当发生type transition时，如果转换后的{role，type}组合未定义，则视为权限错误。从这个层面看，role对应的是主体type，即domain type，而非object type。</p>\n<h3 id=\"特殊的role-object-r\"><a href=\"#特殊的role-object-r\" class=\"headerlink\" title=\"特殊的role: object_r\"></a>特殊的role: object_r</h3><p>object_r是内核SELinux模块预定义的一个role，无需在policy中声明。而这个object_r被专门用来定义客体的安全上下文。</p>\n<h2 id=\"user-vs-role\"><a href=\"#user-vs-role\" class=\"headerlink\" title=\"user vs. role\"></a>user vs. role</h2><p>user是对role的再一次扩充，通过user将role与Linux user的映射关系建立起来。SELinux的用户系统独立于Linux用户系统。通过seusers文件或者<code>semanage user</code>命令可以定义他们之间的映射关系。但实际可定义的自由度并没有那么高。</p>\n<blockquote>\n<p>The design decision for SELinux to have a distinct user identifier (rather than share that of Linux) is motivated by the desire to create an immutable SELinux user identifier.</p>\n</blockquote>\n<p>定义一个user与role的映射关系，可以使用user语句：<code>user user_name roles &#123; role_set &#125;;</code><br>user语句所体现的逻辑和role语句类似，即定义了user=&gt;{ roles }集合的映射关系。当应用启动时发生role transition时，如果转换后的{user, role}未定义，则视为权限错误。</p>\n<p>当SELinux通过RBAC，建立起user=&gt;role=&gt;type的映射关系以后，还获得了一个好处。Linux系统的用户数可能很多，而用户的类型很少。用户并不是为了定义权限的，不同的用户之间的使用数据需要隔离。但往往一类用户的权限是相同的。例如超级用户，管理员用户，普通用户等等。系统的权限集最小粒度由domain定义。可能每个进程的权限不同，也可能一组进程的权限相同。但往往domain的数量也很庞大。如果没有RBAC，我们需要定义user到domain到映射。这样也不是不能做，但却不太优雅。每次新增用户时，需要为新增用户绑定一堆domain。定义了role之后，role相当于较稳定的一层抽象，role到types的映射关系是在定义type时候就定义了的。增加新user的时候，只要定义user到role的映射即可。这就是引入RBAC的原因。</p>\n<pre class=\"mermaid\">graph LR\nA[user] --> B[role]\nA --> C[role]\nA --> D[role]\nC --> E[domain]\nC --> F[domain]\nC --> G[domain]</pre>\n\n<h3 id=\"Linux用户-vs-SELinux-user\"><a href=\"#Linux用户-vs-SELinux-user\" class=\"headerlink\" title=\"Linux用户 vs. SELinux user\"></a>Linux用户 vs. SELinux user</h3><ul>\n<li>当前系统的用户可以通过查看/etc/passwd文件获取，也可以参考<a href=\"https://zhuanlan.zhihu.com/p/41161408\">列出 Linux 系统上所有用户的 3 种方法</a>.</li>\n<li>查看SELinux的用户可以通过命令<code>semanage user -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               标记中        MLS/       MLS/                          </span><br><span class=\"line\">SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色</span><br><span class=\"line\"></span><br><span class=\"line\">guest_u         user       s0         s0                             guest_r</span><br><span class=\"line\">root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</span><br><span class=\"line\">staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r unconfined_r</span><br><span class=\"line\">sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r</span><br><span class=\"line\">system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">user_u          user       s0         s0                             user_r</span><br><span class=\"line\">xguest_u        user       s0         s0                             xguest_r</span><br></pre></td></tr></table></figure></li>\n<li>查看两者的映射关系可以通过命令<code>semanage login -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名                  SELinux 用户           MLS/MCS 范围           服务</span><br><span class=\"line\"></span><br><span class=\"line\">__default__          unconfined_u         s0-s0:c0.c1023       *</span><br><span class=\"line\">john                 user_u               s0                   *</span><br><span class=\"line\">root                 unconfined_u         s0-s0:c0.c1023       *</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Linux用户和SELinux用户的初始映射关系由seusers文件指定。这个文件不属于策略二进制的一部分，而可以直接修改生效。当然更优雅的办法是通过semanage命令来修改。<br>另外，在修改了context以后，或者新建了用户以后，必须要使用注销登录的方法，才能使新的context生效，而只使用su命令切换用户，并不会切换context。推测注销登录使用的是PAM登录程序，而su命令中，并没有重新加载user context的功能。<br>Linux用户登录后，获取shell安全上下文的步骤，可以参考文献【2】。简述如下：</p>\n<ol>\n<li>根据seusers文件，映射SELinux用户，如果没有seusers文件，系统就无法启动了。如果seusers文件没有对应的用户描述，则统一映射为<code>__default__</code>用户。如果<code>__default__</code>用户描述不存在，则无法登录。</li>\n<li>根据SELinux的搜索优先级，找到对应SELinux用户的安全上下文。</li>\n</ol>\n<blockquote>\n<p><strong>勘误</strong><br>在[1]中，对Linux用户和SELinux的映射关系有如下描述：<br>On login, if there is an SELinux user identifier that is exactly the same as the Linux user identifier, the matching SELinux user identifier becomes the user identifier in the security context for the initial shell process. In this way, if a Linux user identifier also exists as a user identifier in the SELinux policy, all login processes will set the initial shell process security context user identifier to that matching Linux identity.<br>经实验证明，并非如此：</p>\n<ul>\n<li>定义了一个guest_u用户，登录后，其shell的安全上下文仍为：<br><img src=\"/2021/09/18/obsidian_posts/RBAC/163C5090-847B-49EC-B709-3AAA87D776D9.png\" alt=\"1ca6909a350aa84947ea565bb4c8eaa2\"></li>\n<li>但事实证明，明明就有guest_u这个用户<br><img src=\"/2021/09/18/obsidian_posts/RBAC/CA68A544-BEE4-4B4E-9BC5-EA3452F816F9.png\" alt=\"7737fbc74190005733b9f01b60178907\"><br>推测，可能是因为SELinux也一直在发展改进中。[1]d 成书时间是2006年，彼时还是FC（Fedora Core）5的年代，现在最新版已经是Fedora 33，2020年10月份发布。</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在可以引用[1]中的一幅图来总结一下RBAC的工作原理了。<br><img src=\"/2021/09/18/obsidian_posts/RBAC/6903A6B7-B8D6-4621-8AF4-C276F4EAD57F.png\" alt=\"115b4d2e2576fd1b93937d66425645d5\"></p>\n<ul>\n<li>Linux系统有一个用户较joe</li>\n<li>SELinuxcelue中规定joe和user_r绑定，user_r和user_t绑定</li>\n<li>当joe登录时，系统根据seusers（此处与图不同，参见上一章勘误），找到对应的SELinux user，找不到就是<strong>default</strong>, <strong>default</strong>没有就不能登录了</li>\n<li>根据以下context文件顺序，决定其shell的安全上下文，即joe:user_r:user_t<ul>\n<li>/etc/selinux/specified-policy/contexts/users</li>\n<li>/etc/selinux/specified-policy/contexts/default_contexts</li>\n<li>/etc/selinux/specified-policy/contexts/failsafe_context</li>\n<li>sid kernel的安全上下文</li>\n</ul>\n</li>\n<li>joe执行了一个应用，开始进行domain_transition, 要从user_t切换到passwd_t<ul>\n<li>如果定义了<code>role user_r types passwd_t</code>和<code>role user_r types user_t</code>，则这次domain transition可以成功</li>\n<li>否则任意一个未定义，domain transition都会失败</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"高阶用法\"><a href=\"#高阶用法\" class=\"headerlink\" title=\"高阶用法\"></a>高阶用法</h1><h2 id=\"role-transition\"><a href=\"#role-transition\" class=\"headerlink\" title=\"role_transition\"></a>role_transition</h2><p>role transition和domain transition非常类似，也是在某个domain进程在执行某个可执行文件时，即exec系统调用时，切换进程主体的安全上下文。domain transition切换的时domain，role transtion切换的是role。实现方式通过以下两条语句：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow staff_r sysadm_r; # 允许从staff_r切换到sysadm_r</span><br><span class=\"line\">role_transition sysadm_r http_exec_t system_r; # sysadm_r进程执行http_exec_t类型文件时，role切换为system_r</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"role-dominance\"><a href=\"#role-dominance\" class=\"headerlink\" title=\"role_dominance\"></a>role_dominance</h2><p>可以利用role来定义其他role，即role dominance。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dominance &#123; role super_r &#123;role sysadm_r; role secadm_r; &#125;</span><br></pre></td></tr></table></figure><br>上面例子中的super_r称为dominant role，它可以从它关联的role中即成types。但它只能继承该条语句之前关联的types。我们之前说role语句是可以累积的。那么在role_dominance语句之后定义的types，并不能动态的添加到dominant role上。</p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><p>跟role相关的主要是semnage的一些用法，另外[1]还介绍了一个apol的可视化工具，可以检索user和role的数据。我理解semanage通过命令行也都可以实现。</p>\n<ol>\n<li>前文介绍过的<code>semanage user -l</code>和<code>semanage login -l</code>, 前者用来查看所有SELinux的用户，后者用来查看Linux用户和SELinux用户两者的映射关系.</li>\n<li>Modify the default user on the system to the guest_u user<ul>\n<li><code>semanage login -m -s guest_u __default__</code></li>\n</ul>\n</li>\n<li>修改user和role的对应关系<ul>\n<li><code>semanage user -m -R &quot;message_filter_r unconfined_r&quot; user_u</code></li>\n</ul>\n</li>\n<li>添加一个用户并指定SELinux用户<ul>\n<li><code>useradd joe -Z user_u</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://app.yinxiang.com/shard/s10/nl/161681/ea41e2f7-d7a8-4629-9f8c-c08696f578af/\">SELinux by Example_ Using Security Enhanced Linux</a><br>[2] <a href=\"https://blog.csdn.net/keheinash/article/details/81047520\">SELinux初始化登录用户安全上下文的方法</a></p>\n",
            "tags": [
                "SELinux",
                "security"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/initializer-list%E5%92%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/initializer-list%E5%92%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "title": "initializer-list和列表初始化",
            "date_published": "2021-09-18T14:07:11.246Z",
            "content_html": "<h1 id=\"C-11的列表初始化\"><a href=\"#C-11的列表初始化\" class=\"headerlink\" title=\"C++11的列表初始化\"></a>C++11的列表初始化</h1><p>在C语言和C++98/03中，大括号可以用来初始化数组，例如：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;; <span class=\"comment\">// 如果个数不足的，用0初始化</span></span><br></pre></td></tr></table></figure></p>\n<p>C++11将这类大括号初始化，扩展到自定义类型，但需要满足一定的条件，否则会编译报错。</p>\n<blockquote>\n<p>参考<a href=\"https://blog.csdn.net/JinhuCheng/article/details/107330983\">C++11新特性之列表初始化、POD、聚合类</a></p>\n<ol>\n<li>C++98/03标准中对于普通数组和POD类型可以直接使用列表初始化；</li>\n<li>C++11标准中对于普通数组和聚合类型可以直接使用列表初始化；</li>\n<li>C++11标准中对于非聚合类型可以通过自定义构造函数的方式使用列表初始化。<br><a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a>提到非聚合类型不能使用列表初始化是不对的。实验证明，不论是不是聚合类型，均可以采用列表初始化。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">A</span>(<span class=\"keyword\">int</span> a1) &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"keyword\">int</span>&gt; l) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tA a = &#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n首先声明<code>A a=&#123;123&#125;</code>或者<code>A a&#123;123&#125;</code>这两种构造方法是一致的。<br>其次，对于这种构造方法，编译器会先尝试用<code>A(std::initializer_list&lt;int&gt; l)</code>去匹配，如果不成功，则会尝试<code>A(int)</code>，如果这两种构造函数都未定义，就会编译报错。<br>另外，成员变量也可以采用就地初始化, 虽然这会导致类成为非聚合类，但并不妨碍其采用列表初始化方法。使用虚函数，有基类的效果都是一样的，不影响列表初始化方法的使用。<h2 id=\"C-11中的几种初始化方法\"><a href=\"#C-11中的几种初始化方法\" class=\"headerlink\" title=\"C++11中的几种初始化方法\"></a>C++11中的几种初始化方法</h2></li>\n<li>就地初始化<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a1 &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> a2 = &#123;<span class=\"number\">12.0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> a3 = <span class=\"number\">12.0</span></span><br><span class=\"line\">        B b&#123;<span class=\"number\">123</span>&#125;</span><br><span class=\"line\">        C c = &#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>构造函数初始化列表<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">A</span>() : <span class=\"built_in\">a</span>(<span class=\"number\">123</span>), <span class=\"built_in\">b</span>(<span class=\"number\">456</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>列表初始化<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) &#123;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先匹配A(std::initializer_list&lt;int, int&gt;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 再匹配A(int, int)</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则报错</span></span><br><span class=\"line\">    A a &#123;<span class=\"number\">123</span>, <span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>就地初始化会最先得到执行，构造函数初始化列表会覆盖就地初始化的值</li>\n<li>如果采用初始化列表，即<code>a&#123;...&#125;</code>初始化，<code>std::initializer_list&lt;T&gt;</code>的构造函数会优先得到执行</li>\n<li>如果采用原生构造函数，即<code>a(int)</code>初始化，<code>A(init)</code>优先得到执行<h1 id=\"什么是initializer-list\"><a href=\"#什么是initializer-list\" class=\"headerlink\" title=\"什么是initializer-list\"></a>什么是initializer-list</h1><strong>摘录<a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a></strong>-初始化列表</li>\n</ul>\n<ol>\n<li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的一些概念。 </li>\n<li>initialzer-list<T>来说，它可以接受任意长度的初始化列表，但是元素必须是要相同的或者可以转换为T类型的。  </T></li>\n<li>三个成员接口，begin(),end(),size(),其中size()返回initialzer-list的长度。  </li>\n<li>能被整体的初始化和赋值，遍历只能通过begin和end迭代器来，遍历取得的数据是可读的，是不能对单个进行修改的。  </li>\n</ol>\n</blockquote>\n<p>注意一：<br>initialzer-list<T>保存的是T类型的引用，并不对T类型的数据进行拷贝，因此需要注意变量的生存期</T></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::initializer_list&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123; <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> c = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = c.<span class=\"built_in\">begin</span>(); it != c.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; it - c.<span class=\"built_in\">begin</span>() &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; (*it) &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处打印是乱的。因为func返回的是右值引用，在退出函数后失效。</p>\n<p>注意二：<br>列表初始化防止类型收窄<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1.1</span>; <span class=\"comment\">//OK</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b&#123; <span class=\"number\">1.1</span> &#125;; <span class=\"comment\">//error</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">float</span> f1 = <span class=\"number\">1e40</span>; <span class=\"comment\">//OK, 科学计数法10^40</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> f2&#123; <span class=\"number\">1e40</span> &#125;; <span class=\"comment\">//error</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x = <span class=\"number\">1024</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c = x; <span class=\"comment\">//OK</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> d&#123; x &#125;;<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> e = y;<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> f&#123; y &#125;;<span class=\"comment\">//error</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://en.cppreference.com/w/cpp/utility/initializer_list\">initializer_list - cppreference.com</a><br><a href=\"https://blog.csdn.net/hailong0715/article/details/54018002\">C++11新特性之列表初始化</a><br><a href=\"https://blog.csdn.net/JinhuCheng/article/details/107330983\">C++11新特性之列表初始化、POD、聚合类</a></p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B&POD/",
            "title": "聚合类型&POD",
            "date_published": "2021-09-18T14:03:05.792Z",
            "content_html": "<h1 id=\"什么是聚合类型\"><a href=\"#什么是聚合类型\" class=\"headerlink\" title=\"什么是聚合类型\"></a>什么是聚合类型</h1><blockquote>\n<p><strong>C++03定义</strong><br>An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).</p>\n<p><strong>C++11定义</strong><br>An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>结合C++03和C++11标准定义，罗列一下聚合类型的特性：</p>\n<ul>\n<li>聚合类型可以有构造函数，但只能是编译器定义的默认构造函数，或者用<code>=default</code>定义的构造函数</li>\n<li>聚合类型不能有private，protected非static变量</li>\n<li>聚合类型可以有copy-assignment operator and/or destructor</li>\n<li>数组是聚合类型，即便数组成员是非聚合类型</li>\n<li>聚合类型的数组可以是非聚合类型</li>\n<li>聚合类型不能用brace-or-equal-initializers（即就地初始化）初始化非static成员。</li>\n</ul>\n<h2 id=\"聚合类型变量初始化\"><a href=\"#聚合类型变量初始化\" class=\"headerlink\" title=\"聚合类型变量初始化\"></a>聚合类型变量初始化</h2><p>聚合类型可以采用列表初始化（其实非聚合类型，通过自定义构造函数，也可以采用列表初始化）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(m == n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the ith element of the array is initialized with ai</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the first m elements of the array are initialized with a1,  a2, …, am and the other n - m elements are, if possible, value-initialized (see below for the explanation of the term)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m &gt; n) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the compiler will issue an error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"comment\">/*(this is the case when n isn&#x27;t specified at all like int a[] = &#123;1, 2, 3&#125;;) */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the size of the array (n) is assumed to be equal to m, so int a[] = &#123;1, 2, 3&#125;; is equivalent to int a[3] = &#123;1, 2, 3&#125;;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>聚合变量最大的特点可以做<strong>聚合初始化</strong>，除了基本的列表初始化规则，聚合初始化还体现在可以递归初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i1;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Y</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"keyword\">float</span> f; </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> d;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>&#123;&#125;      </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Z</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">  X x;</span><br><span class=\"line\">  <span class=\"built_in\">Z</span>(<span class=\"keyword\">char</span> a1) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y y = &#123;<span class=\"string\">&#x27;a&#x27;</span>, &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;, &#123;<span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><br><code>y.x</code>也被初始化了。如果对Z用递归聚合初始化，例如<code>Z z = &#123;&#39;a&#39;, &#123;&#39;b&#39;&#125;&#125;</code>，编译器就会报错。因为Z不是聚合类型，编译器会去找对应的构造函数，显然Z没定义这样的构造函数。<br>具体介绍可以参考<a href=\"https://en.cppreference.com/w/cpp/language/aggregate_initialization\">Aggregate initialization</a>。</p>\n<h1 id=\"什么是POD变量\"><a href=\"#什么是POD变量\" class=\"headerlink\" title=\"什么是POD变量\"></a>什么是POD变量</h1><p>POD = Plain Old Data，可见这是一种兼容型比较好的形态。甚至可以导出与其他语言共享此类变量定义。</p>\n<blockquote>\n<p><strong>C++03定义</strong><br>A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.</p>\n<p>C++11定义变得非常优雅<br><strong>A POD struct is a non-union class that is both a trivial class and a standard-layout class</strong>, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>总而言之：<br>POD类型是一种特殊的聚合类型，一个POD类型为：</p>\n<ul>\n<li>标量类型。</li>\n<li>满足以下条件的自定义类型：<ul>\n<li>C++11之前：<ul>\n<li>聚合类型。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n<li>没有引用类型的非静态成员变量。</li>\n<li>没有自定义的构造函数或析构函数。</li>\n</ul>\n</li>\n<li>C++11之后：<ul>\n<li>是平凡类。</li>\n<li>是标准布局类。</li>\n<li>没有非POD类型的非静态成员变量。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>POD类型的数组。</li>\n</ul>\n<h1 id=\"聚合类型或是POD变量有什么好处？\"><a href=\"#聚合类型或是POD变量有什么好处？\" class=\"headerlink\" title=\"聚合类型或是POD变量有什么好处？\"></a>聚合类型或是POD变量有什么好处？</h1><p>聚合类最大的特点就是可以采用聚合初始化。<br>POD的特点更为实用一些</p>\n<blockquote>\n<p><strong>POD的用途</strong><br>平凡类的用途：</p>\n<ul>\n<li>平凡类的对象可以与字节流之间安全转换，即：<ul>\n<li>若要将对象转为字节流，直接取其地址即可。</li>\n<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>\n<li>直接通过复制字节的方式复制对象。</li>\n</ul>\n</li>\n<li>安全的静态初始化。<ul>\n<li>C++11的thread_local变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的__thread只能使用POD类型。</li>\n</ul>\n</li>\n</ul>\n<p><strong>标准布局类的用途：</strong><br>跨进程、跨语言使用。</p>\n</blockquote>\n<h1 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h1><h2 id=\"value-initialization\"><a href=\"#value-initialization\" class=\"headerlink\" title=\"value initialization\"></a>value initialization</h2><ul>\n<li>对于普通类型变量(bool, int, char, double, pointers, etc.)<br>it means it is initialized with 0 for that type (false for bool, 0.0 for double, etc.). </li>\n<li>对于class类型<ul>\n<li>如果有自定义构造函数，则调用自定义构造函数</li>\n<li>如果没有自定一构造函数，则调用默认构造函数</li>\n<li>如果没有对应的构造函数，则报错</li>\n</ul>\n</li>\n</ul>\n<p>举例<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span>) &#123;&#125; <span class=\"comment\">//no default constructor</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">B</span>() &#123;&#125; <span class=\"comment\">//default constructor available</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  A a1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>), <span class=\"built_in\">A</span>(<span class=\"number\">1</span>), <span class=\"built_in\">A</span>(<span class=\"number\">14</span>)&#125;; <span class=\"comment\">//OK n == m</span></span><br><span class=\"line\">  A a2[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">2</span>)&#125;; <span class=\"comment\">//ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]</span></span><br><span class=\"line\">  B b1[<span class=\"number\">3</span>] = &#123;<span class=\"built_in\">B</span>()&#125;; <span class=\"comment\">//OK b1[1] and b1[2] are value initialized, in this case with the default-ctor</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array1[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//All elements are initialized with 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array2[<span class=\"number\">1000</span>] = &#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">//Attention: only the first element is 1, the rest are 0;</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> Array3[<span class=\"number\">1000</span>] = &#123;&#125;; <span class=\"comment\">//the braces can be empty too. All elements initialized with false</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> Array4[<span class=\"number\">1000</span>]; <span class=\"comment\">//no initializer. This is different from an empty &#123;&#125; initializer in that</span></span><br><span class=\"line\">  <span class=\"comment\">//the elements in this case are not value-initialized, but have indeterminate values </span></span><br><span class=\"line\">  <span class=\"comment\">//(unless, of course, Array4 is a global array)</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> array[<span class=\"number\">2</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;; <span class=\"comment\">//ERROR, too many initializers</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>大括号中个数不足的，用value initialization补足。这就是<code>A a = &#123;1&#125;;</code>或者<code>A a = &#123;&#125;</code>的含义。大括号中个数超过声明的个数的，则编译报错。</p>\n<h2 id=\"brace-or-equal-initializers\"><a href=\"#brace-or-equal-initializers\" class=\"headerlink\" title=\"brace-or-equal-initializers\"></a>brace-or-equal-initializers</h2><p>类成员的一种初始化方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"keyword\">int</span>)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b &#123;<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    B c &#123;<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">    B d = &#123;<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copy-assignment-operator\"><a href=\"#copy-assignment-operator\" class=\"headerlink\" title=\"copy-assignment operator\"></a>copy-assignment operator</h2><p>拷贝赋值方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\">A <span class=\"title\">A</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">const</span> &amp;) &#123;&#125;</span><br><span class=\"line\">    A&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> A&amp;a) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    A b = a; <span class=\"comment\">// 这里调用的是拷贝构造函数</span></span><br><span class=\"line\">    A c;</span><br><span class=\"line\">    c = a; <span class=\"comment\">// 这里才会调用拷贝复制函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"trial-stuff\"><a href=\"#trial-stuff\" class=\"headerlink\" title=\"trial stuff\"></a>trial stuff</h2><h3 id=\"trivial-copyable\"><a href=\"#trivial-copyable\" class=\"headerlink\" title=\"trivial copyable\"></a>trivial copyable</h3><p>参考<a href=\"https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable\">C++ named requirements: TriviallyCopyable</a></p>\n<blockquote>\n<p>The following types are collectively called trivially copyable types:</p>\n<ul>\n<li>Scalar types</li>\n<li>Trivially copyable classes, i.e. classes satisfying following requirements:<ul>\n<li>At least one copy constructor, move constructor, copy assignment operator, or move assignment operator is eligible</li>\n<li>Every eligible copy constructor (if any) is trivial</li>\n<li>Every eligible move constructor (if any) is trivial</li>\n<li>Every eligible copy assignment operator (if any) is trivial</li>\n<li>Every eligible move assignment operator (if any) is trivial</li>\n<li>Has a trivial non-deleted destructor</li>\n</ul>\n</li>\n<li>Arrays of TriviallyCopyable objects</li>\n</ul>\n<p>This implies that a trivially copyable class has no virtual functions or virtual base classes.</p>\n</blockquote>\n<p>通过模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivially_copyable\">std::is_trivially_copyable</a>可以检验一个类是否trivially copyable。</p>\n<h3 id=\"trivial-constructor-destructor\"><a href=\"#trivial-constructor-destructor\" class=\"headerlink\" title=\"trivial constructor/destructor\"></a>trivial constructor/destructor</h3><ul>\n<li>编译器定义的构造/析构函数</li>\n<li>用<code>=default</code>定义的构造析构函数<h3 id=\"trivial-class\"><a href=\"#trivial-class\" class=\"headerlink\" title=\"trivial class\"></a>trivial class</h3>The standard defines a trivial class as follows:</li>\n</ul>\n<p>A trivially copyable class is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n<p>A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n<p>[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes. ]<br>另外trivial class是递归的，即trivial class不能有非trivial class的非static成员。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_trivial\">std::is_trivial</a>来测试</p>\n<h2 id=\"standard-layout\"><a href=\"#standard-layout\" class=\"headerlink\" title=\"standard layout\"></a>standard layout</h2><p>A standard-layout class is a class that:</p>\n<ul>\n<li><p>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p>\n</li>\n<li><p>has no virtual functions (10.3) and no virtual base classes (10.1),</p>\n</li>\n<li><p>has the same access control (Clause 11) for all non-static data members,</p>\n</li>\n<li><p>has no non-standard-layout base classes,</p>\n</li>\n<li><p>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, (要么终点类没有非静态成员，并且只有一个基类有非静态成员；要么没有基类有非静态成员)，and</p>\n</li>\n<li><p>has no base classes of the same type as the first non-static data member.</p>\n</li>\n</ul>\n<p>A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.</p>\n<p>A standard-layout union is a standard-layout class defined with the class-key union.</p>\n<p>[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.]</p>\n<p>标准内存分布，确保对象内存和C语言的结构体内存分布完全一致。使得POD变量具备了C兼容性。<br>用模版<a href=\"https://en.cppreference.com/w/cpp/types/is_standard_layout\">std::is_standard_layout</a>可以测试</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>用<a href=\"https://en.cppreference.com/w/cpp/types/is_pod\">std::is_pod</a>来测试你的类吧。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">What are Aggregates and PODs and how/why are they special?</a></li>\n<li><a href=\"https://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/\">C++对象模型（三）POD</a></li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/12/obsidian_posts/setcap%20vs.%20LD_PRELOAD/",
            "url": "https://blog.zhougy.top/2021/09/12/obsidian_posts/setcap%20vs.%20LD_PRELOAD/",
            "title": "setcap vs. LD_PRELOAD",
            "date_published": "2021-09-12T06:29:34.553Z",
            "content_html": "<p>在Linux中，一个进程拉起另一个进程的流程大致如下：</p>\n<p><pre class=\"mermaid\">graph LR;\nF[parent process] --> A[start]\nA --fork--> B[child]\nA --> C[wait]\nB --exec--> D[new process]\nD --> E[end]\nC --> E</pre><br>最常见的就是通过shell终端执行命令。此场景下，/bin/bash就是这个parent process，而要执行的那个命令就是new process。<br>Linux有一些特性，可以使得创建出的进程比拉起的进程权限高。例如可执行文件配置了set-user-ID位，则拉起的进程就是root权限，而其父进程有可能是普通用户权限。如果可执行文件配置了file capability，则创建出的进程就具备了某些capability，如果父进程没有这些capability，则这也是一种权限放大的场景。<br>当发生这种权限放大的场景时，Linux的安全特性要求，此时子进程中的某些敏感环境变量会被清空，例如：LD_PRELOAD,LD_LIBRARY_PATH。由于这些环境变量都是从父进程继承过来的，如果不清空，则表明会使用高权限级别执行这些环境变量指定的可执行代码。</p>\n<h1 id=\"LD-LIBRARY-PATH\"><a href=\"#LD-LIBRARY-PATH\" class=\"headerlink\" title=\"LD_LIBRARY_PATH\"></a>LD_LIBRARY_PATH</h1><p>参考文献[1]，ld.so搜索动态库的顺序如下：</p>\n<ol>\n<li>DT_PATH指定的库文件（deprecated）</li>\n<li>LD_LIBRARY_PATH指定的库文件</li>\n<li>DT_RUNPATH指定的库文件</li>\n<li>/etc/ld.so.cache这个二进制文件指定的库文件，该文件通过ldconfig命令生成</li>\n<li>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</li>\n</ol>\n<p>所以针对LD_LIBRARY_PATH，除了第二条的方法失效，其他的都可以用。</p>\n<h1 id=\"LD-PRELOAD\"><a href=\"#LD-PRELOAD\" class=\"headerlink\" title=\"LD_PRELOAD\"></a>LD_PRELOAD</h1><p>那针对LD_PRELOAD，是不是就没法用呢？其实也不是。<br>在没有setcap以及set-user-ID的情况下，如果ld.so需要预加载一个库文件，指定方法在文献[1]中同样有描述：</p>\n<ol>\n<li>The <code>LD_PRELOAD</code> environment variable.</li>\n<li>The <code>--preload</code> command-line option when invoking the dynamic linker directly.</li>\n<li>The <code>/etc/ld.so.preload</code> file.</li>\n</ol>\n<p>在secure-execution模式下，方法2和方法3均不受影响。方法1也仍然可以使用。但是需要一些特殊的设置，在[1]中也有描述。</p>\n<blockquote>\n<p>In secure-execution mode, <strong>preload pathnames containing slashes are ignored</strong>.  Furthermore, shared objects are preloaded <strong>only from the standard search directories</strong> and only if <strong>they have set-user-ID mode bit enabled</strong> (which is not typical).</p>\n</blockquote>\n<p>综上，需要3点配置：</p>\n<ul>\n<li>LD_PRELOAD环境变量指定的库文件不能包含斜线’/‘</li>\n<li>库文件只会从标准路径下加载。这里标准路径可以参考LD_LIBRARY_PATH中的描述。注意，此时ld.so只会搜索标准路径，不会搜索通过其他手段配置的路径（如上一节描述的）。</li>\n<li>库文件必须使能了set-user-id位</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>代码目录树：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ tree .</span><br><span class=\"line\">.</span><br><span class=\"line\">├── lib.c</span><br><span class=\"line\">├── libtest.so</span><br><span class=\"line\">├── main</span><br><span class=\"line\">├── main.c</span><br><span class=\"line\">├── test</span><br><span class=\"line\">└── test.c</span><br></pre></td></tr></table></figure><br>main.c生成main可执行程序，test.c生成test可执行程序，lib.c生成libtest.so。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">pid_t</span> pid = fork();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *envp[] = &#123;</span><br><span class=\"line\">                        <span class=\"string\">&quot;LD_PRELOAD=libtest.so&quot;</span>,</span><br><span class=\"line\">                        <span class=\"comment\">// &quot;LD_PRELOAD=./libtest.so&quot;,</span></span><br><span class=\"line\">                        <span class=\"literal\">NULL</span></span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *argv[] = &#123;</span><br><span class=\"line\">                        <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">                        <span class=\"literal\">NULL</span></span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> err = execve(<span class=\"string\">&quot;./test&quot;</span>, argv, envp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">                wait(&amp;status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *preload = getenv(<span class=\"string\">&quot;LD_PRELOAD&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;LD_PRELOAD = %s\\n&quot;</span>, preload);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> __<span class=\"title\">attribute__</span><span class=\"params\">((constructor))</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;m libtest.so loaded\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在test可执行程序是普通的二进制时，输出为<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">I&#x27;m libtest.so loaded</span><br><span class=\"line\">LD_PRELOAD = ./libtest.so</span><br></pre></td></tr></table></figure><br>当test配置了capability以后：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ sudo setcap cap_net_admin,cap_net_raw=eip ./test</span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>可见LD_PRELOAD指定libtest.so未被加载，且LD_PRELOAD环境变量被清空了。</p>\n<h2 id=\"LD-PRELOAD不含斜线\"><a href=\"#LD-PRELOAD不含斜线\" class=\"headerlink\" title=\"LD_PRELOAD不含斜线\"></a>LD_PRELOAD不含斜线</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure>\n<p>LD_PRELOAD仍然被清空了，但ld.so似乎尝试去加载libtest.so了，但是没找着。</p>\n<h2 id=\"将libtest-so放入标准路径\"><a href=\"#将libtest-so放入标准路径\" class=\"headerlink\" title=\"将libtest.so放入标准路径\"></a>将libtest.so放入标准路径</h2><p>如果没有配置set-user-id位：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>仍然提示找不到。如果设置了set-user-id位：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ sudo chmod a+s /usr/lib64/libtest.so </span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">I&#x27;m libtest.so loaded</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>在满足上一节提到的3个条件时，libteso.so就可以正常加载了。<br>看看如果放到/usr/lib下面会怎么样？<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost test]$ ls /usr/lib/libtest.so -l</span><br><span class=\"line\">-rwsr-sr-x. 1 root root 8208 1月  24 19:48 /usr/lib/libtest.so</span><br><span class=\"line\">[ben@localhost test]$ ./main</span><br><span class=\"line\">ERROR: ld.so: object &#x27;libtest.so&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class=\"line\">LD_PRELOAD = (null)</span><br></pre></td></tr></table></figure><br>看看还是一样找不到。可见在x64平台上，/usr/lib并非标准路径，而/usr/lib64以及/lib64才是。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://man7.org/linux/man-pages/man8/ld.so.8.html\">ld.so(8) — Linux manual page</a><br>[2] <a href=\"https://stackoverflow.com/questions/18058426/does-using-linux-capabilities-disables-ld-preload\">Stackoverflow - Does using linux capabilities disables LD_PRELOAD</a></p>\n",
            "tags": [
                "Linux",
                "capability",
                "LD_PRELOAD"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "url": "https://blog.zhougy.top/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "title": "详解SELinux SID",
            "date_published": "2021-09-12T06:26:36.976Z",
            "content_html": "<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p>SID = Security Identifier (即Security ID)。其作用就是取代安全上下文，在权限匹配时，提升规则搜索速度，以及降低整个策略数据的空间复杂度，提升了整个SELinux特性的性能损耗。<br>例如一次权限匹配的函数调用原型如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_has_perm</span><span class=\"params\">(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t u32 requested, struct common_audit_data *auditdata)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>其中ssid, tsid就代表了源(source)SID和目的(target)SID。在最终的av(access vector)计算中，SID被转化为context。</p>\n<blockquote>\n<p>什么是context？<br>context，即安全上下文，是SELinux的核心概念。形如<code>user_u:role_r:type_t:s0-s1:c0,c1-c255</code>的就是context。其中user字段和role字段用于RBAC，type字段用于TEAC，后面的s0-s1,c1-c255用于mls/mcs。而所有的这些字段，都由策略编译工具生成了整数数据，在SELinux加载策略时一并加载到内存policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// context定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// context加载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">context_read_and_validate</span><span class=\"params\">(struct context *c,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     struct policydb *p,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     <span class=\"keyword\">void</span> *fp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    c-&gt;user = le32_to_cpu(buf[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    c-&gt;role = le32_to_cpu(buf[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    c-&gt;type = le32_to_cpu(buf[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>在真正的权限匹配时，SELinux通过SID获取到对应的context，再通过context中的type属性，所搜policydb中相应的hash表找到对应的map array，并获取对应某个权限的一个bit位，来得到权限判定结果。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 搜索sidtab获取SID对应的context，并用context数据结构来计算权限</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    scontext = sidtab_search(sidtab, ssid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    tcontext = sidtab_search(sidtab, tsid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    context_struct_compute_av(policydb, scontext, tcontext, tclass, avd,</span><br><span class=\"line\">\t\t\t\t  xperms);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过context的type字段从policydb中获取权限数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">context_struct_compute_av</span><span class=\"params\">(struct policydb *policydb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *scontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *tcontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   scontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    tattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   tcontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    ebitmap_for_each_positive_bit(sattr, snode, i) &#123;</span><br><span class=\"line\">        ebitmap_for_each_positive_bit(tattr, tnode, j) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (node = avtab_search_node(&amp;policydb-&gt;te_avtab,</span><br><span class=\"line\">                              &amp;avkey);</span><br><span class=\"line\">                 node;</span><br><span class=\"line\">                 node = avtab_search_node_next(node, avkey.specified)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Get and assign perm data</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"initial-SID\"><a href=\"#initial-SID\" class=\"headerlink\" title=\"initial SID\"></a>initial SID</h1><p>initial SID是一种比较特殊的SID。他在策略编译和SELinux启动中都扮演了非常重要的角色。通常在编译policy的时候，需要一些flask文件，例如Fedora refpolicy：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> ls refpolicy-master/policy/flask/</span></span><br><span class=\"line\">access_vectors   initial_sids     security_classes</span><br></pre></td></tr></table></figure>\n<p>其中initial_sids就指定了policy二进制中所有的initial SID。内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># FLASK</span><br><span class=\"line\"></span><br><span class=\"line\">#</span><br><span class=\"line\"># Define initial security identifiers</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\">sid kernel</span><br><span class=\"line\">sid security</span><br><span class=\"line\">sid unlabeled</span><br><span class=\"line\">sid fs</span><br><span class=\"line\">sid file</span><br><span class=\"line\">sid file_labels</span><br><span class=\"line\">sid init</span><br><span class=\"line\">sid any_socket</span><br><span class=\"line\">sid port</span><br><span class=\"line\">sid netif</span><br><span class=\"line\">sid netmsg</span><br><span class=\"line\">sid node</span><br><span class=\"line\">sid igmp_packet</span><br><span class=\"line\">sid icmp_socket</span><br><span class=\"line\">sid tcp_socket</span><br><span class=\"line\">sid sysctl_modprobe</span><br><span class=\"line\">sid sysctl</span><br><span class=\"line\">sid sysctl_fs</span><br><span class=\"line\">sid sysctl_kernel</span><br><span class=\"line\">sid sysctl_net</span><br><span class=\"line\">sid sysctl_net_unix</span><br><span class=\"line\">sid sysctl_vm</span><br><span class=\"line\">sid sysctl_dev</span><br><span class=\"line\">sid kmod</span><br><span class=\"line\">sid policy</span><br><span class=\"line\">sid scmp_packet</span><br><span class=\"line\">sid devnull</span><br><span class=\"line\"></span><br><span class=\"line\"># FLASK</span><br></pre></td></tr></table></figure>\n<p>参考《Building The Sample Policy》中的介绍，这些flask文件的内容将被写到最终的policy二进制文件中（即policy.conf),如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notebook-tools/build-sepolicy -o policy.conf -d ../../flask-files</span><br></pre></td></tr></table></figure><br>build-sepolicy是一个python的示例程序，他是这样处理flask文件的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    f = Flask()</span><br><span class=\"line\">    f.parseSids(flask_dir + <span class=\"string\">&quot;/initial_sids&quot;</span>)</span><br><span class=\"line\">    f.parseClasses(flask_dir + <span class=\"string\">&quot;/security_classes&quot;</span>)</span><br><span class=\"line\">    f.parseVectors(flask_dir + <span class=\"string\">&quot;/access_vectors&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Open the file and then create the requested policy source file</span></span><br><span class=\"line\">    of = <span class=\"built_in\">open</span>(outf, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> include == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicyHdr(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output header file&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> cil == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL policy&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> class_perm == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilClassPerms(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL class permission sets&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> sids == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilInitialSIDS(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL initial SIDs&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output Kernel Language policy&quot;</span>)</span><br><span class=\"line\">    of.close()</span><br></pre></td></tr></table></figure><br>可见这些文件的内容，被写入到一个Flask对象中，而该对象的内容最终会被写入策略二进制数据。在后续的策略编译中，这些文件会被checkpolicy来处理。</p>\n<blockquote>\n<p><strong>initial SID的作用</strong><br><em>from “SELinux by Example: Using Security Enhanced Linux”</em><br>Some objects are labeled via an initial SID early in system initialization, <strong><em>even before the policy is loaded</em></strong>. This labeling behavior is needed, for example, to label objects such as the kernel security server and the root filesystem, which are present in the system before the first policy load. <strong><em>When the policy is eventually loaded, the initial SIDs are then associated with the appropriate security context</em></strong>.<br><strong><em>Initial SIDs are also used to prevent objects from having a missing or invalid security context, which would make it impossible for SELinux to correctly enforce access</em></strong>. Instead, SELinux associates these objects with the special unlabeled initial SID. The unlabeled initial SID should have a security context that allows only limited access, thereby preventing inappropriate access until the objects can be relabeled by the administrator or destroyed.<br>Invalid security contexts most commonly result from loading a new policy that removes users, roles, or types, or changes role or type authorizations. In this situation, the <strong><em>SIDs representing security contexts that use these invalid names or associations will become invalid and are mapped to the unlabeled SID at policy load</em></strong>. Invalid security contexts can also arise when transferring object instances between systems (for example, using removable media). Further, if the objects are created on a non-SELinux system, they will have no associated security context. Regardless of whether the security context is invalid or missing, SELinux will use the unlabeled initial SID on first access to the object as the security context.</p>\n</blockquote>\n<p>总结一下，一共有这几点：</p>\n<ul>\n<li>系统启动时，policy尚未加载，也就是所有的context还没被抽象成SID，存储在内存中的policydb里。allow规则也还没加载，这时候，为了保证代码归一，所以需要这些unlabeled SID，在SELinux启动流程中，再具体介绍。</li>\n<li>当系统策略变化时，有些role，user或type被删除，导致一些安全上下文失效了，此时这些安全上下文，在策略加载时，会被映射到这些initial SID上。（这里还没找到具体的代码位置）</li>\n</ul>\n<h2 id=\"启动时的使用\"><a href=\"#启动时的使用\" class=\"headerlink\" title=\"启动时的使用\"></a>启动时的使用</h2><p>init进程在加载策略之前，首先将SELinux的enforcing模式打开。其打开的方式就是往selinuxfs的enforce文件写1。注意此时策略未加载，初始化也未完成。所以策略判断直接取allow。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!state-&gt;initialized)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> allow;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">allow:</span><br><span class=\"line\">\tavd-&gt;allowed = <span class=\"number\">0xffffffff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但由于用户态的入口是一致的，即启动完成后，用户态可以写同样的enforce文件完成SELinux状态的切换，所以为了判断此时用户态进程是否具有设置的权限，在enforce文件的入口处，对用户态进程权限进行了判定：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length = avc_has_perm(&amp;selinux_state,</span><br><span class=\"line\">                  current_sid(), SECINITSID_SECURITY,</span><br><span class=\"line\">                  SECCLASS_SECURITY, SECURITY__SETENFORCE,</span><br><span class=\"line\">                  <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure><br>这里就用到了initial SID - <code>SECINITSID_SECURITY</code>。这里其实已经可以使用selinuxfs的inode.i_security.sid，但由于selinuxfs未通过系统的file open调用，所以无法使用到inode下的SID标签。</p>\n<h2 id=\"系统标签无效时\"><a href=\"#系统标签无效时\" class=\"headerlink\" title=\"系统标签无效时\"></a>系统标签无效时</h2><p>以socket bind时，对IP地址进行权限判断为例。该权限判断流程大致如下：</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"selinux_socket_bind\"]\nA --> B[\"sock_has_perm(SOCKET__BIND)\"]\nB --> C[\"get nodecon sid by sel_netnode_sid\"]\nC --> D[\"av_has_perm\"]</pre><br><code>security_node_sid</code>会从<code>policydb-&gt;ocontexts[OCON_NODE]</code>中搜索policydb中关于该IP地址的nodecon定义，如果找不着，说明此IP相关的nodecon无效（未定义），则会走默认的initial SID。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c-&gt;sid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        rc = sidtab_context_to_sid(sidtab,</span><br><span class=\"line\">                       &amp;c-&gt;context[<span class=\"number\">0</span>],</span><br><span class=\"line\">                       &amp;c-&gt;sid[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rc)</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *out_sid = c-&gt;sid[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    *out_sid = SECINITSID_NODE; <span class=\"comment\">// &lt;===== intial SID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"其他SID\"><a href=\"#其他SID\" class=\"headerlink\" title=\"其他SID\"></a>其他SID</h1><p>除了initial SID由内核直接加载生成，其他的SID则由对应的打标签流程生成。例如：文件的SID则由setfiles/restorecon工具打入文件系统的扩展属性上，socket则由socket系统调用创建时生成。<br>以socket bind为例，因为比较简单。当socket bind系统调用被执行时，一个socket object被绑定到一个node上。而此时该node的SID才被写入policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sel_netnode_sid</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, u16 family, u32 *sid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sel_netnode</span> *<span class=\"title\">node</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_read_lock();</span><br><span class=\"line\">\tnode = sel_netnode_find(addr, family);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t*sid = node-&gt;nsec.sid;</span><br><span class=\"line\">\t\trcu_read_unlock();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trcu_read_unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sel_netnode_sid_slow(addr, family, sid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>sel_netnode_sid_slow</code>调用<code>security_node_sid</code>,并最终调用<code>sidtab_context_to_sid</code>将相关的SID以及对应的context数据结构插入到表中。</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"security_node_sid\"]\nA --> B[\"search policydb->ocontexts[OCON_NODE]\"]\nB --> C{\"find?\"}\nC --> |N| B\nC --> |Y| D[\"sidtab_context_to_sid(context，&sid)\"]\nD --> E(\"end\")\nC --> |Never find| F[\"set an initial SID\"]\nF --> E</pre></p>\n<ul>\n<li><code>security_node_sid</code>使用传入的IP地址在policydb中匹配查找context，如果找到则进行下一步，匹配或生成SID，找不到，则直接使用initial SID。</li>\n<li><code>sidtab_context_to_sid</code>将context写入sidtab，并获取返回的SID记入policydb中，后续通过context找SID，直接匹配<code>policydb-&gt;ocontexts[OCON_NODE];</code>即可。对于SID本身的生成也很简单，就是一个单向增长的整形数字，在<code>sidtab_context_to_sid</code>中。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sid = sidtab_search_context(s, context);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sid)</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> unlock_out;</span><br><span class=\"line\">...</span><br><span class=\"line\">sid = s-&gt;next_sid++;</span><br><span class=\"line\">..</span><br><span class=\"line\">ret = sidtab_insert(s, sid, context);</span><br></pre></td></tr></table></figure>\n先尝试在sidtab中查找，如果找不到就加一条记录，并为sid赋值。<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>SID在整个SELinux子系统中的作用就是提升匹配性能（从安全上下文的字符串匹配，降低到整数匹配）,所以在整个SELinux子系统生命周期内，SID总是与安全上下文（context）一一对应的。在一次权限匹配过程中，SID的使用如下：<br><img src=\"/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/948A5192-E302-40F3-9A2D-D3C2D5B2FF75.png\" alt=\"7fe0cdf2b84938b1e0610fe99bd3c917\"><br>context和SID的定义分别为：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u32 sid;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1>没有一个专门的工具用来转换SID与context。但libselinux提供了相应的接口，参考<a href=\"https://linux.die.net/man/3/sidget\">sidget(3) - Linux man page</a>。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_context_to_sid</span><span class=\"params\">(<span class=\"keyword\">security_context_t</span> ctx, <span class=\"keyword\">security_id_t</span> *sid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_sid_to_context</span><span class=\"params\">(<span class=\"keyword\">security_id_t</span> sid, <span class=\"keyword\">security_context_t</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"seinfo\"><a href=\"#seinfo\" class=\"headerlink\" title=\"seinfo\"></a>seinfo</h2></li>\n</ul>\n<ol>\n<li>打印所有initial SID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --initialsid</span><br><span class=\"line\"></span><br><span class=\"line\">Initial SIDs: 27</span><br><span class=\"line\">   any_socket</span><br><span class=\"line\">   devnull</span><br><span class=\"line\">   file</span><br><span class=\"line\">   file_labels</span><br><span class=\"line\">   fs</span><br><span class=\"line\">   icmp_socket</span><br><span class=\"line\">   igmp_packet</span><br><span class=\"line\">   init</span><br><span class=\"line\">   kernel</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>打印selinuxfs context<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --genfscon|grep selinux</span><br><span class=\"line\">   genfscon selinuxfs /  system_u:object_r:security_t:s0</span><br></pre></td></tr></table></figure>\n<h2 id=\"initial-contexts\"><a href=\"#initial-contexts\" class=\"headerlink\" title=\"initial_contexts\"></a>initial_contexts</h2>策略加载后，每个initial SID都有一个对应的context。这些context在各策略模块中定义。这些context在selinuxfs可以查看：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ sudo cat /sys/fs/selinux/initial_contexts/kernel</span><br><span class=\"line\">system_u:system_r:kernel_t:s0</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1></li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/fedora-selinux/selinux-policy\">Fedora refpolicy</a></li>\n<li>Frank Mayer, Karl MacMillan, David Caplan， July 27, 2006- “SELinux by Example: Using Security Enhanced Linux”</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook</a>“ Volume II, Building The Sample Policy</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook 4th Edition</a>“</li>\n</ul>\n",
            "tags": [
                "SELinux"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/08/30/obsidian_posts/%E6%88%91%E7%9A%84Code%20Review%E5%BF%83%E5%BE%97/",
            "url": "https://blog.zhougy.top/2021/08/30/obsidian_posts/%E6%88%91%E7%9A%84Code%20Review%E5%BF%83%E5%BE%97/",
            "title": "Code Review",
            "date_published": "2021-08-30T14:57:57.572Z",
            "content_html": "<p>记得某一场合，一位领导说过，这次可信变革大概率会留下两样东西，一个是committer机制，另一个是代码白盒评价。而对于committer来说，code review就是其最重要的工作。</p>\n<p>第一次接触code review还是在前公司。那时候，代码合入要请人点“ship it”。后来工具切换成了gerrit，不过code review基本上还是流于形式，和朋友圈点赞差不多。有一些比较较真的老外会给出不少意见，同事间还颇有不忿。<br>”连拼写错误也要提！“<br>”烦死了，他根本就不懂！“<br>国内的开发同学基本上是磨不开面子的，反正代码又不是我维护，就给你点个赞有啥关系。</p>\n<p>真正第一次被评审代码是初入我司的时候。那时候与隔壁部门的同事一起参与一个操作系统项目。其中一位专家在评审代码的时候非常认真。每次提交MR，该专家在评审的时候都会提一堆问题。而且，这些问题点都或多或少确实存在问题，或者存在优化的可能。或修改，或解释，或补充注释。不过，最终我的MR也并没有合入，就切换到另外一个项目去了。经过这次刻骨铭心的合作，我也算是经历了一次真正的代码评审。后来，这位专家以及和他同组的小兄弟，在我司屡次的committer评选中，斩获了数次优秀committer的殊荣。很荣幸和他们能有过一段“不太愉快”的合作经历。在之后的项目里，我也被任命为committer，我希望把这份“不愉快”原汁原味地传递下去。</p>\n<p>code review，又叫代码评审，是代码开发很必要的一环，也是代码合入的最后一环。我们通常说，问题发现得越早，修复问题花费的成本月底。code review通常就是靠看看代码，就能发现一些潜在的问题，成本是非常低的。试想代码合入之后再发现问题，会引入多少overloading——沟通，重现，定界，抓log……</p>\n<p>code review既然这么好，那为什么总做不好呢？因为大家都是职场人，磨不开面儿。通常我们看到别人做的不好的地方，都不会当面戳破。关系好的，可能私底下会提醒一下，绝大多数情况就当作视而不见。所以committer课程通常第一句话都是教大家“要敢于说不”。话是不错，不过如果没有具体怎么做，就略显空洞，缺乏实操性。好在Google提供了一份详尽的code review指南（《<a href=\"https://github.com/google/eng-practices\">google/eng-practices: Google’s Engineering Practices documentation</a>》），从提交人和评审人的角度，给出了切实的做法，值得大家阅读。</p>\n<p>下面结合我自身的一些评审经验和Google指南，从committer的角度谈一谈我的心得。</p>\n<h1 id=\"如何提出评审意见？\"><a href=\"#如何提出评审意见？\" class=\"headerlink\" title=\"如何提出评审意见？\"></a>如何提出评审意见？</h1><p>尽量保持就事论事的态度，避免采用情绪化的表达方式，例如：</p>\n<blockquote>\n<p>不好的例子: “你为什么会在这里使用线程，这样做难道会有任何好处？”</p>\n<p>好的例子: “我并没有发现这个并发模块给程序带来了多少帮助，并且还增加了<strong>程序的复杂性，因此我认为这段代码最好是用单线程而不是多线程。</strong></p>\n</blockquote>\n<p>及时的评审，也可以减少负面评论带来的“挫败感”。<br>评审人如果能够主动地与提交人进行交流探讨，接受提交人的解释，也可以很大程度避免在MR中发生键盘侠现象。</p>\n<h1 id=\"问题太多怎么办？\"><a href=\"#问题太多怎么办？\" class=\"headerlink\" title=\"问题太多怎么办？\"></a>问题太多怎么办？</h1><p>问题太多应不应该提出来？会不会得罪提交人？会不会来得及修，影响交付进度？<br>Google给出的答案是“如果确定是问题，应当尽量提出”。</p>\n<p>首先需要明确的是哪些问题需要提出来。code review并不是为了追求完美。不应当苛责提交人写出完美代码。问题解决也要顾及成本。只要保证提交的代码对原有代码有了明显的提升，且能正常工作，就应该尽快合入。识别出的问题可以等待未来修复，只要确保有合适的跟踪方式即可。</p>\n<p>其次，如果确实有问题，就应当及时提出。如果我们能够及时响应评审请求，并且避免情绪化观点，通常不太会令提交人感觉不舒服。大部分情况下，很多问题都是一些编写风格的问题，一旦修改了，后续可能就不会再出现。那么后续的代码评审速度就会变快。</p>\n<h1 id=\"code-review应当何时进行\"><a href=\"#code-review应当何时进行\" class=\"headerlink\" title=\"code review应当何时进行\"></a>code review应当何时进行</h1><p>code review应当及时，因为通常提交人需要等待评审结果，再进行下一步开发。code review拖得比较就，如果涉及大面积改动，那么后续开发代码的merge成本就会很高。可能造成团队开发配合进度受影响。所以建议code review的时间不要超过一天。</p>\n<p>code review应当及时，但如果评审人正在处理需要集中注意力的事情时，例如正在开发代码时，就不应当被打断。因为一旦被打断，那么恢复现场的时间成本就会比较高。比较合理的着手处理code review的时间是处理事情的间歇，例如：每天开始工作之前，或者吃完午餐，或者从茶水间回来……</p>\n<h1 id=\"与提交人发生意见不一致怎么办？\"><a href=\"#与提交人发生意见不一致怎么办？\" class=\"headerlink\" title=\"与提交人发生意见不一致怎么办？\"></a>与提交人发生意见不一致怎么办？</h1><p>如果你坚信有问题，应当更积极地和提交人沟通。如果最终无法说服提交人，应当以提交人的意见为准，毕竟他才是代码owner。</p>\n<h1 id=\"与项目交付节点冲突怎么办？\"><a href=\"#与项目交付节点冲突怎么办？\" class=\"headerlink\" title=\"与项目交付节点冲突怎么办？\"></a>与项目交付节点冲突怎么办？</h1><p>除了确实会引起问题的代码需要修正之外，其他的改进意见是需要权衡的，如果无法在项目交付节点之内完成，或者完成会引入很大的交付风险，那应该选择规避项目风险，并留下跟踪项，以尽快解决或优化潜在问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总而言之，还是鼓励大家多参与code review。如果你不知道怎么做，可以阅读《<a href=\"https://github.com/google/eng-practices\">google/eng-practices: Google’s Engineering Practices documentation</a>》。另外，把code review当成一种交流，一次思想碰撞，而不是一次评审。不论你是提交人，还是评审人，take it easy！</p>\n",
            "tags": [
                "code review",
                "committer"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "url": "https://blog.zhougy.top/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "title": "我眼中的单元测试",
            "date_published": "2021-08-29T09:11:09.223Z",
            "content_html": "<p>在最近的一些针对毕业生的面试中，我都会问一下他们对单元测试的理解。得到的答案无一例外都是不知道，不清楚，或是按字面意思的解释。其实，这也难怪。虽然我司可信变革对单元测试的要求越来越严苛，但真正能够理解并正确使用单元测试的同学也还是比较少的。至少在我周围是这样。</p>\n<p>想想这也正常，记得曾经刚毕业时，我根本都不知道单元测试这个名词。直到后来，以前任职的公司专门外聘了专业的机构，做了相关的培训之后，我算是认识了这个词。但彼时的理解，有点像现在我司推行的Fuzz测试。也就是，代码写好后，通过工具生成各种各样的参数，调用待测代码，从而保证代码输出质量。现在可能很多同学还是这样的思路。回过头来再审视当时的观点，不免觉得过于片面了。单元测试最重要的作用其实并不是保证代码质量，对代码质量的改进可以说是它的一个副作用。</p>\n<p>后来对于单元测试有了更深入的理解，是在阅读了下面三本书之后：</p>\n<ul>\n<li>《敏捷软件开发-原则模式与实践》 — Robert C. Martin</li>\n<li>《测试驱动开发》— Kent Beck</li>\n<li>《重构-改善既有代码的设计》— Martin Fowler</li>\n</ul>\n<p>值得一提的是这三本书的作者都是<a href=\"https://agilemanifesto.org/iso/zhchs/manifesto.html\">敏捷软件开发宣言</a>的发起者，也是<a href=\"https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B\">极限编程（Extreme Programming）</a>的践行者。书也都是高分经典著作，非常推荐给大家阅读。</p>\n<h1 id=\"单元测试提升代码信心\"><a href=\"#单元测试提升代码信心\" class=\"headerlink\" title=\"单元测试提升代码信心\"></a>单元测试提升代码信心</h1><p>现在谈谈我对单元测试的认识。在刚毕业的那一段时间，我的开发流程是这样的：</p>\n<ol>\n<li>先尝试设计，思考代码的执行流程，画一些时序图和流程图</li>\n<li>开始编程</li>\n<li>发现问题<br> 1). 如果是设计问题，导致开发不下去，那么回到步骤1<br> 2). 如果发现有更好的实现方法，那么擦掉已有的代码，回到步骤2</li>\n<li>所有问题都解决了，开发结束，开始写功能测试代码，验证特性代码。如果发现问题，重复步骤3</li>\n</ol>\n<p>这样完成整个开发循环，通常要至少半天时间。有时半天甚至一天，也没留下几行特性代码。整个开发过程不断地陷入编写和整体推翻的循环中。即便最终完成了前3步，准备开始第4步功能测试的时候，也是战战兢兢的。如果功能测试发现问题，又会陷入不停地调试，修改，推翻设计的死循环。我相信很多同学都遇到过这样的问题，并因此而感到困惑。到底该怎么摆脱这样效率低下的不断重复？</p>\n<p>现在就让我们诊断一下。通常我们做完前3步流程都会花比较久的时间。按照我的经验，一般一个新特性的开发，少则若干个小时，多则一天，甚至数天。整个流程来到第4步，我们才第一次开始测试我们的特性代码。之前顶多就是编译通过。运行测试的时候才会发现很多问题，进而反思我们的实现逻辑是否与我们开始设计时思考的逻辑相符合。编写代码，实际是将物理世界，翻译成用代码表述的，严谨的逻辑语言。而通常我们并不能一次性地完成这样的翻译。而且即便完成了，也无法避免引入bug。我们只有通过测试不断地完成负反馈，来验证我们的代码，找到错误，最终收敛成正确的代码逻辑，从而完成现实世界到代码逻辑的翻译工作。软件的迭代开发，就像控制系统一样，测试就如控制系统中的负反馈，如果没有负反馈的，控制系统是无法达到稳定收敛的。</p>\n<p>由于我们前面的步骤过于依赖功能测试，所以需要我们等很久，也就是功能代码编写完以后，才可以进行第一次测试。由于功能测试与特性逻辑相关，其运行花费的时间往往很久。用例要覆盖端到端功能，测试逻辑也比较复杂，写起来也比较耗时。这几点从本质上就会限制功能测试的运行次数。功能测试虽然能发现，且擅长发现代码逻辑问题，但开发和执行成本高，导致运行的次数不会太多。测试运行次数少，导致我们不知道我们自己写出来的特性逻辑是否真实地反映了我们的设计。那么这就会影响我们对代码的信心。所以，在进行第4步功能测试之前，我们总是战战兢兢的。</p>\n<p>我们等不及到所有特性代码开发完成再进行测试。因为通过昂贵的功能测试来试错发现问题，返工所花费的成本太高了。所以，我们需要一种针对小逻辑的（这样单case复杂度更低，有利于测试case之间的解耦），覆盖率高（通过mock依赖实现），运行快速的（方便不断运行）测试。于是，单元测试就应运而生了。为了编写单元测试，我们首先会把大的特性分解成小的模块；其次，通过编写单元测试，我们会不断地思考代码实现逻辑，这样就可以实时地发现逻辑问题，及时返工修正。而通常单元测试速度是很快的，这使得我们有条件可以完成下面的red-&gt;green-&gt;refactor的开发节奏。<br><img src=\"/2021/08/29/obsidian_posts/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/Pasted%20image%2020210829201431.png\" alt><br>在每一次red-&gt;green的变化中，我们都会运行一次单元测试。而每次完成refactor后，我们又会使用单元测试，验证我们重构后的代码是否破坏了原有的逻辑。所以引入单元测试，并不是为了直接提升我们的代码质量，而是为了能让我们：</p>\n<ol>\n<li>切分原先整块的代码逻辑，变成一个个小的积木逻辑</li>\n<li>充分测试我们的特性代码逻辑，并且达到足够的覆盖率（越高越好）</li>\n<li>在重构时，有足够覆盖率的测试帮助我们验证逻辑是否遭到破坏</li>\n</ol>\n<p>当我们严格按照red-&gt;green-&gt;refactor的节奏不断推进时，我们的代码架构就会变好，代码经过更多的测试，代码质量也会得到一定的保证。而这只是单元测试带来的附加值。</p>\n<p>现在我们有了单元测试这个武器后，看看我们的开发流程会变成怎样？</p>\n<ol>\n<li>设计代码逻辑，与前面不同之处在于，我们先不深入到具体的代码逻辑，而是将功能模块化，将模块接口化</li>\n<li>挑一个接口开始编程</li>\n<li>按照开发顺序，写好待测逻辑的单元测试</li>\n<li>开发特性代码逻辑，让单元测试通过</li>\n<li>如果发现设计逻辑导致无法开发，回到步骤1</li>\n<li>重复3-4步，直到接口完成</li>\n<li>重复1-6，直到特性代码完成</li>\n<li>编写功能测试，调试，如果发现问题，检验代码逻辑，如果有设计问题，仍然要回到步骤1</li>\n</ol>\n<p>可以看到，从第3步开始，我们就不断地测试，不断验证我们的逻辑。虽然到达最后一步功能测试验证时，如果发现设计问题，仍然要返工回到步骤1，但因为我们期间不断地测试，不断地思考，并验证逻辑，我们可能很早就发现了设计问题，而不会等到最后一步才需要返工。正因为如此，当我们在准备进行功能测试验证的时候，我们对自己开发的代码更有信心。</p>\n<h1 id=\"单元测试带来的额外好处\"><a href=\"#单元测试带来的额外好处\" class=\"headerlink\" title=\"单元测试带来的额外好处\"></a>单元测试带来的额外好处</h1><h2 id=\"单元测试帮助你进入心流\"><a href=\"#单元测试帮助你进入心流\" class=\"headerlink\" title=\"单元测试帮助你进入心流\"></a>单元测试帮助你进入心流</h2><p>单元测试提升了我们对开发代码的信心，让我们有机会实现red-&gt;green-&gt;refactor的开发节奏，从而优化代码架构。单元测试让我们能够更focus，从而更容易进入心流状态。进入心流状态，意味着注意力极为集中，工作效率很高。</p>\n<blockquote>\n<p><strong>心流</strong>（英语：Flow），也有别名以化境（Zone）表示，亦有人翻译为<strong>神驰</strong>或<strong>沉浸</strong>状态，是由匈牙利裔美籍心理学家<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%93%88%E9%87%8C%C2%B7%E5%A5%91%E5%85%8B%E6%A3%AE\" title=\"米哈里·契克森\">米哈里·契克森</a>首度提出，定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生同时会有高度的兴奋感及充实感等正向情绪。<br>Martin Fowler的<a href=\"https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073\">The Clean Coder: A Code of Conduct for Professional Programmers: Martin, Robert: 4708364241379: Amazon.com: Books</a>一书告诉我们，心流对程序员来说并不一定是好事，但大多数情况它还是好的。心流并不在本文讨论范围之内。</p>\n</blockquote>\n<p>《测试驱动开发》一书给出了一种撰写单元测试的最佳实践。即<strong>每次关注一个足够小的逻辑，并在完成之后再完善它</strong>。</p>\n<p>因为人的注意力是有限的，不能一次性关注太多的东西。在开发某一个逻辑中间，如果被其他事情分散了注意力，往往会造成逻辑发散。例如：你在实现一个上报故障逻辑，但你希望记录每个故障的时间戳，你又不记得时间戳函数的具体使用方法。这时候如果你选择去google这个函数，并搞清楚它的使用方法，有可能你需要花很久时间才会回到你原先的主线逻辑继续开发。这和你的开发被打断没有区别，你失去了进入心流的机会，你需要花很长的时间再重新回顾原先的开发现场，导致你的效率不可能很高。但这还不是最糟糕的。最糟糕的是，你在google的过程中，又发现了其他问题，你又去看那个问题，或者不巧在这过程中被访客打断（实际工作中经常发生，这也是通常我认为在家远程办公的效率可能更高）。你离开原先的开发主线的时间越长，则需要重建现场的时间就越长。这和操作系统的中断很像，你离开的时间越长，很多cache都被flush掉了，那么你再次回到原先的工作状态就要花费更多的overloading。</p>\n<p>Kent Beck给出的建议是，以最简单的方法解决当前的问题，让你每一个开发逻辑都原子化地完成。例如：刚才我们的上报故障功能需要一个时间戳，我们现在不知道怎么写那个时间戳方法，于是就先hard code一个时间戳，并在我们的TODO list上记录一个事项。等我们完成了当前的开发逻辑，再去除TODO list，依次解决上面的问题。等问题都解决完了，再进行下一步开发。每件事务的处理保持原子化，要么没做，要么就做完。这样多出来记录TODO list的时间，但节省了被打断并且恢复现场的时间，并且你有更多的机会进入“心流”。</p>\n<h2 id=\"单元测试帮助你克服内心的恐惧\"><a href=\"#单元测试帮助你克服内心的恐惧\" class=\"headerlink\" title=\"单元测试帮助你克服内心的恐惧\"></a>单元测试帮助你克服内心的恐惧</h2><p>通常一个有责任心的程序员，都会有“完美程序”情节。你希望你写出来的代码是完美抽象的，通用性好，扩展性强，性能佳，等等。这本没有错，也是一个程序员的基本素养。但如果你总是想毕其功于一役，却并没有那么简单。这曾经也深深地困扰过我。在一个支线逻辑上踟蹰不前，严重影响开发效率。在现实的开发中，我也观察到很多同事有和我一样的困扰。针对这个问题， Kent Beck给出的建议是，先实现你的预定计划（除非你可以立即证明它完全是错误的，无法实现）。之后，再通过不断的重构，在必要的时候优化它，避免过设计。直到它能满足你的需求。</p>\n<p>我们总是提倡编写好代码，优美的代码，但事实上，并没有放之四海而皆准的好代码标准。好的代码应该是动态的，能够满足当下可见的需求（功能性和扩展性）的代码就是好代码。当有新需求的时候，比如开发新特性，或需要做性能优化，及时地重构就可以了。重构应当是实时进行的，是自下而上的。通过一些技巧和工具，我们在重构中就能让代码进化到一个更适合当前需求的状态，从而更易于开发新特性，或者继续重构优化。</p>\n<p>再回头看，为什么程序员会有完美代码情结？没错，因为他们自律，有责任心，且见贤思齐。但换个角度说，也可能因为他们内心有一种焦虑，或者恐惧。这是程序员对自己代码没有信心的表现。担心因为一时考虑不周全，在未来会付出更大的返工。每时每刻需要在欠设计和过设计之间做权衡。但请记住，代码是动态的，只要保证代码能够实时地被重构，尽量减少代码的坏味道，代码架构通常大概率是合理的。架构合理的代码，不论做架构调整或性能优化，都是比较容易的。没必要追求所谓的“完美代码”。</p>\n<p>我们平时编程时，应当尽力克服自己内心对未知的恐惧，用单元测试和重构来武装自己。这时，我常常想到一个词“Zen Coding”。做一个佛系的程序员，运用禅编程。</p>\n<h1 id=\"单元测试的误区\"><a href=\"#单元测试的误区\" class=\"headerlink\" title=\"单元测试的误区\"></a>单元测试的误区</h1><p>公司在施行可信变革时，要求单元测试能够达到一定的覆盖率数值。这是完全正确的，应该被提倡。因为只有单元测试的覆盖率足够高，才能在重构时捕获每一个轻微的逻辑破损，避免因为即时重构引入的问题。而单元测试因为通常采用mock依赖实现，理论上只要mock实现的足够优秀，是可以实现100%的覆盖率的。但真正在项目运行的时候，因为覆盖率是一个很容易感知的指标，所以单元测试慢慢地沦为实现覆盖率的附属品。也就是只是为了实现超高覆盖率而写单元测试。这表现在：</p>\n<ul>\n<li>每个测试case不是为了覆盖一个小逻辑而产生，为了迅速满足覆盖率要求，很多个测试断言放在一起，产生巨大的composite case</li>\n<li>为了完成超高覆盖率，随意运用核武器来mock依赖函数，造成mock了过多的内部实现，测试代码变得异常脆弱，一旦依赖实现需要变更，整棵依赖树上的测试case都要跟着改</li>\n<li>测试代码缺乏重构，随处可见重复代码，一旦变更要涉及多处更改</li>\n<li>测试case之间耦合严重，一个特性代码的修改理想情况下只会导致一个相关case失败，但耦合严重的case，往往会失败一大片。一个特性代码改动导致一个完全不相干的case失败。这是很令人崩溃的事情。令人崩溃的事情往往就会成为一个包袱，随时等待被丢弃。</li>\n</ul>\n<p>在我接触到的项目中，这样的情况非常普遍。虽然我们每日的CI报告中，单元测试覆盖率数值是很好看的。但实际单元测试应该产生的作用很小，甚至沦为了开发的负担。通常听到一个词语叫“补单元测试”。可见单元测试并没有被正确的使用。打个比方，登山运动员都有一个很大的背包，背包里面放满了各种救命用的工具。你见别人的包挺大，你也整了个大背包，然后背了一堆你爱吃的零食。这些零食在一开始的时候，让你挺happy，到了关键时刻，别人从背包里拿出救命的工具，你的背包只会成为累赘，不如早早丢弃。</p>\n<p>正确的做法应当是，每写一个小逻辑（接口实现级别，若干个小逻辑组成一个接口），就完成一个单元测试case与之对应，不论你是先写case（TDD），还是先写特性代码（非TDD）。当整个特性代码完成后，单元测试也是完备的，并且提交MR之前，应当即时完成重构，并修复能识别到的坏味道。如果因为交付时间问题，不能即时解决的应当添加FIXME注释，并且在你的TODO list上添加一条，以跟踪该事项。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>单元测试是工具不是目的。</li>\n<li>单元测试用于即时重构，优化代码逻辑和结构，功能测试用于看护代码质量</li>\n<li>流水不腐，户枢不蠹，好的代码应该不断地流动，在变化中达到平衡</li>\n</ul>\n",
            "tags": [
                "UT",
                "TDD"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/",
            "url": "https://blog.zhougy.top/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/",
            "title": "unique_ptr到底是否能按值传递？",
            "date_published": "2021-08-22T02:36:37.359Z",
            "content_html": "<p>答案是否定的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::unique_ptr&lt;<span class=\"keyword\">int</span>&gt; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> a = std::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">func</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这段代码是不能编译的，因为uniqe_ptr没有拷贝构造函数。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ben@LUbuntu ~/t/unique_ptr&gt; g++ -o <span class=\"built_in\">test</span> main.cpp -std=c++14</span><br><span class=\"line\"></span><br><span class=\"line\">main.cpp: In <span class=\"keyword\">function</span> ‘int main()’:</span><br><span class=\"line\"></span><br><span class=\"line\">main.cpp:10:11: error: use of deleted <span class=\"keyword\">function</span> ‘std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]’</span><br><span class=\"line\"></span><br><span class=\"line\">10 | func(a);</span><br><span class=\"line\"></span><br><span class=\"line\">|</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>那为什么问这个问题？看下面这段代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::unique_ptr&lt;<span class=\"keyword\">int</span>&gt; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(std::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个是可以编译的，执行也没问题。再看make_unique的原型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt; class T, class... Args &gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">( Args&amp;&amp;... args )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt; class T &gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">( std::<span class=\"keyword\">size_t</span> size )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">Args</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* unspecified */</span> <span class=\"built_in\">make_unique</span>( Args&amp;&amp;... args ) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可见make_unique的返回值是unique_ptr。那么前面那段代码就给人造成了unique_ptr似乎也可以按值传递的假象。到底是什么原因呢？后面我们结合汇编一起分析一下，编译器针对这样的场景做了什么优化。</p>\n<h1 id=\"make-unique的返回值直接作为函数参数的真相\"><a href=\"#make-unique的返回值直接作为函数参数的真相\" class=\"headerlink\" title=\"make_unique的返回值直接作为函数参数的真相\"></a>make_unique的返回值直接作为函数参数的真相</h1><p>直接通过<code>objectdum -tCS test &gt; test.dump</code>命令对可执行文件进行反汇编。注意编译时，要指定<code>-g -O0</code>。这样反汇编时，信息更多一些。</p>\n<p>由于STL扩展代码，外加C++编译器插入的一些初始化和退出清理代码，反汇编产生的文件行数较多，我们只需关注核心的main函数以及一些相关的函数即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">4008a8: a9be7bfd stp x29, x30, [sp, #-32]! // 将x29,x30存储于sp-32处，且sp = sp-32</span><br><span class=\"line\"></span><br><span class=\"line\">4008ac: 910003fd mov x29, sp</span><br><span class=\"line\"></span><br><span class=\"line\">func(std::make_unique&lt;int&gt;(1));</span><br><span class=\"line\"></span><br><span class=\"line\">4008b0: 52800020 mov w0, #0x1 // #1</span><br><span class=\"line\"></span><br><span class=\"line\">4008b4: b9001fe0 str w0, [sp, #28]</span><br><span class=\"line\"></span><br><span class=\"line\">4008b8: 910073e0 add x0, sp, #0x1c</span><br><span class=\"line\"></span><br><span class=\"line\">4008bc: 910043e1 add x1, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008c0: aa0103e8 mov x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\">4008c4: 94000027 bl 400960 &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4008c8: 910043e0 add x0, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008cc: 97fffff2 bl 400894 &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4008d0: 910043e0 add x0, sp, #0x10</span><br><span class=\"line\"></span><br><span class=\"line\">4008d4: 94000035 bl 4009a8 &lt;std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;::~unique_ptr()&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">4008d8: 52800000 mov w0, #0x0 // #0</span><br><span class=\"line\"></span><br><span class=\"line\">4008dc: a8c27bfd ldp x29, x30, [sp], #32</span><br><span class=\"line\"></span><br><span class=\"line\">4008e0: d65f03c0 ret</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">///@&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"调用make-unique前的准备\"><a href=\"#调用make-unique前的准备\" class=\"headerlink\" title=\"调用make_unique前的准备\"></a>调用make_unique前的准备</h2><p>main函数的第一行指令，将栈指针（sp）移动到了栈底，并保存了x29和x30寄存器。寄存器含义可以参考附录。在调用make_unique前，栈内存如下图。<br><img src=\"/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/Pasted%20image%2020210822121125.png\" alt></p>\n<h3 id=\"ARM函数调用约定\"><a href=\"#ARM函数调用约定\" class=\"headerlink\" title=\"ARM函数调用约定\"></a>ARM函数调用约定</h3><p>也叫AAPCS，Procedure Call Standard for the Arm Architecture。对于aarch64，简而言之就是：</p>\n<ul>\n<li><p>小于8个参数时，使用x0-x7寄存器</p>\n</li>\n<li><p>超过8个参数，按顺序从右往左入栈（因为栈是先入后出的）</p>\n</li>\n<li><p>返回地址在lr寄存器，返回值的值在x0寄存器</p>\n</li>\n</ul>\n<h3 id=\"make-unique的参数传递\"><a href=\"#make-unique的参数传递\" class=\"headerlink\" title=\"make_unique的参数传递\"></a>make_unique的参数传递</h3><p>按照AAPCS的理解，make_unique的实现函数实际有两个入参：一个是uniuqe_ptr的构造函数参数1，另一个就是用来存放unique_ptr对象指针的地址，即x1。</p>\n<p>这样就很好理解了，调用完make_unique，下一步就是使用make_unique的输出调用func了。也就是<code>add x0, sp, #0x10</code>z这一行。将保存了unique_ptr指针的地址赋予了func函数的唯一一个参数。</p>\n<blockquote>\n<p><strong>所以可见，func函数并不是传递unique_ptr的值，而是通过编译器生成了一个临时变量保存了make_unique返回的unique_ptr对象指针，并传递给了func。</strong></p>\n</blockquote>\n<h3 id=\"按引用传递会怎么样？\"><a href=\"#按引用传递会怎么样？\" class=\"headerlink\" title=\"按引用传递会怎么样？\"></a>按引用传递会怎么样？</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> a = <span class=\"built_in\">std</span>::make_unique&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    func(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">int</span> main()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>a8: a9bd7bfd stp x29, x30, [<span class=\"built_in\">sp</span>, #-<span class=\"number\">48</span>]!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>ac: <span class=\"number\">910003</span>fd <span class=\"keyword\">mov</span> x29, <span class=\"built_in\">sp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b0: f9000bf3 <span class=\"keyword\">str</span> x19, [<span class=\"built_in\">sp</span>, <span class=\"number\">#16</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">auto</span> a = std::make_unique&lt;int&gt;(<span class=\"number\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b4: <span class=\"number\">52800020</span> <span class=\"keyword\">mov</span> w0, <span class=\"number\">#0x1</span> <span class=\"comment\">// #1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b8: b9002fe0 <span class=\"keyword\">str</span> w0, [<span class=\"built_in\">sp</span>, <span class=\"number\">#44</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>bc: <span class=\"number\">9100</span>b3e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x2c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c0</span>: <span class=\"number\">910083</span>e1 <span class=\"keyword\">add</span> x1, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c4</span>: aa0103e8 <span class=\"keyword\">mov</span> x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c8</span>: <span class=\"number\">94000029</span> <span class=\"keyword\">bl</span> <span class=\"number\">40096</span>c &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">func</span>(a)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>cc: <span class=\"number\">910083</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">d0</span>: <span class=\"number\">97</span>fffff1 <span class=\"keyword\">bl</span> <span class=\"number\">400894</span> &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///@&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2021/08/22/obsidian_posts/unique_ptr%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E8%83%BD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/Pasted%20image%2020210822121232.png\" alt></p>\n<p>如出一辙，对make_unique的调用是一样的，只不过这里多存了一个局部变量a，所以多话费了几个字节的栈空间。而前文的临时变量存在寄存器即可。</p>\n<h3 id=\"传右值引用呢？\"><a href=\"#传右值引用呢？\" class=\"headerlink\" title=\"传右值引用呢？\"></a>传右值引用呢？</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>b8: <span class=\"number\">910073</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x1c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>bc: <span class=\"number\">910043</span>e1 <span class=\"keyword\">add</span> x1, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c0</span>: aa0103e8 <span class=\"keyword\">mov</span> x8, x1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c4</span>: <span class=\"number\">94000027</span> <span class=\"keyword\">bl</span> <span class=\"number\">400960</span> &lt;std::_MakeUniq&lt;int&gt;::__single_object std::make_unique&lt;int, int&gt;(int&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span><span class=\"built_in\">c8</span>: <span class=\"number\">910043</span>e0 <span class=\"keyword\">add</span> x0, <span class=\"built_in\">sp</span>, <span class=\"number\">#0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4008</span>cc: <span class=\"number\">97</span>fffff2 <span class=\"keyword\">bl</span> <span class=\"number\">400894</span> &lt;func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;&amp;)&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可见传右值引用和传值一模一样。</p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"AARCH64寄存器\"><a href=\"#AARCH64寄存器\" class=\"headerlink\" title=\"AARCH64寄存器\"></a>AARCH64寄存器</h2><p>参考<a href=\"https://winddoing.github.io/post/7190.html\">ARMv8-aarch64 寄存器和指令集</a></p>\n<h3 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h3><ul>\n<li><p>参数寄存器（X0-X7）： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8 个寄存器可用于传递参数）</p>\n</li>\n<li><p>来电保存的临时寄存器（X9-X15）： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。</p>\n</li>\n<li><p>被调用者保存的寄存器（X19-X29）： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。</p>\n</li>\n</ul>\n<h3 id=\"特殊用途寄存器（X8，X16-X18，X29，X30）：\"><a href=\"#特殊用途寄存器（X8，X16-X18，X29，X30）：\" class=\"headerlink\" title=\"特殊用途寄存器（X8，X16-X18，X29，X30）：\"></a>特殊用途寄存器（X8，X16-X18，X29，X30）：</h3><p>X8： 是间接结果寄存器，用于保存子程序返回地址，尽量不使用</p>\n<p>X16 和 X17： 程序内调用临时寄存器</p>\n<p>X18： 平台寄存器，保留用于平台 ABI，尽量不使用</p>\n<p>X29： 帧指针寄存器（FP）</p>\n<p>X30： 链接寄存器（LR）</p>\n<p>X31： 堆栈指针寄存器 SP 或零寄存器 ZXR</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><p><a href=\"https://code.woboq.org/appleseed/include/boost/move/make_unique.hpp.html\">make_unique源码</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/forever_2015/article/details/50283747\">[AAPCS 学习课后练习 - 通过一个小例子来讲解]</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/42486116\">基于ARM64 的常见汇编命令记录</a></p>\n</li>\n<li><p><a href=\"https://winddoing.github.io/post/7190.html\">ARMv8-aarch64 寄存器和指令集</a></p>\n</li>\n</ul>\n",
            "tags": [
                "C++",
                "coding"
            ]
        }
    ]
}