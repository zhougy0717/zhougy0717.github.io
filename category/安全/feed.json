{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben • All posts by \"安全\" category",
    "description": null,
    "home_page_url": "https://blog.zhougy.top",
    "items": [
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "title": "RBAC",
            "date_published": "2021-09-18T14:17:35.996Z",
            "content_html": "<p>RBAC, Role Based Access Control, 是SELinux的另一个重要的特性。但他并不是一种独立的控制方式，而是对TEAC的一种补充。其主要的作用是，构建SELinux提供的进程级的MAC机制与Linux的用户系统的映射关系。</p>\n<h1 id=\"RBAC工作原理\"><a href=\"#RBAC工作原理\" class=\"headerlink\" title=\"RBAC工作原理\"></a>RBAC工作原理</h1><p>RBAC并不提供强制访问控制，而是通过user，role，type之间的对应关系，来控制type_transition策略能否成功。</p>\n<h2 id=\"role-vs-type\"><a href=\"#role-vs-type\" class=\"headerlink\" title=\"role vs. type\"></a>role vs. type</h2><p>role based最基本的就是定义role到type到对应关系。使用role语句可以实现：<code>role role_name [types type_set];</code>。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">role user_r types user_t;</span><br><span class=\"line\">role user_r types &#123; staff_t, admin_t &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>role定义是累积的，即后面的对应关系不会覆盖前面语句定义的对应关系，而只会追加这种关系</li>\n<li>role语句通常定义在type声明附近，以确保该对应关系被及时定义</li>\n</ul>\n<blockquote>\n<p><strong>定义子role (period)</strong><br>A period is used to indicate restrictions on the set of types that may be assigned to a role. For example, the set of types for a role called <strong><em>apache.cgi</em></strong> must be a <strong><em>subset</em></strong> of the type set of a role called <strong><em>apache</em></strong>.</p>\n</blockquote>\n<p>role语句定义的基本逻辑就是，定义了role=&gt;{ types }集合的映射关系。当发生type transition时，如果转换后的{role，type}组合未定义，则视为权限错误。从这个层面看，role对应的是主体type，即domain type，而非object type。</p>\n<h3 id=\"特殊的role-object-r\"><a href=\"#特殊的role-object-r\" class=\"headerlink\" title=\"特殊的role: object_r\"></a>特殊的role: object_r</h3><p>object_r是内核SELinux模块预定义的一个role，无需在policy中声明。而这个object_r被专门用来定义客体的安全上下文。</p>\n<h2 id=\"user-vs-role\"><a href=\"#user-vs-role\" class=\"headerlink\" title=\"user vs. role\"></a>user vs. role</h2><p>user是对role的再一次扩充，通过user将role与Linux user的映射关系建立起来。SELinux的用户系统独立于Linux用户系统。通过seusers文件或者<code>semanage user</code>命令可以定义他们之间的映射关系。但实际可定义的自由度并没有那么高。</p>\n<blockquote>\n<p>The design decision for SELinux to have a distinct user identifier (rather than share that of Linux) is motivated by the desire to create an immutable SELinux user identifier.</p>\n</blockquote>\n<p>定义一个user与role的映射关系，可以使用user语句：<code>user user_name roles &#123; role_set &#125;;</code><br>user语句所体现的逻辑和role语句类似，即定义了user=&gt;{ roles }集合的映射关系。当应用启动时发生role transition时，如果转换后的{user, role}未定义，则视为权限错误。</p>\n<p>当SELinux通过RBAC，建立起user=&gt;role=&gt;type的映射关系以后，还获得了一个好处。Linux系统的用户数可能很多，而用户的类型很少。用户并不是为了定义权限的，不同的用户之间的使用数据需要隔离。但往往一类用户的权限是相同的。例如超级用户，管理员用户，普通用户等等。系统的权限集最小粒度由domain定义。可能每个进程的权限不同，也可能一组进程的权限相同。但往往domain的数量也很庞大。如果没有RBAC，我们需要定义user到domain到映射。这样也不是不能做，但却不太优雅。每次新增用户时，需要为新增用户绑定一堆domain。定义了role之后，role相当于较稳定的一层抽象，role到types的映射关系是在定义type时候就定义了的。增加新user的时候，只要定义user到role的映射即可。这就是引入RBAC的原因。</p>\n<pre class=\"mermaid\">graph LR\nA[user] --> B[role]\nA --> C[role]\nA --> D[role]\nC --> E[domain]\nC --> F[domain]\nC --> G[domain]</pre>\n\n<h3 id=\"Linux用户-vs-SELinux-user\"><a href=\"#Linux用户-vs-SELinux-user\" class=\"headerlink\" title=\"Linux用户 vs. SELinux user\"></a>Linux用户 vs. SELinux user</h3><ul>\n<li>当前系统的用户可以通过查看/etc/passwd文件获取，也可以参考<a href=\"https://zhuanlan.zhihu.com/p/41161408\">列出 Linux 系统上所有用户的 3 种方法</a>.</li>\n<li>查看SELinux的用户可以通过命令<code>semanage user -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               标记中        MLS/       MLS/                          </span><br><span class=\"line\">SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色</span><br><span class=\"line\"></span><br><span class=\"line\">guest_u         user       s0         s0                             guest_r</span><br><span class=\"line\">root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</span><br><span class=\"line\">staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r unconfined_r</span><br><span class=\"line\">sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r</span><br><span class=\"line\">system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">user_u          user       s0         s0                             user_r</span><br><span class=\"line\">xguest_u        user       s0         s0                             xguest_r</span><br></pre></td></tr></table></figure></li>\n<li>查看两者的映射关系可以通过命令<code>semanage login -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名                  SELinux 用户           MLS/MCS 范围           服务</span><br><span class=\"line\"></span><br><span class=\"line\">__default__          unconfined_u         s0-s0:c0.c1023       *</span><br><span class=\"line\">john                 user_u               s0                   *</span><br><span class=\"line\">root                 unconfined_u         s0-s0:c0.c1023       *</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Linux用户和SELinux用户的初始映射关系由seusers文件指定。这个文件不属于策略二进制的一部分，而可以直接修改生效。当然更优雅的办法是通过semanage命令来修改。<br>另外，在修改了context以后，或者新建了用户以后，必须要使用注销登录的方法，才能使新的context生效，而只使用su命令切换用户，并不会切换context。推测注销登录使用的是PAM登录程序，而su命令中，并没有重新加载user context的功能。<br>Linux用户登录后，获取shell安全上下文的步骤，可以参考文献【2】。简述如下：</p>\n<ol>\n<li>根据seusers文件，映射SELinux用户，如果没有seusers文件，系统就无法启动了。如果seusers文件没有对应的用户描述，则统一映射为<code>__default__</code>用户。如果<code>__default__</code>用户描述不存在，则无法登录。</li>\n<li>根据SELinux的搜索优先级，找到对应SELinux用户的安全上下文。</li>\n</ol>\n<blockquote>\n<p><strong>勘误</strong><br>在[1]中，对Linux用户和SELinux的映射关系有如下描述：<br>On login, if there is an SELinux user identifier that is exactly the same as the Linux user identifier, the matching SELinux user identifier becomes the user identifier in the security context for the initial shell process. In this way, if a Linux user identifier also exists as a user identifier in the SELinux policy, all login processes will set the initial shell process security context user identifier to that matching Linux identity.<br>经实验证明，并非如此：</p>\n<ul>\n<li>定义了一个guest_u用户，登录后，其shell的安全上下文仍为：<br><img src=\"/2021/09/18/obsidian_posts/RBAC/163C5090-847B-49EC-B709-3AAA87D776D9.png\" alt=\"1ca6909a350aa84947ea565bb4c8eaa2\"></li>\n<li>但事实证明，明明就有guest_u这个用户<br><img src=\"/2021/09/18/obsidian_posts/RBAC/CA68A544-BEE4-4B4E-9BC5-EA3452F816F9.png\" alt=\"7737fbc74190005733b9f01b60178907\"><br>推测，可能是因为SELinux也一直在发展改进中。[1]d 成书时间是2006年，彼时还是FC（Fedora Core）5的年代，现在最新版已经是Fedora 33，2020年10月份发布。</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在可以引用[1]中的一幅图来总结一下RBAC的工作原理了。<br><img src=\"/2021/09/18/obsidian_posts/RBAC/6903A6B7-B8D6-4621-8AF4-C276F4EAD57F.png\" alt=\"115b4d2e2576fd1b93937d66425645d5\"></p>\n<ul>\n<li>Linux系统有一个用户较joe</li>\n<li>SELinuxcelue中规定joe和user_r绑定，user_r和user_t绑定</li>\n<li>当joe登录时，系统根据seusers（此处与图不同，参见上一章勘误），找到对应的SELinux user，找不到就是<strong>default</strong>, <strong>default</strong>没有就不能登录了</li>\n<li>根据以下context文件顺序，决定其shell的安全上下文，即joe:user_r:user_t<ul>\n<li>/etc/selinux/specified-policy/contexts/users</li>\n<li>/etc/selinux/specified-policy/contexts/default_contexts</li>\n<li>/etc/selinux/specified-policy/contexts/failsafe_context</li>\n<li>sid kernel的安全上下文</li>\n</ul>\n</li>\n<li>joe执行了一个应用，开始进行domain_transition, 要从user_t切换到passwd_t<ul>\n<li>如果定义了<code>role user_r types passwd_t</code>和<code>role user_r types user_t</code>，则这次domain transition可以成功</li>\n<li>否则任意一个未定义，domain transition都会失败</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"高阶用法\"><a href=\"#高阶用法\" class=\"headerlink\" title=\"高阶用法\"></a>高阶用法</h1><h2 id=\"role-transition\"><a href=\"#role-transition\" class=\"headerlink\" title=\"role_transition\"></a>role_transition</h2><p>role transition和domain transition非常类似，也是在某个domain进程在执行某个可执行文件时，即exec系统调用时，切换进程主体的安全上下文。domain transition切换的时domain，role transtion切换的是role。实现方式通过以下两条语句：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow staff_r sysadm_r; # 允许从staff_r切换到sysadm_r</span><br><span class=\"line\">role_transition sysadm_r http_exec_t system_r; # sysadm_r进程执行http_exec_t类型文件时，role切换为system_r</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"role-dominance\"><a href=\"#role-dominance\" class=\"headerlink\" title=\"role_dominance\"></a>role_dominance</h2><p>可以利用role来定义其他role，即role dominance。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dominance &#123; role super_r &#123;role sysadm_r; role secadm_r; &#125;</span><br></pre></td></tr></table></figure><br>上面例子中的super_r称为dominant role，它可以从它关联的role中即成types。但它只能继承该条语句之前关联的types。我们之前说role语句是可以累积的。那么在role_dominance语句之后定义的types，并不能动态的添加到dominant role上。</p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><p>跟role相关的主要是semnage的一些用法，另外[1]还介绍了一个apol的可视化工具，可以检索user和role的数据。我理解semanage通过命令行也都可以实现。</p>\n<ol>\n<li>前文介绍过的<code>semanage user -l</code>和<code>semanage login -l</code>, 前者用来查看所有SELinux的用户，后者用来查看Linux用户和SELinux用户两者的映射关系.</li>\n<li>Modify the default user on the system to the guest_u user<ul>\n<li><code>semanage login -m -s guest_u __default__</code></li>\n</ul>\n</li>\n<li>修改user和role的对应关系<ul>\n<li><code>semanage user -m -R &quot;message_filter_r unconfined_r&quot; user_u</code></li>\n</ul>\n</li>\n<li>添加一个用户并指定SELinux用户<ul>\n<li><code>useradd joe -Z user_u</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://app.yinxiang.com/shard/s10/nl/161681/ea41e2f7-d7a8-4629-9f8c-c08696f578af/\">SELinux by Example_ Using Security Enhanced Linux</a><br>[2] <a href=\"https://blog.csdn.net/keheinash/article/details/81047520\">SELinux初始化登录用户安全上下文的方法</a></p>\n",
            "tags": [
                "security",
                "SELinux"
            ]
        },
        {
            "id": "https://blog.zhougy.top/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "url": "https://blog.zhougy.top/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/",
            "title": "详解SELinux SID",
            "date_published": "2021-09-12T06:26:36.976Z",
            "content_html": "<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p>SID = Security Identifier (即Security ID)。其作用就是取代安全上下文，在权限匹配时，提升规则搜索速度，以及降低整个策略数据的空间复杂度，提升了整个SELinux特性的性能损耗。<br>例如一次权限匹配的函数调用原型如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_has_perm</span><span class=\"params\">(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t u32 requested, struct common_audit_data *auditdata)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>其中ssid, tsid就代表了源(source)SID和目的(target)SID。在最终的av(access vector)计算中，SID被转化为context。</p>\n<blockquote>\n<p>什么是context？<br>context，即安全上下文，是SELinux的核心概念。形如<code>user_u:role_r:type_t:s0-s1:c0,c1-c255</code>的就是context。其中user字段和role字段用于RBAC，type字段用于TEAC，后面的s0-s1,c1-c255用于mls/mcs。而所有的这些字段，都由策略编译工具生成了整数数据，在SELinux加载策略时一并加载到内存policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// context定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// context加载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">context_read_and_validate</span><span class=\"params\">(struct context *c,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     struct policydb *p,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t     <span class=\"keyword\">void</span> *fp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    c-&gt;user = le32_to_cpu(buf[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    c-&gt;role = le32_to_cpu(buf[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    c-&gt;type = le32_to_cpu(buf[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>在真正的权限匹配时，SELinux通过SID获取到对应的context，再通过context中的type属性，所搜policydb中相应的hash表找到对应的map array，并获取对应某个权限的一个bit位，来得到权限判定结果。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 搜索sidtab获取SID对应的context，并用context数据结构来计算权限</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    scontext = sidtab_search(sidtab, ssid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    tcontext = sidtab_search(sidtab, tsid);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    context_struct_compute_av(policydb, scontext, tcontext, tclass, avd,</span><br><span class=\"line\">\t\t\t\t  xperms);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过context的type字段从policydb中获取权限数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">context_struct_compute_av</span><span class=\"params\">(struct policydb *policydb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *scontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct context *tcontext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      u16 tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t      struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   scontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    tattr = flex_array_get(policydb-&gt;type_attr_map_array,</span><br><span class=\"line\">                   tcontext-&gt;type - <span class=\"number\">1</span>);</span><br><span class=\"line\">    ebitmap_for_each_positive_bit(sattr, snode, i) &#123;</span><br><span class=\"line\">        ebitmap_for_each_positive_bit(tattr, tnode, j) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (node = avtab_search_node(&amp;policydb-&gt;te_avtab,</span><br><span class=\"line\">                              &amp;avkey);</span><br><span class=\"line\">                 node;</span><br><span class=\"line\">                 node = avtab_search_node_next(node, avkey.specified)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Get and assign perm data</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"initial-SID\"><a href=\"#initial-SID\" class=\"headerlink\" title=\"initial SID\"></a>initial SID</h1><p>initial SID是一种比较特殊的SID。他在策略编译和SELinux启动中都扮演了非常重要的角色。通常在编译policy的时候，需要一些flask文件，例如Fedora refpolicy：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> ls refpolicy-master/policy/flask/</span></span><br><span class=\"line\">access_vectors   initial_sids     security_classes</span><br></pre></td></tr></table></figure>\n<p>其中initial_sids就指定了policy二进制中所有的initial SID。内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># FLASK</span><br><span class=\"line\"></span><br><span class=\"line\">#</span><br><span class=\"line\"># Define initial security identifiers</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\">sid kernel</span><br><span class=\"line\">sid security</span><br><span class=\"line\">sid unlabeled</span><br><span class=\"line\">sid fs</span><br><span class=\"line\">sid file</span><br><span class=\"line\">sid file_labels</span><br><span class=\"line\">sid init</span><br><span class=\"line\">sid any_socket</span><br><span class=\"line\">sid port</span><br><span class=\"line\">sid netif</span><br><span class=\"line\">sid netmsg</span><br><span class=\"line\">sid node</span><br><span class=\"line\">sid igmp_packet</span><br><span class=\"line\">sid icmp_socket</span><br><span class=\"line\">sid tcp_socket</span><br><span class=\"line\">sid sysctl_modprobe</span><br><span class=\"line\">sid sysctl</span><br><span class=\"line\">sid sysctl_fs</span><br><span class=\"line\">sid sysctl_kernel</span><br><span class=\"line\">sid sysctl_net</span><br><span class=\"line\">sid sysctl_net_unix</span><br><span class=\"line\">sid sysctl_vm</span><br><span class=\"line\">sid sysctl_dev</span><br><span class=\"line\">sid kmod</span><br><span class=\"line\">sid policy</span><br><span class=\"line\">sid scmp_packet</span><br><span class=\"line\">sid devnull</span><br><span class=\"line\"></span><br><span class=\"line\"># FLASK</span><br></pre></td></tr></table></figure>\n<p>参考《Building The Sample Policy》中的介绍，这些flask文件的内容将被写到最终的policy二进制文件中（即policy.conf),如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notebook-tools/build-sepolicy -o policy.conf -d ../../flask-files</span><br></pre></td></tr></table></figure><br>build-sepolicy是一个python的示例程序，他是这样处理flask文件的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    f = Flask()</span><br><span class=\"line\">    f.parseSids(flask_dir + <span class=\"string\">&quot;/initial_sids&quot;</span>)</span><br><span class=\"line\">    f.parseClasses(flask_dir + <span class=\"string\">&quot;/security_classes&quot;</span>)</span><br><span class=\"line\">    f.parseVectors(flask_dir + <span class=\"string\">&quot;/access_vectors&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Open the file and then create the requested policy source file</span></span><br><span class=\"line\">    of = <span class=\"built_in\">open</span>(outf, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> include == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicyHdr(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output header file&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> cil == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL policy&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> class_perm == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilClassPerms(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL class permission sets&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> sids == <span class=\"number\">1</span>:</span><br><span class=\"line\">        of.writelines(f.createCilInitialSIDS(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output CIL initial SIDs&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        of.writelines(f.createPolicy(mode))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Output Kernel Language policy&quot;</span>)</span><br><span class=\"line\">    of.close()</span><br></pre></td></tr></table></figure><br>可见这些文件的内容，被写入到一个Flask对象中，而该对象的内容最终会被写入策略二进制数据。在后续的策略编译中，这些文件会被checkpolicy来处理。</p>\n<blockquote>\n<p><strong>initial SID的作用</strong><br><em>from “SELinux by Example: Using Security Enhanced Linux”</em><br>Some objects are labeled via an initial SID early in system initialization, <strong><em>even before the policy is loaded</em></strong>. This labeling behavior is needed, for example, to label objects such as the kernel security server and the root filesystem, which are present in the system before the first policy load. <strong><em>When the policy is eventually loaded, the initial SIDs are then associated with the appropriate security context</em></strong>.<br><strong><em>Initial SIDs are also used to prevent objects from having a missing or invalid security context, which would make it impossible for SELinux to correctly enforce access</em></strong>. Instead, SELinux associates these objects with the special unlabeled initial SID. The unlabeled initial SID should have a security context that allows only limited access, thereby preventing inappropriate access until the objects can be relabeled by the administrator or destroyed.<br>Invalid security contexts most commonly result from loading a new policy that removes users, roles, or types, or changes role or type authorizations. In this situation, the <strong><em>SIDs representing security contexts that use these invalid names or associations will become invalid and are mapped to the unlabeled SID at policy load</em></strong>. Invalid security contexts can also arise when transferring object instances between systems (for example, using removable media). Further, if the objects are created on a non-SELinux system, they will have no associated security context. Regardless of whether the security context is invalid or missing, SELinux will use the unlabeled initial SID on first access to the object as the security context.</p>\n</blockquote>\n<p>总结一下，一共有这几点：</p>\n<ul>\n<li>系统启动时，policy尚未加载，也就是所有的context还没被抽象成SID，存储在内存中的policydb里。allow规则也还没加载，这时候，为了保证代码归一，所以需要这些unlabeled SID，在SELinux启动流程中，再具体介绍。</li>\n<li>当系统策略变化时，有些role，user或type被删除，导致一些安全上下文失效了，此时这些安全上下文，在策略加载时，会被映射到这些initial SID上。（这里还没找到具体的代码位置）</li>\n</ul>\n<h2 id=\"启动时的使用\"><a href=\"#启动时的使用\" class=\"headerlink\" title=\"启动时的使用\"></a>启动时的使用</h2><p>init进程在加载策略之前，首先将SELinux的enforcing模式打开。其打开的方式就是往selinuxfs的enforce文件写1。注意此时策略未加载，初始化也未完成。所以策略判断直接取allow。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">security_compute_av</span><span class=\"params\">(struct selinux_state *state,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 ssid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u32 tsid,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t u16 orig_tclass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct av_decision *avd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t struct extended_perms *xperms)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!state-&gt;initialized)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> allow;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">allow:</span><br><span class=\"line\">\tavd-&gt;allowed = <span class=\"number\">0xffffffff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但由于用户态的入口是一致的，即启动完成后，用户态可以写同样的enforce文件完成SELinux状态的切换，所以为了判断此时用户态进程是否具有设置的权限，在enforce文件的入口处，对用户态进程权限进行了判定：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length = avc_has_perm(&amp;selinux_state,</span><br><span class=\"line\">                  current_sid(), SECINITSID_SECURITY,</span><br><span class=\"line\">                  SECCLASS_SECURITY, SECURITY__SETENFORCE,</span><br><span class=\"line\">                  <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure><br>这里就用到了initial SID - <code>SECINITSID_SECURITY</code>。这里其实已经可以使用selinuxfs的inode.i_security.sid，但由于selinuxfs未通过系统的file open调用，所以无法使用到inode下的SID标签。</p>\n<h2 id=\"系统标签无效时\"><a href=\"#系统标签无效时\" class=\"headerlink\" title=\"系统标签无效时\"></a>系统标签无效时</h2><p>以socket bind时，对IP地址进行权限判断为例。该权限判断流程大致如下：</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"selinux_socket_bind\"]\nA --> B[\"sock_has_perm(SOCKET__BIND)\"]\nB --> C[\"get nodecon sid by sel_netnode_sid\"]\nC --> D[\"av_has_perm\"]</pre><br><code>security_node_sid</code>会从<code>policydb-&gt;ocontexts[OCON_NODE]</code>中搜索policydb中关于该IP地址的nodecon定义，如果找不着，说明此IP相关的nodecon无效（未定义），则会走默认的initial SID。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c-&gt;sid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        rc = sidtab_context_to_sid(sidtab,</span><br><span class=\"line\">                       &amp;c-&gt;context[<span class=\"number\">0</span>],</span><br><span class=\"line\">                       &amp;c-&gt;sid[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rc)</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *out_sid = c-&gt;sid[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    *out_sid = SECINITSID_NODE; <span class=\"comment\">// &lt;===== intial SID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"其他SID\"><a href=\"#其他SID\" class=\"headerlink\" title=\"其他SID\"></a>其他SID</h1><p>除了initial SID由内核直接加载生成，其他的SID则由对应的打标签流程生成。例如：文件的SID则由setfiles/restorecon工具打入文件系统的扩展属性上，socket则由socket系统调用创建时生成。<br>以socket bind为例，因为比较简单。当socket bind系统调用被执行时，一个socket object被绑定到一个node上。而此时该node的SID才被写入policydb中。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sel_netnode_sid</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, u16 family, u32 *sid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sel_netnode</span> *<span class=\"title\">node</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_read_lock();</span><br><span class=\"line\">\tnode = sel_netnode_find(addr, family);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t*sid = node-&gt;nsec.sid;</span><br><span class=\"line\">\t\trcu_read_unlock();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trcu_read_unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sel_netnode_sid_slow(addr, family, sid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>sel_netnode_sid_slow</code>调用<code>security_node_sid</code>,并最终调用<code>sidtab_context_to_sid</code>将相关的SID以及对应的context数据结构插入到表中。</p>\n<p><pre class=\"mermaid\">graph TD\nA[\"security_node_sid\"]\nA --> B[\"search policydb->ocontexts[OCON_NODE]\"]\nB --> C{\"find?\"}\nC --> |N| B\nC --> |Y| D[\"sidtab_context_to_sid(context，&sid)\"]\nD --> E(\"end\")\nC --> |Never find| F[\"set an initial SID\"]\nF --> E</pre></p>\n<ul>\n<li><code>security_node_sid</code>使用传入的IP地址在policydb中匹配查找context，如果找到则进行下一步，匹配或生成SID，找不到，则直接使用initial SID。</li>\n<li><code>sidtab_context_to_sid</code>将context写入sidtab，并获取返回的SID记入policydb中，后续通过context找SID，直接匹配<code>policydb-&gt;ocontexts[OCON_NODE];</code>即可。对于SID本身的生成也很简单，就是一个单向增长的整形数字，在<code>sidtab_context_to_sid</code>中。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sid = sidtab_search_context(s, context);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sid)</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> unlock_out;</span><br><span class=\"line\">...</span><br><span class=\"line\">sid = s-&gt;next_sid++;</span><br><span class=\"line\">..</span><br><span class=\"line\">ret = sidtab_insert(s, sid, context);</span><br></pre></td></tr></table></figure>\n先尝试在sidtab中查找，如果找不到就加一条记录，并为sid赋值。<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>SID在整个SELinux子系统中的作用就是提升匹配性能（从安全上下文的字符串匹配，降低到整数匹配）,所以在整个SELinux子系统生命周期内，SID总是与安全上下文（context）一一对应的。在一次权限匹配过程中，SID的使用如下：<br><img src=\"/2021/09/12/obsidian_posts/%E8%AF%A6%E8%A7%A3SELinux%20SID/948A5192-E302-40F3-9A2D-D3C2D5B2FF75.png\" alt=\"7fe0cdf2b84938b1e0610fe99bd3c917\"><br>context和SID的定义分别为：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u32 sid;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">context</span> &#123;</span></span><br><span class=\"line\">\tu32 user;</span><br><span class=\"line\">\tu32 role;</span><br><span class=\"line\">\tu32 type;</span><br><span class=\"line\">\tu32 len;        <span class=\"comment\">/* length of string in bytes */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mls_range</span> <span class=\"title\">range</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *str;\t<span class=\"comment\">/* string representation if context cannot be mapped. */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1>没有一个专门的工具用来转换SID与context。但libselinux提供了相应的接口，参考<a href=\"https://linux.die.net/man/3/sidget\">sidget(3) - Linux man page</a>。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_context_to_sid</span><span class=\"params\">(<span class=\"keyword\">security_context_t</span> ctx, <span class=\"keyword\">security_id_t</span> *sid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">avc_sid_to_context</span><span class=\"params\">(<span class=\"keyword\">security_id_t</span> sid, <span class=\"keyword\">security_context_t</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"seinfo\"><a href=\"#seinfo\" class=\"headerlink\" title=\"seinfo\"></a>seinfo</h2></li>\n</ul>\n<ol>\n<li>打印所有initial SID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --initialsid</span><br><span class=\"line\"></span><br><span class=\"line\">Initial SIDs: 27</span><br><span class=\"line\">   any_socket</span><br><span class=\"line\">   devnull</span><br><span class=\"line\">   file</span><br><span class=\"line\">   file_labels</span><br><span class=\"line\">   fs</span><br><span class=\"line\">   icmp_socket</span><br><span class=\"line\">   igmp_packet</span><br><span class=\"line\">   init</span><br><span class=\"line\">   kernel</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>打印selinuxfs context<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ seinfo --genfscon|grep selinux</span><br><span class=\"line\">   genfscon selinuxfs /  system_u:object_r:security_t:s0</span><br></pre></td></tr></table></figure>\n<h2 id=\"initial-contexts\"><a href=\"#initial-contexts\" class=\"headerlink\" title=\"initial_contexts\"></a>initial_contexts</h2>策略加载后，每个initial SID都有一个对应的context。这些context在各策略模块中定义。这些context在selinuxfs可以查看：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ben@localhost ~]$ sudo cat /sys/fs/selinux/initial_contexts/kernel</span><br><span class=\"line\">system_u:system_r:kernel_t:s0</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1></li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/fedora-selinux/selinux-policy\">Fedora refpolicy</a></li>\n<li>Frank Mayer, Karl MacMillan, David Caplan， July 27, 2006- “SELinux by Example: Using Security Enhanced Linux”</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook</a>“ Volume II, Building The Sample Policy</li>\n<li>SELinux官方教材，”<a href=\"https://github.com/SELinuxProject/selinux-notebook\">The SELinux Notebook 4th Edition</a>“</li>\n</ul>\n",
            "tags": [
                "SELinux"
            ]
        }
    ]
}