{
    "version": "https://jsonfeed.org/version/1",
    "title": "Big Ben • All posts by \"安全\" category",
    "description": null,
    "home_page_url": "https://blog.zhougy.top",
    "items": [
        {
            "id": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "url": "https://blog.zhougy.top/2021/09/18/obsidian_posts/RBAC/",
            "title": "RBAC",
            "date_published": "2021-09-18T14:17:35.996Z",
            "content_html": "<p>RBAC, Role Based Access Control, 是SELinux的另一个重要的特性。但他并不是一种独立的控制方式，而是对TEAC的一种补充。其主要的作用是，构建SELinux提供的进程级的MAC机制与Linux的用户系统的映射关系。</p>\n<h1 id=\"RBAC工作原理\"><a href=\"#RBAC工作原理\" class=\"headerlink\" title=\"RBAC工作原理\"></a>RBAC工作原理</h1><p>RBAC并不提供强制访问控制，而是通过user，role，type之间的对应关系，来控制type_transition策略能否成功。</p>\n<h2 id=\"role-vs-type\"><a href=\"#role-vs-type\" class=\"headerlink\" title=\"role vs. type\"></a>role vs. type</h2><p>role based最基本的就是定义role到type到对应关系。使用role语句可以实现：<code>role role_name [types type_set];</code>。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">role user_r types user_t;</span><br><span class=\"line\">role user_r types &#123; staff_t, admin_t &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>role定义是累积的，即后面的对应关系不会覆盖前面语句定义的对应关系，而只会追加这种关系</li>\n<li>role语句通常定义在type声明附近，以确保该对应关系被及时定义</li>\n</ul>\n<blockquote>\n<p><strong>定义子role (period)</strong><br>A period is used to indicate restrictions on the set of types that may be assigned to a role. For example, the set of types for a role called <strong><em>apache.cgi</em></strong> must be a <strong><em>subset</em></strong> of the type set of a role called <strong><em>apache</em></strong>.</p>\n</blockquote>\n<p>role语句定义的基本逻辑就是，定义了role=&gt;{ types }集合的映射关系。当发生type transition时，如果转换后的{role，type}组合未定义，则视为权限错误。从这个层面看，role对应的是主体type，即domain type，而非object type。</p>\n<h3 id=\"特殊的role-object-r\"><a href=\"#特殊的role-object-r\" class=\"headerlink\" title=\"特殊的role: object_r\"></a>特殊的role: object_r</h3><p>object_r是内核SELinux模块预定义的一个role，无需在policy中声明。而这个object_r被专门用来定义客体的安全上下文。</p>\n<h2 id=\"user-vs-role\"><a href=\"#user-vs-role\" class=\"headerlink\" title=\"user vs. role\"></a>user vs. role</h2><p>user是对role的再一次扩充，通过user将role与Linux user的映射关系建立起来。SELinux的用户系统独立于Linux用户系统。通过seusers文件或者<code>semanage user</code>命令可以定义他们之间的映射关系。但实际可定义的自由度并没有那么高。</p>\n<blockquote>\n<p>The design decision for SELinux to have a distinct user identifier (rather than share that of Linux) is motivated by the desire to create an immutable SELinux user identifier.</p>\n</blockquote>\n<p>定义一个user与role的映射关系，可以使用user语句：<code>user user_name roles &#123; role_set &#125;;</code><br>user语句所体现的逻辑和role语句类似，即定义了user=&gt;{ roles }集合的映射关系。当应用启动时发生role transition时，如果转换后的{user, role}未定义，则视为权限错误。</p>\n<p>当SELinux通过RBAC，建立起user=&gt;role=&gt;type的映射关系以后，还获得了一个好处。Linux系统的用户数可能很多，而用户的类型很少。用户并不是为了定义权限的，不同的用户之间的使用数据需要隔离。但往往一类用户的权限是相同的。例如超级用户，管理员用户，普通用户等等。系统的权限集最小粒度由domain定义。可能每个进程的权限不同，也可能一组进程的权限相同。但往往domain的数量也很庞大。如果没有RBAC，我们需要定义user到domain到映射。这样也不是不能做，但却不太优雅。每次新增用户时，需要为新增用户绑定一堆domain。定义了role之后，role相当于较稳定的一层抽象，role到types的映射关系是在定义type时候就定义了的。增加新user的时候，只要定义user到role的映射即可。这就是引入RBAC的原因。</p>\n<pre class=\"mermaid\">graph LR\nA[user] --> B[role]\nA --> C[role]\nA --> D[role]\nC --> E[domain]\nC --> F[domain]\nC --> G[domain]</pre>\n\n<h3 id=\"Linux用户-vs-SELinux-user\"><a href=\"#Linux用户-vs-SELinux-user\" class=\"headerlink\" title=\"Linux用户 vs. SELinux user\"></a>Linux用户 vs. SELinux user</h3><ul>\n<li>当前系统的用户可以通过查看/etc/passwd文件获取，也可以参考<a href=\"https://zhuanlan.zhihu.com/p/41161408\">列出 Linux 系统上所有用户的 3 种方法</a>.</li>\n<li>查看SELinux的用户可以通过命令<code>semanage user -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               标记中        MLS/       MLS/                          </span><br><span class=\"line\">SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色</span><br><span class=\"line\"></span><br><span class=\"line\">guest_u         user       s0         s0                             guest_r</span><br><span class=\"line\">root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</span><br><span class=\"line\">staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r unconfined_r</span><br><span class=\"line\">sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r</span><br><span class=\"line\">system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r</span><br><span class=\"line\">user_u          user       s0         s0                             user_r</span><br><span class=\"line\">xguest_u        user       s0         s0                             xguest_r</span><br></pre></td></tr></table></figure></li>\n<li>查看两者的映射关系可以通过命令<code>semanage login -l</code>.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名                  SELinux 用户           MLS/MCS 范围           服务</span><br><span class=\"line\"></span><br><span class=\"line\">__default__          unconfined_u         s0-s0:c0.c1023       *</span><br><span class=\"line\">john                 user_u               s0                   *</span><br><span class=\"line\">root                 unconfined_u         s0-s0:c0.c1023       *</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Linux用户和SELinux用户的初始映射关系由seusers文件指定。这个文件不属于策略二进制的一部分，而可以直接修改生效。当然更优雅的办法是通过semanage命令来修改。<br>另外，在修改了context以后，或者新建了用户以后，必须要使用注销登录的方法，才能使新的context生效，而只使用su命令切换用户，并不会切换context。推测注销登录使用的是PAM登录程序，而su命令中，并没有重新加载user context的功能。<br>Linux用户登录后，获取shell安全上下文的步骤，可以参考文献【2】。简述如下：</p>\n<ol>\n<li>根据seusers文件，映射SELinux用户，如果没有seusers文件，系统就无法启动了。如果seusers文件没有对应的用户描述，则统一映射为<code>__default__</code>用户。如果<code>__default__</code>用户描述不存在，则无法登录。</li>\n<li>根据SELinux的搜索优先级，找到对应SELinux用户的安全上下文。</li>\n</ol>\n<blockquote>\n<p><strong>勘误</strong><br>在[1]中，对Linux用户和SELinux的映射关系有如下描述：<br>On login, if there is an SELinux user identifier that is exactly the same as the Linux user identifier, the matching SELinux user identifier becomes the user identifier in the security context for the initial shell process. In this way, if a Linux user identifier also exists as a user identifier in the SELinux policy, all login processes will set the initial shell process security context user identifier to that matching Linux identity.<br>经实验证明，并非如此：</p>\n<ul>\n<li>定义了一个guest_u用户，登录后，其shell的安全上下文仍为：<br><img src=\"/2021/09/18/obsidian_posts/RBAC/163C5090-847B-49EC-B709-3AAA87D776D9.png\" alt=\"1ca6909a350aa84947ea565bb4c8eaa2\"></li>\n<li>但事实证明，明明就有guest_u这个用户<br><img src=\"/2021/09/18/obsidian_posts/RBAC/CA68A544-BEE4-4B4E-9BC5-EA3452F816F9.png\" alt=\"7737fbc74190005733b9f01b60178907\"><br>推测，可能是因为SELinux也一直在发展改进中。[1]d 成书时间是2006年，彼时还是FC（Fedora Core）5的年代，现在最新版已经是Fedora 33，2020年10月份发布。</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在可以引用[1]中的一幅图来总结一下RBAC的工作原理了。<br><img src=\"/2021/09/18/obsidian_posts/RBAC/6903A6B7-B8D6-4621-8AF4-C276F4EAD57F.png\" alt=\"115b4d2e2576fd1b93937d66425645d5\"></p>\n<ul>\n<li>Linux系统有一个用户较joe</li>\n<li>SELinuxcelue中规定joe和user_r绑定，user_r和user_t绑定</li>\n<li>当joe登录时，系统根据seusers（此处与图不同，参见上一章勘误），找到对应的SELinux user，找不到就是<strong>default</strong>, <strong>default</strong>没有就不能登录了</li>\n<li>根据以下context文件顺序，决定其shell的安全上下文，即joe:user_r:user_t<ul>\n<li>/etc/selinux/specified-policy/contexts/users</li>\n<li>/etc/selinux/specified-policy/contexts/default_contexts</li>\n<li>/etc/selinux/specified-policy/contexts/failsafe_context</li>\n<li>sid kernel的安全上下文</li>\n</ul>\n</li>\n<li>joe执行了一个应用，开始进行domain_transition, 要从user_t切换到passwd_t<ul>\n<li>如果定义了<code>role user_r types passwd_t</code>和<code>role user_r types user_t</code>，则这次domain transition可以成功</li>\n<li>否则任意一个未定义，domain transition都会失败</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"高阶用法\"><a href=\"#高阶用法\" class=\"headerlink\" title=\"高阶用法\"></a>高阶用法</h1><h2 id=\"role-transition\"><a href=\"#role-transition\" class=\"headerlink\" title=\"role_transition\"></a>role_transition</h2><p>role transition和domain transition非常类似，也是在某个domain进程在执行某个可执行文件时，即exec系统调用时，切换进程主体的安全上下文。domain transition切换的时domain，role transtion切换的是role。实现方式通过以下两条语句：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allow staff_r sysadm_r; # 允许从staff_r切换到sysadm_r</span><br><span class=\"line\">role_transition sysadm_r http_exec_t system_r; # sysadm_r进程执行http_exec_t类型文件时，role切换为system_r</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"role-dominance\"><a href=\"#role-dominance\" class=\"headerlink\" title=\"role_dominance\"></a>role_dominance</h2><p>可以利用role来定义其他role，即role dominance。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dominance &#123; role super_r &#123;role sysadm_r; role secadm_r; &#125;</span><br></pre></td></tr></table></figure><br>上面例子中的super_r称为dominant role，它可以从它关联的role中即成types。但它只能继承该条语句之前关联的types。我们之前说role语句是可以累积的。那么在role_dominance语句之后定义的types，并不能动态的添加到dominant role上。</p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><p>跟role相关的主要是semnage的一些用法，另外[1]还介绍了一个apol的可视化工具，可以检索user和role的数据。我理解semanage通过命令行也都可以实现。</p>\n<ol>\n<li>前文介绍过的<code>semanage user -l</code>和<code>semanage login -l</code>, 前者用来查看所有SELinux的用户，后者用来查看Linux用户和SELinux用户两者的映射关系.</li>\n<li>Modify the default user on the system to the guest_u user<ul>\n<li><code>semanage login -m -s guest_u __default__</code></li>\n</ul>\n</li>\n<li>修改user和role的对应关系<ul>\n<li><code>semanage user -m -R &quot;message_filter_r unconfined_r&quot; user_u</code></li>\n</ul>\n</li>\n<li>添加一个用户并指定SELinux用户<ul>\n<li><code>useradd joe -Z user_u</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] <a href=\"https://app.yinxiang.com/shard/s10/nl/161681/ea41e2f7-d7a8-4629-9f8c-c08696f578af/\">SELinux by Example_ Using Security Enhanced Linux</a><br>[2] <a href=\"https://blog.csdn.net/keheinash/article/details/81047520\">SELinux初始化登录用户安全上下文的方法</a></p>\n",
            "tags": [
                "SELinux",
                "security"
            ]
        }
    ]
}